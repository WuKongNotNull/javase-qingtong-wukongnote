{"./":{"url":"./","title":"Java 青铜篇-首页","keywords":"","body":"javase-qingtong-wukongnote Java 入门，青铜篇教学文档，定位初学者 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/ 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 09:58:50 "},"computer-overview/computer-overview.html":{"url":"computer-overview/computer-overview.html","title":"认识计算机","keywords":"","body":"计算机概述 计算机概述 ​ (1)计算机 ​ (2)计算机硬件 ​ (3)计算机软件 ​ 系统软件：window,linux,mac ​ 应用软件：qq,微信 ​ (4)软件开发(理解) ​ 软件：是由数据和指令组成的。(计算器) ​ 开发：就是把软件做出来。 ​ 如何实现软件开发呢? ​ 就是使用开发工具和计算机语言做出东西来 ​ (5)语言 ​ 自然语言：人与人交流沟通的 ​ 计算机语言：人与计算机交流沟通的 ​ C,C++,C#,Java ​ (6)人机交换 ​ 图形界面：操作方便只管 ​ DOS命令：需要记忆一些常见的命令 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/computer-overview/computer-overview.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 10:31:08 "},"computer-overview/shortcuts-keyboard.html":{"url":"computer-overview/shortcuts-keyboard.html","title":"shortcuts-keyboard.md","keywords":"","body":"键盘功能键的认识和快捷键 功能键的认识 - tab - shift ctrl alt window键 空格 上下左右 回车 快捷键 全选 Ctrl+A 复制 Ctrl+C 粘贴 Ctrl+V 剪切 Ctrl+X 撤销 Ctrl+Z 保存 Ctrl+S 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/computer-overview/shortcuts-keyboard.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 10:34:43 "},"computer-overview/dos-command.html":{"url":"computer-overview/dos-command.html","title":"dos-command.md","keywords":"","body":"常见的DOS系统命令(掌握) 常见的如下 ​ 盘符的切换 ​ d:回车 ​ 目录的进入 ​ cd javase ​ cd javase\\day01\\code ​ 目录的回退 ​ cd.. ​ cd\\ ​ 清屏 ​ cls ​ 退出 ​ exit 其他的几个(了解) ​ 创建目录 ​ 删除目录 ​ 创建文件 ​ 删除文件 ​ 显示目录下的内容 ​ 删除带内容的目录 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/computer-overview/dos-command.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 10:35:52 "},"java-introduction/java-introduction.html":{"url":"java-introduction/java-introduction.html","title":"认识 Java","keywords":"","body":"作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/java-introduction/java-introduction.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 11:22:48 "},"java-introduction/java-history.html":{"url":"java-introduction/java-history.html","title":"java-history.md","keywords":"","body":"2.1 Java的发展史 2.1.1 Java的发展历程 当时人类已经发明了很多种消费类电子产品，包括微机、手机、手持电脑、录相机、电视机、洗衣机、冰箱、微波炉等等。他们认为要将这些设备数字化并用网络互联讲是今后的方向（物联网？）。绿色小组将这个需求归结成两个产品原型目标，即发明一种手持遥控设备来实现所有家电设备的互联（硬件）；发明一种程序设计语言，用它来编写能在这些设备上运行的小巧程序（软件）. 这个后来取名为“绿色小组”所要研究的产品就是十年后风靡IT界的数字家电、后PC设备和家庭网。事实证明，绿色小组的研究并不十分成功，直到2001年，Sun在数字家电方面的业绩并不很突出。但是，绿色小组的一个副产品，高斯林发明的Java程序设计语言，却深深改变了这个世界…… 1991年，为家电开发了“oak” ； 1996年Sun 公司发布了Java1.0； 它的后继者， Java1.1填补了最明显的空缺，极大地提高了反射能力，并为GUI编程增加了新的事件模型。尽管如此，它仍然具有很大的局限性。 1998年12月Java1.2发布，该版本用Swing取代了早期版本的GUI编程，从而比其先前版本更接近“一次编写，到处运行”的承诺； Java1.2发布3天后， Sun的市场部门把名字改为更响亮的“Java2标准版软件开发工具包1.2版”。 J2SE1.2----Java 2 Platform,Standard Edtion1.2 在标准版之外，还推出了J2ME和J2EE两种版本。 J2SE 5.0成为Java开发者的新一代平台。 2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。 2.1.2 Java之父 詹姆斯·高斯林，被称为Java之父。现任SUN公司副总裁及Sun研究院院士 ，他亲手设计了Java语言，并开发了Java编译器和JAVA虚拟机，使Java成为了世界上最流行的开发语言。 5年5月，Sun 公司开发了一门新的编程语言—Java。 当时目标是：创建能嵌入到消费类电子设备的软件。 詹姆斯·高斯林（Java之父）是这个项目的核心成员，最初被称为“Oak”，后来改名“Java”。 1995年Java语言诞生之后，迅速成为一种流行的编程语言。 1996年Sun公司推出了Java开发工具包，也就是JDK1.0,提供了强大的类库支持。 1998年推出了JDK1.2,又叫Java2，它是Java里程碑式的版本。 分为三个版本：Java SE、Java ME和Java EE 分别进军 桌面/嵌入式/企业级领域 出生于加拿大，是一位计算机编程天才。在卡内基·梅隆大学攻读计算机博士学位时，他编写了多处理器版本的Unix操作系统，是Java编程语言的创始人。 2.1.3 Java名字由来 Java这个名字是创始人员团队中，一名成员由于灵感想到的，他想起自己在Java岛（爪哇岛）上曾喝过一种美味的咖啡。 Java是印度尼西亚爪哇岛的英文名称，因盛产咖啡而闻名。Java语言中的许多库类名称，多与咖啡有关：如JavaBeans（咖啡豆）、NetBeans（网络豆）以及ObjectBeans(对象豆）等等。SUN和JAVA的标识也正是一杯正冒着热气的咖啡。 2.1.4 Java的面向对象 1.java的一个重要的特点就是面向对象（Object Oriented）； 2.面向对象是相对于面向过程（Process Oriented）来说的； 3.面向对象：先了解做一个什么样的盒子，再去找对应的工具来做； 4.面向过程：不去想向做什么样的盒子，随机取得工具去执行； 2.1.5 JAVA语言介绍、语言特性 1.java的语言特性：Java是一种高级的、严格检查数据类型的、面向对象的程序设计语言。Java还是一种平台无关的、健壮和安全的程序设计语言。 2.语言特性的介绍： 高级语言：相对于汇编语言而言的； 严格检查数据类型：如果需要定义一个变量，首先必须定义这个变量的类型； 面向对象：万物皆对象，世界上的每一个事务都可以通过对象来实现； 平台无关（可移植性、跨平台）：不同的操作系统，JAVA提供了适应不同操作系统的虚拟机（用于计算JAVA的CPU）； 支持分布式的网络应用：分布式简单而言就是客户端和服务器分开的，可以通过网络来进行通信； 安全性和健壮性：主要体现在java的强类型、异常处理、垃圾回收； 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/java-introduction/java-history.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 11:09:53 "},"java-introduction/dev-env.html":{"url":"java-introduction/dev-env.html","title":"dev-env.md","keywords":"","body":"开发环境的搭建与配置** 2.2.1 JDK定义 Java Development Kit的缩写：它是Java开发工具包。它提供了编译、运行Java程序所需的各种工具和资源。 2.2.3 JDK目录结构 bin目录：存放编译、运行java的可执行文件。 lib目录：存放java的类库文件。 jre目录：存放java运行环境文件。 2.2.4 JDK安装步骤 JDK的安装环境变量的配置 确认操作系统：我的电脑 ---- 右键查看属性 下载JDK版本：根据操作系统下载对应的JDK ​ 1）安装版： 2）解压版 解压到指定路径，注意不要使用中文路径； 3）临时环境变量 打开命令行：windows键+r 输入set命令： 显示所有环境变量 输入set path 命令： 显示path变量值 输入set test=abc 新增环境变量值为abc 输入set test= 删除环境变量 输入set path=%path%;D:\\Program Files\\jdk1.7.0_17\\bin 在path变量的值上面追加**D:\\Program Files\\jdk1.7.0_17\\bin** ​ 输入java –version 查看JDK版本 ​ 输入javac 查看环境变量是否可用 ​ PS：临时环境变量只对当前窗口有效。 4）永久环境变量 1、java_home 右击“我的电脑”，选择“属性”，点击“高级”选项卡，选择“环境变量”。进入如下对话框： 在系统变量栏，点击“新建”按钮，弹出如下对话框： 在变量名处填写java_home，变量值填写 (JDK的路径)，然后点击确定，这样java_home变量就 配置完成了。 2、classpath 可以参考java_home的配置过程，需要新建一个系统变量，不过classpath的变量名是classpath，变量 值是 .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar (要加.表示当前路径)。 3、path path变量在系统变量中已存在，要修改path变量只需要选中path变量，点击编辑即可。在变量值中加入 如下内容： %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin。建议把 JDK bin 的路径放在原有 path 的最前面。因为在%SystemRoot%\\system32 中还有一个 java.exe/javaw.exe，这是 Windows 操作系统自带的那个JRE， 如果我们自己装的话就不要用他默认的那个JRE 了，可以用我们自己装的。如果把 JDK bin 的 path 放在最前面的话会优先使用。 1 下载jdk安装包 2 安装成功后，记住安装路径 3 配置环境变量path 4 doc命令检测： java -vesion 查版本号 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/java-introduction/dev-env.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 11:12:21 "},"java-introduction/notepad-dev.html":{"url":"java-introduction/notepad-dev.html","title":"notepad-dev.md","keywords":"","body":"使用记事本开发Java 步骤 1、创建一个Test.txt文本文件(首字母大写) 2、编写符合Java语法的代码 3、保存，将后缀名改成 .java 4、在doc界面输入 指令 javac编译代码 5、在doc界面输入 指令 java 运行字节文件 2.4常见的问题 ​ (1)扩展名被隐藏 ​ 如何找到：工具--文件夹选项--查看--去除隐藏扩展名的那个勾勾 ​ (2)我要求文件名称和类名一致。 ​ 实际上不这样做也是可以的。 ​ 但是，注意： ​ javac后面跟的是文件名+扩展名 ​ java后面跟的类名不带扩展名 ​ (3)Java语言严格区分大小写，请注意。 ​ 还有就是单词不要写错了。 ​ (4)见到非法字符: \\65307肯定是中文问题。 ​ 我们写程序要求标点符号必须全部是英文状态。 ​ (5)括号的配对问题。 ​ 一般来说，括号都是成对出现的。 ​ (6)遇到 ​ 在类 HelloWorld 中找不到主方法, 请将主方法定义为 ​ 肯定是主方法的格式问题。 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/java-introduction/notepad-dev.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 11:13:15 "},"java-introduction/jvm.html":{"url":"java-introduction/jvm.html","title":"jvm.md","keywords":"","body":"Java虚拟机与跨平台原理 1.“一次编译，到处运行”的原理 2.JDK（Java Development Kit）：java开发工具包 由以下图形可以看出：JDK包含了JRE（java程序文件的可运行环境），JRE（Java SE Runtime Environment）包含了JVM（Java Virtual Machine），JVM包含了客户机和主机，而我们的java程序是运行在JVM中的。 ​ 3.提供的运行时环境 ​ JVM虚拟机的三大任务：1、加载代码、2校验代码、3执行代码 JVM是什么？ JVM是可运行Java字节码的虚拟计算机系统。 JVM具有一套虚拟机指令，运行编译后的 *.class文件。 JVM的优点是什么？ 它的优点是跨平台。 编写一次，随处运行。Write Once, Run Anywhere java程序可以在多种平台上运行。 比如： Windows系统、Linux系统、安卓系统、苹果系统等 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/java-introduction/jvm.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 11:15:51 "},"java-introduction/ide-dev.html":{"url":"java-introduction/ide-dev.html","title":"ide-dev.md","keywords":"","body":"使用Idea或者Eclipse开发Java 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/java-introduction/ide-dev.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 11:13:40 "},"java-introduction/first-program.html":{"url":"java-introduction/first-program.html","title":"first-program.md","keywords":"","body":"第一个java程序 1．HelloWorld.java public class HelloWorld { ​ ​ public static void main(String[] args) { ​ System.out.println(\"HelloWorld\"); ​ } } 代码说明： 1） public:如果有public修饰需要class名和文件名相同； 2） class：修饰类。 3） main函数：java程序的入口和出口，表示一个程序从main函数的第一行开始，到最后一行结束；要想正确运行一个java程序必须要有一个main函数(固定写法)； 4） System.out.println(\"HelloWorld\")：标准输出，表示在控制台输出字符串“HelloWorld”（字符串必须使用双引号）； 5） 编译.java源程序：javac HelloWorld.java；会在当前路径下生成HelloWorld.class 6） 运行程序：java HelloWorld；不需要加.class，因为JVM虚拟机去找的HelloWorld类，而不是HelloWorld.class文件； 2.CLASSPATH变量的说明 CLASSPATH：当使用java去运行.class文件的时候，首先从当前路径查找，如果当前路径没有，则在CLASSPATH所指定的路径下继续查找； 练习 1.使用记事本编辑‘’hello world‘’程序。 2.使用eclipse或者Idea编写‘’hello world‘’程序。 3.JDK和JRE分别是什么？它们的区别是什么？ 4.JVM的优势是什么？ 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/java-introduction/first-program.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 11:16:54 "},"basic-grammar/basic-grammar.html":{"url":"basic-grammar/basic-grammar.html","title":"基础语法","keywords":"","body":"3 基础语法 3.1Java内存划分 1. java定义了8中基本数据类型和引用数据类型（JDK预定义的引用数据类型和自定义的引用数据类型），java程序的执行会将内存划分为栈空间和堆空间 2. 栈空间:自动分配，不需要程序员去申请 1.栈空间存取数据的效率高。 2.栈中的数据按“先进后出”的方式管理。 3.栈空间存储空间较小，不能存放大量的数据。 4.JVM将基本类型的数据存放在栈空间。 3. 堆空间：需要程序员去申请 1、堆空间存取数据的效率最低； 2、数据存放的位置随机分配； 3、堆空间存储数据的空间大，能存放大容量的数据。 3.1标识符 由字母、数字、下划线（_）或者美元符号($)组成。 首字母以字母、下划线或者美元符号开头，不能以数字开头。 不能与关键字、布尔值和null相同。 区分大小写，没有长度限制，坚持见名知义的原则和驼峰命名法。 class MakeNameDemo { public static void main(String[] args) { //正确做法 int x = 100; //不能以数字开头 //int 1y = 100; int y1 = 100; //不能是Java中的关键字 //int public = 100; int Public = 100; } } 3.2注释 单行注释 //单行注释 多行注释 /* *多行注释 * */ 文档注释 /** *文档注释 *@author *@parameter *@return */ 3.3常量 在java中的常量是指在程序运行中值不变的量。 分类举例： 整型常量 123 浮点型常量 1.2f /1.2D 布尔常量 true / false 字符常量 ‘a’ 字符串常量 \"abc\" null常量 null 符号常量 final double PI=3.14 class ConstantDemo { public static void main(String[] args) { //字符串常量的输出 System.out.println(\"hello\"); //整数常量的输出 System.out.println(100); //小数常量的输出 System.out.println(100.10); //字符常量的输出 System.out.println('a'); System.out.println('A'); System.out.println('0'); //这个是有问题的 //System.out.println('ab'); //布尔常量的输出 System.out.println(true); System.out.println(false); } } public class TestFinal { public static void main(String[] args) { //计算圆的面积 final double PI=3.14; int r=2; //PI=8; double area=PI*r*r; System.out.println(\"圆的面积为：\"+area); } } 3.4变量 在java中的变量是指在程序运行中值可以改变的量，在高级语言中普遍使用变量来管理内存中的数据。 3.4.1变量的声明和使用 1.变量和字面量 ​ public static void main(String[] args) { ​ int i =100; ​ } 代码解析： 1） i：表示变量，可变的量； 2） 100：字面量，变量中存放的具体数据； 2.变量的命名 (1)首字母是英文字母、$或下划线，后面由字母、数字、 $、下划线组成； (2)变量的命名遵循见名知义的原则。 String name = \"jack\"; //姓名 int age = 25; //年龄 (3)Java变量名建议不用中文。 (使用中文并没有语法错误) (4)变量名首字母建议不用大写字母。 (5)用驼峰命名法命名多个单词组成的变量名。 ​ String userName = \"admin\"; (6)变量名不能使用关键字 PS：有关关键字值得我们注意的地方： （1）true、false和null为小写，而不是象在C++语言中那样为大写。 （2）无sizeof运算符，因为所有数据类型的长度和表示是固定的，与平台无关，不是象在C语言中那样数据类型的长度根据不同的平台而变化。这正是Java语言的一大特点。 （3）goto(保留字)和const不是Java编程语言中使用的关键字。 3.变量的定义（声明）： 类型 变量名1，变量名2**…**变量名n； ​ int a; ​ int b; int a,b,c; ​ 4.变量的初始化（第一次赋值）： 变量名=字面量 ​ 字面量可以是具体数值，也可以是返回数组的表达式； ​ 5.变量的作用域： 1、 Java用一对大括号作为语句块的范围，称为作用域。 2、作用域中的变量不能重复定义。 3、离开作用域，变量所分配的内存空间将被JVM（GC垃圾会是机制）回收。 示例1 /** *声明变量，在内存中开辟一个存储空间 *int number; *赋值，将数据放入到存储空间内 *number=1000; *上述合二为一,声明变量并赋值 *int number=1000; */ public class TestType { public static void main(String[] args) { double score = 98.5; String name = \"张三\"; char sex = '男'; System.out.println(\"本次考试成绩最高分： \" + score); System.out.println(\"最高分得主： \" + name); System.out.println(\"性别： \" + sex); } } 示例2 //实现数据的交换 public class TestChange { public static void main(String[] args) { int num1=5; int num2=6; System.out.println(\"交换前：\"); System.out.println(\"num1:\"+num1); System.out.println(\"num2:\"+num2); int temp=num1; num1=num2; num2=temp; System.out.println(\"交换后：\"); System.out.println(\"num1:\"+num1); System.out.println(\"num2:\"+num2); } } 3.5数据类型 Java是一种强类型的语言，针对每一种数据都定义了明确的数据类型。 数据类型分类： ​ A:基本数据类型 ​ B:引用数据类型(类,接口,数值) 3.5.1基本数据类型 数据类型 大小 取值范围 byte 1字节8位 -128 ~ +127 int 4字节32位 -2147483648（-231） ~ + 2147483647（231-1） short 2字节16位 -32768 （-215） ~ + 32767 （+215-1） long 8字节64位 -263 ~ + 263-1 float 4字节32位 1.4E-45 ~ 3.4E+38 , -1.4E-45 ~ -3.4E+38 double 8字节64位 4.9E-324 ~ 1.7E+308, -4.9E-324 ~ -1.7E+308 char 2字节16位 0~65535 boolean 1字节8位 true\\false 学习方法：可以将基本数据类型理解为一个个已经有固定大小的盒子，而JAVA程序在执行的过程中需要将用的数据存放在指定的大小的盒子中。 1.整数型 类型 存放数据大小 说明 字节型（byte） -2^7 ~ 2^7-1 使用一个8位的二进制来保存，其中1位为符号位。 短整型（short） -2^15 ~ 2^15-1 使用一个16位的二进制来保存，其中1位为符号位。 整型（int） -2^31 ~ 2^31-1 使用一个32位的二进制来保存，其中1位为符号位。 长整型（long） -2^63 ~ 2^63-1 使用一个64位的二进制来保存，其中1位为符号位。 PS：在给long类型赋值的时候，如果值大于2^31-1，那么需要在字面量后面加上L，不区分大小写，因为java中默认将输出作为int类型来计算。 ​ 2.浮点型： 1）浮点类型用于表示小数的数据类型。 2）浮点数原理:也就是二进制科学计数法。 3）Java的浮点类型有float和double两种。 4）Java默认浮点类型计算的结果是double类型，字面量也是double类型。 ​ 2.1）float：单精度浮点型 1）float类型共32位，1位为符号位, 指数8位, 尾数23位。 2）float的精度是23位（即能精确表达23位的数，超过就被截取了）。 3）小数是以尾数长度来表示精确度的，比如pi=3.1415的精度是4位。 4）float存储数据的范围大于int类型，但精度比int要小，因为int的精度是31位。 5）浮点型的取值范围： System.out.println(Float.MAX_VALUE); System.out.println(Float.MIN_VALUE); 6）定义浮点型并初始化，字面量后面需要加上F，不区分大小写 ​ float f = 10.98f; ​ 2.2）double：双精度浮点 1）double类型，1位符号位,11位指数,52位尾数。 2）double范围远远大于long，但double精度不如long。 3）定义double类型并初始化，字面量需要加上D，不区分大小写 ​ double d = 98.99d; ​ PS：注：浮点运算就是实数运算，由于计算机只能存储整数，所以实数都是约数，这样浮点运算是很慢的而且会有误差。 ​ 3.字符型：char 1）char类型的字面量可以是一个英文字母、字符或一个汉字，并且由单引号包括。 2）Java底层使用一个16位的整数来处理字符类型,该数值是一个字符的unicode编码值。 ​ 3）unicode a、unicode编码是全球范围内的编码方法。 b、unicode编码的英文部分与ASCII码兼容（ASCII表示范围0~128）, 同时英文字符和数字是连续编码的。 c、Java在处理char类型的数据时，在底层是按unicode码来处理的。 d、编码是什么？计算机硬件系统只能用0和1表示数，我们人为地做了规定，某个数还可以表示一个字符。 例如：65代表的字符是A ​ 4)转义字符：”\\” 转义字符是”\\”，通过转义字符，可表示一些特殊的字符。 或者将本身具有特殊含义的字符的特殊含义取消。 例如: '\\n' 表示回车 ​ '\\t' 表示制表位字符，一个制表符表示向右跳8-10个字符 ​ '\\\\' 表示\\ ​ '\\' ' 表示单引号 ​ '\\\"' 表示双引号 ​ 4.布尔型：boolean 1、什么是布尔类型 ： boolean类型用来表示肯定或否定两种可能。 2、为什么使用布尔类型？ 布尔类型常用在分支语句、循环语句中。 3、boolean类型的值有两个： true:表示肯定意义；false:表示否定意义； 4、布尔变量的定义 boolean isPass; 5、布尔变量的初始化 boolean isPass=true; isPass=59>=60; 注意：** ​ 整数默认是int类型 ​ 浮点数默认是double类型。 ​ 长整型后缀用L或者l标记。建议使用L。 ​ 单精度浮点数用F或者f标记。建议使用F。 class DataTypeDemo { public static void main(String[] args) { //定义变量的格式： //数据类型 变量名 = 初始化值; //定义一个字节变量 byte b = 10; System.out.println(10); System.out.println(b); //定义一个短整型变量 short s = 100; System.out.println(s); //定义一个整型变量 int i = 1000; System.out.println(i); //超过了int的范围 //int j = 1000000000000; long j = 1000000000000L; //long j = 100L; System.out.println(j); //定义浮点数据变量 float f = 12.345F; System.out.println(f); double d = 12.345; System.out.println(d); //定义字符变量 char ch = 'a'; System.out.println(ch); //定义布尔变量 boolean flag = true; System.out.println(flag); } } 3.5.2引用数据类型 一、 字符串 java中String为应用数据类型。它是一个特殊的引用数据类型，可以通过字面值的方式进行初始化 \\1. 使用new关键字进行初始化 ​ String str = new String(\"java\"); ​ System.out.println(str); \\2. 使用字面量的方式初始化 ​ String str = \"java\"; ​ System.out.println(str); PS：当String类型使用字面量的方式进行初始化的时候，其可以按照基本数据类型的处理方式来处理 ==运算符：用于基本数据类型的时候是比较值是否相同，用于引用数据类型是比较其内存地址 ​ String a = \"JAVA\"; ​ String b = \"JAVA\"; ​ System.out.println(a==b);//true ​ String a = new String(\"JAVA\"); ​ String b = new String(\"JAVA\"); ​ System.out.println(a==b);//false 3.6数据类型转换 不同的基本数据类型之间进行运算时需要进行类型转换。 1.小类型向大类型的转换 1) 小类型向大类型的转换会自动完成，即不需要程序员编写额外的代码，由JVM负责。提示：自动类型转换也叫\"隐式类型转换\"。 2) 自动转换的规则：符号位会自动扩展, 负数补1, 正数补0。 3) 自动类型转换包含以下情况： ​ (1)byte->short->int->long->float->double ​ (2)int和char类型的数据在某些情况下可以自动相互转换。 PS：小类型向大类型转换一般情况下是安全的。当小类型的精度高于大类型时要注意精度丢失的隐患 int i = 0x10000001; float f = i; System.out.println(i);// 268435457 System.out.println(f);// 2.68435456E8 ​ 2.大类型向小类型的转换 1、强转类型转换-简称强转 2、强制类型转换时，要注意边界数风险问题 ​ int i =129; ​ byte b = (byte) i; ​ System.out.println(i); //129 ​ System.out.println(b); //-127 ​ 3.int和char类型之间的转换 Java对char类型的数据在底层是按int类型来处理的。 ​ int--->char ​ int i =97; ​ char c = (char) i; ​ System.out.println(i);//97 ​ System.out.println(c);//a ​ char-->int ​ char c = 'A'; ​ int i = c; ​ System.out.println(c);//A ​ System.out.println(i);//65 ​ 字符型进行计算： ​ char c = 'A'; ​ System.out.println(c+1);//66 1.自动类型转换 byte b=2; int i=b; 2.强制类型转换 int i=10; byte b=(byte)i; short s=(short)i; class DataTypeDemo4 { public static void main(String[] args) { byte a = 3; int b = 4; //这个肯定没有问题 //int c = a + b; //byte c = 7; //这个是有问题的 //byte c = a + b; //用强制类型转换改进 byte c = (byte) (a + b); System.out.println(c); } } 思考题1：请问下面这个有没有问题 double d = 12.345; float f = d; 思考题2：看看下面两个定义有没有区别呢? float f1 = (float)12.345; float f2 = 12.345f; f1其实是通过一个double类型转换过来的。 而f2本身就是一个float类型。 */ class DataTypeDemo5 { public static void main(String[] args) { //把double赋值给float，加了强制类型转换 double d = 12.345; float f = (float)d; //看看下面两个定义有没有区别呢? float f1 = (float)12.345; float f2 = 12.345F; } } 实例演示 public class TypeChange { public static void main(String[] args) { double firstAvg = 81.29; // 第一次平均分 double secondAvg; // 第二次平均分 int rise = 2; secondAvg = firstAvg + rise; System.out.println(\"第二次平均分是：\" + secondAvg); } } 3.7Scanner(键盘录入) ​ (1)实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。 ​ (2)如何实现呢?目前就记住 ​ A:导包 ​ import java.util.Scanner; ​ 位置：在class的上边 ​ B:创建对象 ​ Scanner sc = new Scanner(System.in); ​ C:获取数据 ​ int x = sc.nextInt(); ​ (3)把三元运算符的案例加入键盘录入改进。 /* 为了让程序的数据更符合开发的数据，我们就加入了键盘录入。 让程序更灵活一下。 那么，我们如何实现键盘数据的录入呢? A:导包 格式： import java.util.Scanner; 位置： 在class上面。 B:创建键盘录入对象 格式： Scanner sc = new Scanner(System.in); C:通过对象获取数据 格式： int x = sc.nextInt(); */ import java.util.Scanner; class ScannerDemo { public static void main(String[] args) { //创建键盘录入数据对象 Scanner sc = new Scanner(System.in); System.out.println(\"请你输入一个数据：\"); int x = sc.nextInt(); System.out.println(\"你输入的数据是：\"+x); } } /* 键盘录入练习： 键盘录入两个数据，并对这两个数据求和，输出其结果 */ import java.util.Scanner; class ScannerTest { public static void main(String[] args) { //键盘录入两个数据，并对这两个数据求和，输出其结果 //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(\"请输入第一个数据：\"); int x = sc.nextInt(); System.out.println(\"请输入第二个数据：\"); int y = sc.nextInt(); //把键盘录入的数据进行相加即可 int sum = (x + y); System.out.println(\"sum:\"+sum); } } 练习 /* 键盘录入练习： 键盘录入两个数据，并对这两个数据求和，输出其结果 */ import java.util.Scanner; class ScannerTest { public static void main(String[] args) { //键盘录入两个数据，并对这两个数据求和，输出其结果 //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(\"请输入第一个数据：\"); int x = sc.nextInt(); System.out.println(\"请输入第二个数据：\"); int y = sc.nextInt(); //把键盘录入的数据进行相加即可 int sum = (x + y); System.out.println(\"sum:\"+sum); } } /* 练习： 键盘录入三个数据，获取这三个数据中的最大值 键盘录入两个数据，比较这两个数据是否相等 */ import java.util.Scanner; class ScannerTest3 { public static void main(String[] args) { //键盘录入三个数据，获取这三个数据中的最大值 //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(\"请输入第一个数据：\"); int a = sc.nextInt(); System.out.println(\"请输入第二个数据：\"); int b = sc.nextInt(); System.out.println(\"请输入第三个数据：\"); int c = sc.nextInt(); //获取这三个数据中的最大值 int temp = ((a > b)? a: b); int max = (temp > c? temp : c); System.out.println(\"max:\"+max); System.out.println(\"------------------\"); //键盘录入两个数据 System.out.println(\"请输入第一个数据：\"); int x = sc.nextInt(); System.out.println(\"请输入第二个数据：\"); int y = sc.nextInt(); //比较这两个数据是否相等 boolean flag = (x == y); System.out.println(\"flag:\"+flag); } } Scanner可以实现控制台输入数据。 import java.util.Scanner; public class TestScanner { public static void main(String[] args) { Scanner input=new Scanner(System.in); System.out.print(\"请输入您的姓名：\"); String name=input.next(); System.out.print(\"请输入您的号码：\"); int num=input.nextInt(); System.out.println(name+\"您好！您的等待号码为：\"+num); } } 示例 public class NumJudge { /** * 判断一个数字是否为偶数 */ public static void main(String[] args) { Scanner input=new Scanner(System.in); System.out.print(\"请输入一个数字：\"); int num=input.nextInt(); String result=(num%2==0)?\"偶数\":\"奇数\"; System.out.println(num+\"是\"+result); } } 3.8运算符 赋值运算符 A:=,+=,-=,*=,/=,%=等 ​ B:=叫做赋值运算符，也是最基本的赋值运算符 ​ int x = 10; 把10赋值给int类型的变量x。 ​ C:扩展的赋值运算符的特点 ​ 隐含了自动强制转换。 ​ ​ 面试题： ​ short s = 1; ​ s = s + 1; ​ ​ short s = 1; ​ s += 1; ​ 请问上面的代码哪个有问题? /* 赋值运算符： 基本的赋值运算符：= 把=右边的数据赋值给左边。 扩展的赋值运算符：+=,-=,*=,/=,%= += 把左边和右边做加法，然后赋值给左边。 */ class OperatorDemo { public static void main(String[] args) { //定义一个变量 int x = 10; //其他用法 int a,b; a = b = 10; System.out.println(a); System.out.println(b); System.out.println(\"-----------\"); //定义一个变量 int y = 10; y += 20; System.out.println(y); } } /* 面试题： short s=1;s = s+1; short s=1;s+=1; 上面两个代码有没有问题，如果有，那里有问题。 为什么第二个木有问题呢? 扩展的赋值运算符其实隐含了一个强制类型转换。 s += 1; 不是等价于 s = s + 1; 而是等价于 s = (s的数据类型)(s + 1); */ class OperatorTest { public static void main(String[] args) { //short s = 1; //s = s + 1; //System.out.println(s); short s = 1; s += 1; //好像是 s = s + 1; System.out.println(s); } } 算术运算符 ​ A:加号（+）、 减号（-）、 乘号（*）、 除号（/） 、取模（%） 、自增运算符（++） 、自减运算符（--） ​ B:+的用法 ​ a:加法 ​ b:正号 ​ c:字符串连接符 ​ C:/和%的区别 ​ 数据做除法操作的时候，/取得是商，%取得是余数 ​ D:++和--的用法 ​ a:他们的作用是自增或者自减 ​ b:使用 ​ **单独使用 ​ 放在操作数据的前面和后面效果一样。 ​ a++或者++a效果一样。 ​ **参与操作使用 ​ 放在操作数的前面：先自增或者自减，再参与操作 ​ int a = 10; ​ int b = ++a; ​ 放在操作数的后面：先参与操作，再自增或者自减 ​ int a = 10; ​ int b = a++; /* 运算符： 就是对常量和变量进行操作的符号。 分类：算术运算符，赋值运算符，比较运算符，逻辑运算符，位运算符，三目运算符 算术运算符： +,-,*,/,%,++,-- 注意事项： A:整数相除只能得到整数。如果想得到小数，必须把数据变化为浮点数类型 B:/获取的是除法操作的商，%获取的是除法操作的余数 */ class OperatorDemo { public static void main(String[] args) { //定义变量 int x = 3; //把3赋值给int类型的变量x int y = 4; System.out.println(x+y); System.out.println(x-y); System.out.println(x*y); System.out.println(x/y); //整数相除只能得到整数 //我就想得到小数，该肿么办呢? //只需要把操作的数据中任意的一个数据变为浮点数 System.out.println(x*1.0/y); //%的应用 System.out.println(x%y); //得到的是余数 } } /* ++,--运算符的使用： 单独使用： 放在操作数的前面和后面效果一样。(这种用法是我们比较常见的) 参与运算使用： 放在操作数的前面，先自增或者自减，然后再参与运算。 放在操作数的后面，先参与运算，再自增或者自减。 作用：就是对变量进行自增1或者自减1。 */ class OperatorDemo2 { public static void main(String[] args) { //定义两个变量 int x = 3; int y = 4; //字符串的拼接 //System.out.println(\"x:\"+x); //System.out.println(\"y:\"+y); System.out.println(\"x:\"+x+\",y:\"+y); //单独使用 //x++; //y--; ++x; --y; //System.out.println(x); System.out.println(\"x:\"+x+\",y:\"+y); //意外的类型,常量是不可以这样做的 //System.out.println(10++); System.out.println(\"-------------------\"); //参与运算使用 int a = 3; int b = 4; //int c = a++; //int d = b--; int c = ++a; int d = --b; System.out.println(\"a:\"+a); //4, 4 System.out.println(\"b:\"+b); //3, 3 System.out.println(\"c:\"+c); //3, 4 System.out.println(\"d:\"+d); //4, 3 //先输出后自增 int i =1; System.out.println(i++); // int i = 1; for (; i /* +的用法： A:加法 B:正号 C:字符串连接符 */ class OperatorDemo3 { public static void main(String[] args) { //加法 System.out.println(3+4); //正号 System.out.println(+4); System.out.println('a'); System.out.println('a'+1); //这里是加法 //字符串连接符 System.out.println(\"hello\"+'a'+1); System.out.println('a'+1+\"hello\"); } } /* ++,--的练习题 第一题： int a = 10; int b = 10; int c = 10; a = b++; c = --a; b = ++a; a = c--; 请分别计算出a,b,c的值 第二题： int x = 4; int y = (x++)+(++x)+(x*10); 请分别计算出x,y的值 */ class OperatorTest { public static void main(String[] args) { int a = 10; int b = 10; int c = 10; a = b++; //a=10,b=11,c=10 c = --a; //a=9,b=11,c=9 b = ++a; //a=10,b=10,c=9 a = c--; //a=9,b=10,c=8 System.out.println(\"a:\"+a); System.out.println(\"b:\"+b); System.out.println(\"c:\"+c); System.out.println(\"--------------\"); int x = 4; int y = (x++)+(++x)+(x*10); //4+6+60 //x=5,6 System.out.println(\"x:\"+x); System.out.println(\"y:\"+y); } } 关系运算符 ​ ​ A:==,!=,>,>=, ​ B:无论运算符两端简单还是复杂最终结果是boolean类型。 ​ C:千万不要把==写成了= /* 比较运算符： ==,!=,>,>=, y); System.out.println(x >= y); System.out.println(x 逻辑运算符 ​ ​ A:&,|,^,!,&&,|| ​ B:逻辑运算符用于连接boolean类型的式子 ​ C:结论 ​ &:有false则false ​ |:有true则true ​ ^:相同则false，不同则true。 ​ 情侣关系。 ​ !:非true则false，非false则true ​ ​ &&:结果和&是一样的，只不过有短路效果。左边是false，右边不执行。 ​ ||:结果和|是一样的，只不过有短路效果。左边是true，右边不执行。 /* 逻辑运算符： &,|,^,! &&,|| 特点： 逻辑运算符一般用于连接boolean类型的表达式或者值。 表达式：就是用运算符把常量或者变量连接起来的符合java语法的式子。 算术表达式：a + b 比较表达式：a == b 结论： &逻辑与:有false则false。 |逻辑或:有true则true。 ^逻辑异或:相同为false，不同为true。 举例：情侣关系。男男,男女,女男,女女 !逻辑非:非false则true，非true则false。 特点：偶数个不改变本身。 */ class OperatorDemo { public static void main(String[] args) { int a = 3; int b = 4; int c = 5; //&逻辑与 System.out.println((a > b) & (a > c)); //false & false = false System.out.println((a > b) & (a c)); //true & false = false System.out.println((a b) | (a > c)); //false | false = false System.out.println((a > b) | (a c)); //true | false = true System.out.println((a b) ^ (a > c)); //false ^ false = false System.out.println((a > b) ^ (a c)); //true ^ false = true System.out.println((a b)); //!false = true System.out.println(!(a b)); //!!false = false System.out.println(!!!(a > b)); //!!false = true } } /* &&和&的区别? 同理||和|的区别? A:最终结果一样。 B:&&具有短路效果。左边是false，右边不执行。 开发中常用的逻辑运算符： &&,||,! */ class OperatorDemo2 { public static void main(String[] args) { int a = 3; int b = 4; int c = 5; //&&双与 System.out.println((a > b) && (a > c)); //false && false = false System.out.println((a > b) && (a c)); //true && false = false System.out.println((a 位运算符 按位与运算符（&） 按位或运算符（|） 按位异或运算符（^） 按位取反运算符（~） 左移位运算符（>） 1．按位与运算（&） 参与运算的两个值，如果两个相应位都为1，则该位的结果为1，否则为0。 即：0&0=0，0&1=0，1&0=0，1&1=1 2．按位或运算（|） 参与运算的两个值，如果两个相应位都是0，则该位结果为0，否则为1。 即：0|0=0，0|1=1，1|0=1，1|1=1 3．按位异或运算（^） 参与运算的两个值，如果两个相应位的某一个是1，另一个是0，那么按位异或（^）在该位的结果为1。也就是说如果两个相应位相同，输出位为0，否则为1。 即：0^0=0，0^1=1，1^0=1，1^1=0 4．按位取反运算（~） 按位取反运算（~）属于一元运算符，它只对一个自变量进行操作（其他所有运算符都是二元运算符）。按位取反生成与输入位的相反的值——若输入0，则输出1；输入1，则输出0。 即：~0=1，~1=0 5．左移位运算符（ 运算符 int a=64,b; b=a //b=128 6．右移位运算符（>>与>>>） 运算符>>执行一个右移位（带符号），操作数的构成二进制位右移若干位，地位溢出舍弃，高位补充原来高位的值。（右移一位相当于除2取商） 例如： int a=16,b; b=a>>2; //b=4 ^的特殊用法:一个数据针对另一个数据位异或两次，该数不变 面试题 a:请实现两个变量的交换 ​ **采用第三方变量 ​ **用位异或运算符 ​ 左边a,b,a ​ 右边a^b ​ b:请用最有效率的方式计算出2乘以8的结果 ​ 2 /* 位运算符： &,|,^,~ >,>>> 注意： 要做位运算，首先要把数据转换为二进制。 */ class OperatorDemo { public static void main(String[] args) { //&,|,^,~ int a = 3; int b = 4; System.out.println(3 & 4); System.out.println(3 | 4); System.out.println(3 ^ 4); System.out.println(~3); } } /* 分析：因为是位运算，所以我们必须先把数据换算成二进制。 3的二进制：11 00000000 00000000 00000000 00000011 4的二进制：100 00000000 00000000 00000000 00000100 &位与运算：有0则0。 00000000 00000000 00000000 00000011 &00000000 00000000 00000000 00000100 ----------------------------------- 00000000 00000000 00000000 00000000 结果是：0 |位或运算：有1则1。 00000000 00000000 00000000 00000011 |00000000 00000000 00000000 00000100 ----------------------------------- 00000000 00000000 00000000 00000111 结果是：7 ^位异或运算：相同则0，不同则1。 00000000 00000000 00000000 00000011 &00000000 00000000 00000000 00000100 ----------------------------------- 00000000 00000000 00000000 00000111 结果是：7 ~按位取反运算符：0变1，1变0 00000000 00000000 00000000 00000011 ~11111111 11111111 11111111 11111100 (补码) 补码：11111111 11111111 11111111 11111100 反码：11111111 11111111 11111111 11111011 原码：10000000 00000000 00000000 00000100 结果是：-4 */ /* ^的特点：一个数据对另一个数据位异或两次，该数本身不变。 */ class OperatorDemo2 { public static void main(String[] args) { int a = 10; int b = 20; System.out.println(a ^ b ^ b); //10 System.out.println(a ^ b ^ a); //20 } } /* >:右移 最高位是0，左边补齐0；最高为是1，左边补齐1 >>>:无符号右移 无论最高位是0还是1，左边补齐0 面试题： 请用最有效率的方式写出计算2乘以8的结果? 2 * 8 2 > 把>>左边的数据除以2的移动次幂 System.out.println(24 >> 2); //24 / 2^2 = 24 / 4 = 6 System.out.println(24 >>> 2); System.out.println(-24 >> 2); System.out.println(-24 >>> 2); } } /* 计算出3的二进制：11 00000000 00000000 00000000 00000011 (00)000000 00000000 00000000 0000001100 >>的移动： 计算出24的二进制：11000 原码：10000000 00000000 00000000 00011000 反码：11111111 11111111 11111111 11100111 补码：11111111 11111111 11111111 11101000 11111111 11111111 11111111 11101000 1111111111 11111111 11111111 111010(00) 补码 补码：1111111111 11111111 11111111 111010 反码：1111111111 11111111 11111111 111001 原码：1000000000 00000000 00000000 000110 结果：-6 >>>的移动： 计算出24的二进制：11000 原码：10000000 00000000 00000000 00011000 反码：11111111 11111111 11111111 11100111 补码：11111111 11111111 11111111 11101000 11111111 11111111 11111111 11101000 0011111111 11111111 11111111 111010(00) 结果： */ /* 面试题： 请自己实现两个整数变量的交换 注意：以后讲课的过程中，我没有明确指定数据的类型，默认int类型。 */ class OperatorTest { public static void main(String[] args) { int a = 10; int b = 20; System.out.println(\"a:\"+a+\",b:\"+b); //方式1：使用第三方变量(开发中用的) /* int c = a; a = b; b = c; System.out.println(\"a:\"+a+\",b:\"+b); System.out.println(\"------------\"); */ //方式2：用位异或实现(面试用) //左边：a,b,a //右边：a ^ b /* a = a ^ b; b = a ^ b; //a ^ b ^ b = a a = a ^ b; //a ^ b ^ a = b System.out.println(\"a:\"+a+\",b:\"+b); */ //方式3：用变量相加的做法 /* a = a + b; //a=30 b = a - b; //b=10 a = a - b; //a=20 System.out.println(\"a:\"+a+\",b:\"+b); */ //方式4：一句话搞定 b = (a+b) - (a=b); //b=30-20=10,a=20 System.out.println(\"a:\"+a+\",b:\"+b); } } 三目运算符 ​ A:格式 ​ 比较表达式?表达式1:表达式2; ​ B:执行流程： ​ 首先计算比较表达式的值，看是true还是false。 ​ 如果是true，表达式1就是结果。 ​ 如果是false，表达式2就是结果。 ​ C:案例： ​ a:比较两个数据是否相等 ​ b:获取两个数据中的最大值 ​ c:获取三个数据中的最大值 /* 单目运算符：~3 双目运算符：3 + 4 三目运算符： 格式：比较表达式?表达式1:表达式2; 比较表达式:结果是一个boolean类型。 执行流程： 根据比较表达式的计算返回一个true或者false。 如果是true，就把表达式1作为结果。 如果是false，就把表达式2作为结果。 */ class OperatorDemo { public static void main(String[] args) { int x = 100; int y = 200; int z = ((x > y)? x: y); //int z = ((x /* 练习： 获取两个整数中的最大值 获取三个整数中的最大值 比较两个整数是否相同 */ class OperatorTest { public static void main(String[] args) { //获取两个整数中的最大值 int x = 100; int y = 200; int max = (x > y? x: y); System.out.println(\"max:\"+max); System.out.println(\"--------\"); //获取三个整数中的最大值 int a = 10; int b = 30; int c = 20; //分两步： //A:先比较a,b的最大值 //B:拿a,b的最大值在和c进行比较 int temp = ((a > b)? a: b); //System.out.println(temp); int max1 = (temp > c? temp: c); System.out.println(\"max1:\"+max1); //一步搞定 //int max2 = (a > b)?((a > c)? a: c):((b > c)? b: c); //这种做法不推荐。 //int max2 = a > b?a > c? a: c:b > c? b: c; //System.out.println(\"max2:\"+max2); System.out.println(\"--------\"); //比较两个整数是否相同 int m = 100; int n = 200; //boolean flag = (m == n)? true: false; boolean flag = (m == n); System.out.println(flag); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/basic-grammar/basic-grammar.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 17:04:09 "},"flow-control/flow-control.html":{"url":"flow-control/flow-control.html","title":"流程控制","keywords":"","body":"4-流程控制 流程控制用来控制程序中各语句的执行顺序。 4.1顺序结构 从上往下，依次执行。 /* 流程控制语句：可以控制程序的执行流程。 分类： 顺序结构 选择结构 循环结构 顺序结构： 从上往下，依次执行。 */ class ShunXuJieGouDemo { public static void main(String[] args) { System.out.println(\"程序开始了\"); System.out.println(\"我爱Java\"); System.out.println(\"程序结束了\"); } } 4.2选择结构 简单if结构 i. if语句 ​ if(返回boolean值的条件表达式){ ​ 语句组; ​ } 示例1 import java.util.Scanner; public class GetPrize { public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.print(\"输入张浩的Java成绩: \"); //提示要输入Java成绩 int score = input.nextInt(); //从控制台获取Java成绩 if ( score > 90 ) { //判断是否大于90分 System.out.println(\"老师说:不错，奖励一个iPhone5！\"); } } } 示例2 import java.util.Scanner; public class GetPrize2 { public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.print(\"输入张浩的Java成绩: \"); //提示要输入Java成绩 int score1 = input.nextInt(); //从控制台获取Java成绩 System.out.print(\"输入张浩的音乐成绩: \"); //提示要输入音乐成绩 int score2 = input.nextInt(); //从控制台获取音乐成绩 if ((score1>90 && score2>80) || (score1==100 && score2>70)) { System.out.println(\"老师说:不错，奖励一个iPhone5！\"); } } } if-else结构 if-else语句 ​ if(条件表达式){ ​ 语句组1 ​ }else { ​ 语句组2 ​ } import java.util.Scanner; public class SimpleIfElse { public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.print(\"输入张浩的Java成绩: \"); //提示要输入Java成绩 int score = input.nextInt(); //从控制台获取Java成绩 if ( score > 90 ) { System.out.println(\"老师说:不错，奖励一个iPhone5！\"); }else{ System.out.println(\"老师说:惩罚蹲5分钟马步！\"); } } } 多重if结构 import java.util.Scanner; public class ScoreAssess { public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.print(\"请输入考试成绩: \"); //提示要输入考试成绩 int score = input.nextInt(); //从控制台获取成绩 if (score >= 80) { // 考试成绩>=80 System.out.println(\"良好\"); } else if (score >= 60) { // 80>考试成绩>=60 System.out.println(\"中等\"); } else { // 考试成绩嵌套if结构 import java.util.*; public class RunningMatch { public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.print(\"请输入比赛成绩（s）：\"); double score = input.nextDouble(); System.out.print(\"请输入性别：\"); String gender = input.next(); if(score switch结构 switch语句（又称开关语句）是和case语句一起使用的，其功能是根据某个表达式的值在多个case引导的多个分支语句中选择一个来执行。它的一般格式如下： ​ switch (key) { ​ case value: ​ 语句块1; ​ break; ​ …… ​ default: ​ break; ​ } ​ 案例： ​ int i = 3; ​ switch (i) { ​ case 1: ​ System.out.println(1); ​ break; ​ case 2: ​ System.out.println(2); ​ break; ​ default: ​ System.out.println(\"default\"); ​ break; ​ } ​ • default语句是可选的，它接受除上面接受值的其他值，通俗的讲，就是谁也不要的都归它。 • case后面可以跟多个语句，这些语句可以不用大括号括起来。 • switch后面括号中表达式的值必须是符合**byte，char，short，int类型的常量表达式,jdk1.7以后可以使用String，而不能用浮点类型或long**类型。 • 一个switch语句可以代替多个if—else语句组成的分支结构，而switch语句从思路上显得更清晰 /* switch语句的注意事项： A:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的 B:default可以省略吗? 可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。 特殊情况： case就可以把值固定。 A,B,C,D C:break可以省略吗? 可以省略，但是结果可能不是我们想要的。 会出现一个现象：case穿透。 最终我们建议不要省略 D:default一定要在最后吗? 不是，可以在任意位置。但是建议在最后。 E:switch语句的结束条件 a:遇到break就结束了 b:执行到末尾就结束了 */ public class Compete2 { public static void main(String[] args) { int mingCi = 1; //名次 switch (mingCi){ case 1: System.out.println(\"参观麻省理工大学计算机学院组织1个月夏令营\"); break; case 2: System.out.println(\"奖励hp笔记本一部\"); break; case 3: System.out.println(\"奖励移动硬盘一部\"); break; default: System.out.println(\"没有任何奖励\"); } } } 4.3循环结构 while循环 语法： ​ 初始化语句; ​ while(判断条件语句){ ​ ​ 循环体语句; ​ 控制条件语句; ​ } 在循环刚开始时，会计算一次“条件表达式”的值。当条件为假时，将不执行循环体，直接跳转到循环体外，执行循环体外的后续语句；当条件为真时，便执行循环体。每执行完一次循环体，都会重新计算一次条件表达式，当条件为真时，便继续执行循环体，直到条件为假才结束循环。 public class WhileDemo1 { /* * while打印100遍 */ public static void main(String[] args) { int i = 1; while(i import java.util.Scanner; public class WhileDemo { /* * 如何使用while循环 */ public static void main(String[] args) { int count = 1; while(count public class WhileDemo { /* * 如何使用while循环 */ public static void main(String[] args) { String answer; //标识是否合格 Scanner input = new Scanner(System.in); System.out.print(\"合格了吗?(y/n)：\"); answer = input.next(); while(!\"y\".equals(answer)){ System.out.println(\"上午阅读教材！\"); System.out.println(\"下午上机编程！\\n\"); System.out.print(\"合格了吗?(y/n)：\"); answer = input.next(); } System.out.println(\"完成学习任务！\"); } } do-while循环 语法： ​ 初始化语句; ​ do { ​ 循环体语句; ​ 控制条件语句; ​ }while(判断条件语句); do-while循环与while循环的不同在于：它先执行循环中的语句，然后再判断条件是否为真，如果为真则继续循环；如果为假，则终止循环。因此，do-while循环至少要执行一次循环语句。 注意：while()后一定要加“；” ​ 案例：循环输出1=100； ​ int i =1; ​ do { ​ System.out.println(i); ​ i++; ​ } while (i import java.util.Scanner; public class DoWhileDemo { /* * 如何使用do-while循环 */ public static void main(String[] args) { Scanner input = new Scanner(System.in); String answer = \"\"; //标识是否合格 do{ System.out.println(\"上机编写程序！\"); System.out.print(\"合格了吗?(y/n)\"); answer = input.next(); System.out.println(\"\"); }while(!\"y\".equals(answer)); System.out.println(\"恭喜你通过了测试！\"); } } PS：while循环和do-while循环的区别 while循环只有当条件表达式为true的时候才会进入循环体，do-while循环首先执行一次循环体中的内容，无论条件表达式是否为true； for循环 语法 ​ for(初始化语句;判断条件语句;控制条件语句){ ​ 循环体语句; ​ } ​ ​ 执行流程： ​ a:执行初始化语句 ​ b:执行判断条件语句 ​ 如果这里是true，就继续 ​ 如果这里是false，循环就结束 ​ c:执行循环体语句 ​ d:执行控制条件语句 ​ e:回到b 增强for循环(JDK5.0之后的新特性) 可以用来处理数组中的每个元素(其它类型的集合也可以)，而不需要指定下标； ​ for (类型 变量 : 集合) { ​ ​ } ​ 类型：值集合中保存的数据的数据类型； ​ 变量：表示集合中的每一个元素； ​ 集合：需要处理的集合对象； /* 需求：请在控制台输出10次\"HelloWorld\" */ class ForDemo { public static void main(String[] args) { //最原始的做法 System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); System.out.println(\"----------\"); //这种做法不好,代码的重复度太高。 //所以呢，我们用循环改进 for(int x=1;x /* 需求： A:求1-100之和。 B:求出1-100之间偶数和 C:求出1-100之间奇数和(自己做) */ class ForDemo4 { public static void main(String[] args) { //求1-100之和。 int sum1 = 0; for(int x=1; x /* 需求：求5的阶乘。 什么是阶乘呢? n! = n*(n-1)! 规则 n! = n*(n-1)*(n-2)*...*3*2*1 求和思想。 求阶乘思想。 */ class ForDemo5 { public static void main(String[] args) { //定义最终结果变量 int jc = 1; //这里的x其实可以直接从2开始 //for(int x=1; x /* 需求：在控制台输出所有的”水仙花数” 分析： 我们都不知道什么叫\"水仙花数\"，你让我怎么做呢? 所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。 举例：153就是一个水仙花数。 153 = 1*1*1 + 5*5*5 + 3*3*3 = 1 + 125 + 27 = 153 A:三位数其实是告诉了我们范围。 B:通过for循环我们就可以实现获取每一个三位数 但是麻烦是如何获取这个三位数的个,十,百位上的数据 我们如何获取一个数据的个,十,百呢? 假设有个一个数据:153 ge: 153%10 = 3 shi: 153/10%10 = 5 bai：153/10/10%10 = 1 qian：x/10/10/10%10 wan: x/10/10/10/10%10 ... C:让ge*ge*ge+shi*shi*shi+bai*bai*bai和该数据比较 如果相同，就把该数据在控制台输出。 */ class ForDemo6 { public static void main(String[] args) { //三位数其实是告诉了我们范围。 for(int x=100; x 练习 /* 练习： 请在控制台输出满足如下条件的五位数 个位等于万位 十位等于千位 个位+十位+千位+万位=百位 分析： A:五位数就告诉了我们范围。 B:分解每一个五位数的个，十，百，千，万位上的数据 C:按照要求进行判断即可 */ class ForDemo7 { public static void main(String[] args) { //五位数就告诉了我们范围。 for(int x=10000; x /* 需求：统计”水仙花数”共有多少个 分析： A:首先必须知道什么是水仙花数 所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。 举例：153就是一个水仙花数。 153 = 1*1*1 + 5*5*5 + 3*3*3 = 1 + 125 + 27 = 153 B:定义统计变量，初始化值是0 C:三位数告诉了我们范围，用for循环就可以搞定 D:获取每一个三位数的个，十，百的数据 E:按照要求进行判断 F:如果满足要求就计数。 */ class ForDemo8 { public static void main(String[] args) { //定义统计变量，初始化值是0 int count = 0; //三位数告诉了我们范围，用for循环就可以搞定 for(int x=100; x /* 需求：请统计1-1000之间同时满足如下条件的数据有多少个： 对3整除余2 对5整除余3 对7整除余2 分析： A:定义统计变量,初始化值是0 B:1-1000之间是一个范围，用for很容易就可以实现。 C:每个数据要同时满足如下要求 x%3==2 x%5==3 x%7==2 D:如果满足条件，统计数据++即可，最后输出统计变量 */ class ForDemo9 { public static void main(String[] args) { //定义统计变量,初始化值是0 int count = 0; //1-1000之间是一个范围，用for很容易就可以实现。 for(int x=1; x import java.util.*; public class AverageScore{ /** * 统计80分以上学生比例 */ public static void main(String[] args){ int score; //每门课的成绩 int sum = 0; //成绩之和 double avg = 0.0; //平均分 Scanner input = new Scanner(System.in); System.out.print(\"输入学生姓名: \"); String name = input.next(); for(int i = 0; i import java.util.*; public class SumTable { /** * 输入整数，输出其加法表 */ public static void main(String[] args){ int i, j; Scanner input = new Scanner(System.in); System.out.print(\"请输入一个值： \"); int val = input.nextInt(); System.out.println(\"根据这个值可以输出以下加法表： \"); for(i = 0, j = val; i 多重循环 /* * 打印平行四边形 * */ public class PrintParallelogram { public static void main(String[] args) { //外层循环，执行五次，每次输出一行* for (int i = 1; i /* * 打印矩形 * */ public class PrintRect { public static void main(String[] args) { //外层循环，执行五次，每次输出一行* for (int i = 1; i /* * 打印等腰三角形 * */ public class PrintSJX { public static void main(String[] args) { //外层循环，执行五次，每次输出一行* for (int i = 1; i /* * 打印菱形 * */ public class PrintLX { public static void main(String[] args) { //外层循环，执行五次，每次输出一行* for (int i = 1; i /* * 打印9*9乘法表 */ public class Multiplication { public static void main(String[] args) { int i, j; // 循环变量 for (i = 1; i 练习 使用三种方式计算100以内偶数之和 public class EvenSum { /* * 计算100以内偶数之和 * 思考：还有没有其他方式？ */ public static void main(String[] args) { //使用while /*int sum = 0; //当前之和 int num = 2; //加数 while(num 4.5跳转语句 break语句 ​ A:用在循环和switch语句中，离开此应用场景无意义。 ​ B:作用 ​ a:跳出单层循环 ​ b:跳出多层循环，需要标签语句的配合 /** * break 中止当前循环 */ public class TestBreak { public static void main(String[] args) { int sum = 0; // 和 for (int i = 1; i 20) { System.out.print(\"当前数是:\" + i); break; } } } } /* break:中断的意思 使用场景： A:switch语句中 B:循环语句中。 (循环语句中加入了if判断的情况) 注意：离开上面的两个场景，无意义。 如何使用呢? A:跳出单层循环 B:跳出多层循环 要想实现这个效果，就必须知道一个东西。带标签的语句。 格式： 标签名: 语句 */ class BreakDemo { public static void main(String[] args) { //在 switch 或 loop 外部中断 //break; //跳出单层循环 for(int x=0; x 示例 import java.util.Scanner; public class BreakDemo { /** * 循环录入学生成绩，输入负数则退出 */ public static void main(String[] args) { int score; //每门课的成绩 int sum = 0; //成绩之和 int avg; //平均分 boolean isNegative = false; //是否为负数 Scanner input = new Scanner(System.in); System.out.print(\"输入学生姓名: \"); String name = input.next(); //输入姓名 for(int i = 0; i continue语句 ​ A:用在循环中，离开此应用场景无意义。 ​ B:作用 ​ a:跳出单层循环的一次，可以继续下一次 /** * 中止本次循环，进入下一次循环 */ public class TestContinue { public static void main(String[] args) { int sum = 0; // 定义一个变量，进行累加 for (int i = 1; i 示例 import java.util.Scanner; public class ContinueDemo { /** * 统计80分以上学生比例 */ public static void main(String[] args) { int score; // 成绩 int total; // 班级总人数 int num = 0; // 成绩大于或等于80分的人数 Scanner input = new Scanner(System.in); System.out.print(\"输入班级总人数: \"); total = input.nextInt(); // 输入班级总数 for (int i = 0; i return语句 ​ A:用于结束方法的，后面还会在继续讲解和使用。 ​ B:一旦遇到return,程序就不会在继续往后执行。 /* return:返回 其实它的作用不是结束循环的，而是结束方法的。 */ class ReturnDemo { public static void main(String[] args) { for(int x=0; x 练习 1.输出九九表 /* * 打印9*9乘法表 */ public class Multiplication { public static void main(String[] args) { int i, j; // 循环变量 for (i = 1; i 2.打印数列 public class ForEx { public static void main(String[] args){ for(int i = 100; i >= 5; i=i-5){ System.out.print(i+\" \"); } /* int i = 100; while(i>=5){ // System.out.print(i+\" \"); i-=5; }*/ // int i = 100; // do{ // System.out.print(i+\" \"); // i-=5; // }while(i>=5); } } 3.输出星期数 public class ShowDate { public static void main(String[] args){ //定义变量 int inputNum = -1; //记录用户输入 Scanner input = new Scanner(System.in); String date = \"\"; //记录星期几 //循环询问用户输入的数字 do{ //询问用户输入的数字： System.out.print(\"请输入数字（1~7），输入0结束：\"); inputNum = input.nextInt(); //分支：根据用户输入的内容，显示相应星期几 switch(inputNum){ case 1: //System.out.println(\"星期一\"); date = \"星期一\"; break; case 2: //System.out.println(\"星期二\"); date = \"星期二\"; break; case 3: System.out.println(\"星期三\"); date = \"星期三\"; break; case 4: //System.out.println(\"星期四\"); date = \"星期四\"; break; case 5: //System.out.println(\"星期五\"); date = \"星期五\"; break; case 6: //System.out.println(\"星期六\"); date = \"星期六\"; break; case 7: //System.out.println(\"星期日\"); date = \"星期日\"; break; case 0: break; default: System.out.println(\"您的输入有误！\"); break; } if(inputNum>=1 && inputNum 4.打印数字三角形 /* * 打印等腰三角形 * */ public class PrintSJX { public static void main(String[] args) { //外层循环，执行五次，每次输出一行* for (int i = 1; i 5. //打印矩形 public class PintPic1 { public static void main(String[] args) { for(int i=1;i 6 //打印平行四边形 public class PintPic2 { public static void main(String[] args) { for(int i=1;i 7 //打印等腰三角形 public class PintPic3 { public static void main(String[] args) { for(int i=1;i 8. //打印菱形 public class PintPic4 { public static void main(String[] args) { for(int i=1;i 9. //打印数字菱形 public class PintPic5 { public static void main(String[] args) { for(int i=1;i 10 //打印空心菱形 public class PintPic6 { public static void main(String[] args) { for(int i=1;i 11 /* * 编写Java程序，实现输出1~100中所有不能被7整除的数，并求其和。当累加和大于4000时，记录当前数，跳出循环。 要求：每输出4个数换行显示。 * */ public class Test { public static void main(String[] args) { int sum = 0; int i = 0; for(int num = 1;num4000){ System.out.println(\"\\n当前数：\"+num); break; } } } System.out.println(\"总和：\"+sum); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/flow-control/flow-control.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 17:39:49 "},"array/array.html":{"url":"array/array.html","title":"数组","keywords":"","body":"5-数组 5.1一维数组 5.1.1数组定义 1）数组是一个变量，存储相同数据类型的一组数据。 数组是一个长度固定的数据结构，它存储多个相同类型的数值。数组直接被Java编程语言所支持，数组也是一个对象(引用数据类型)。数组是一个Object类的一个不明显的扩展。 数组的特征： 有序、具有相同类型、通过数组名和下标确定数组中的元素。 数组的声明： a）数组的元素类型 数组变量名[]; b）数组的元素类型[] 数组变量名; 创建数组空间：创建数组空间可以在声明的时候进行创建，也可以先声明然后在创建空间。 数组名=new 数组元素类型[数组的长度]； **int**[] arr = **new** **int**[10]; 等同于下面的 **int**[] arr; arr=**new** **int**[10]; 2）如何使用数组? 声明数组 int[] a; 分配空间 a=new int[5]; 赋值 a[0]=1; 数据处理 a[0]=a[0]*10; 3)创建数组的3种方式 第一种 int[] a= new int[4]; a[0]=1; a[1]=2; a[2]=3;a[3]=4; 第二种(简写) int[] a=new int[]{1,2,3,4}; 第三种（再简写） int[] a={1,2,3,4}; 5.1.2数组的遍历 每个数组都有一个属性length，表示该数组可以存放元素的个数。Java环境会自定检测数组的下标是否越界。 //通过for循环遍历数组中的所用元素 **for** (**int** i = 0; i ​ //通过增强for循环遍历 **for** (**int** i : arr) { System.**out**.println(i); } 增强for循环是JDK5.0的新特性，内部使用的是迭代的方法iteratoer来实现的。只可以用来遍历集合不可以对集合中的元素进行赋值。 import java.util.Scanner; public class ArrayDemo { /** * 使用数组计算平均分 */ public static void main(String[] args) { int[] scores = new int[5]; //成绩数组 int sum = 0; //成绩总和 Scanner input = new Scanner(System.in); System.out.println(\"请输入5位学员的成绩：\"); for(int i = 0; i import java.util.Scanner; public class MaxScore { /** * 求数组最大值 */ public static void main(String[] args) { int[] scores = new int[5]; int max = 0; //记录最大值 System.out.println(\"请输入5位学员的成绩：\"); Scanner input = new Scanner(System.in); for(int i = 0; i max){ max = scores[i]; } } System.out.println(\"考试成绩最高分为：\" + max); } } 5.1.3数组元素的增加 import java.util.*; public class Insert { public static void main(String[] args) { int[] list = new int[6]; // 长度为为6的数组 list[0] = 99; list[1] = 85; list[2] = 82; list[3] = 63; list[4] = 60; int index = list.length; // 保存新增成绩插入位置 System.out.println(\"请输入新增成绩： \"); Scanner input = new Scanner(System.in); int num = input.nextInt(); // 输入要插入的数据 // 找到新元素的插入位置 for (int i = 0; i list[i]) { index = i; break; } } // 元素后移 for (int j = list.length - 1; j > index; j--) { list[j] = list[j - 1]; // index下标开始的元素后移一个位置 } list[index] = num;// 插入数据 System.out.println(\"插入成绩的下标是：\" + index); System.out.println(\"插入后的成绩信息是： \"); for (int k = 0; k 5.1.4数组元素的修改 5.1.5数组元素的删除 5.1.6数组的内存分配 5.2二维数组 (1)元素是一维数组的数组。 (2)格式： A:数据类型[][] 数组名 = new 数据类型[m][n]; B:数据类型[][] 数组名 = new 数据类型[m][]; C:数据类型[][] 数组名 = new 数据类型[][]{{...},{...},{...}}; D:数据类型[][] 数组名 = {{...},{...},{...}}; 5.2.1遍历二维数组 import java.util.Scanner; /** * 有5个班各5名学生某门课程的成绩，计算5个班各自的总成绩 * */ public class FiveTotal { public static void main(String[] args) { Scanner input=new Scanner(System.in); int [][] array = new int[5][5]; //5个班的成绩 //i:班级 j:各班级的学生 for(int i=0;i5.2.2冒泡排序 /* * 冒泡排序 * */ public class SortNum { public static void main(String[] args) { int[] scores={16,25,9,90,23}; for (int i = 0; i scores[j + 1]) { // 交换元素 int temp = scores[j]; scores[j] = scores[j + 1]; scores[j + 1] = temp; } } } System.out.println(\"冒泡排序后：\"); for(int score:scores){ System.out.print(score+\"\\t\"); } } } 5.2.3 八大排序 8种排序之间的关系: 1， 直接插入排序 （1）基本思想：在要排序的一组数中，假设前面(n-1)[n>=2] 个数已经是排 好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数 也是排好顺序的。如此反复循环，直到全部排好顺序。 （2）实例 （3）用java实现 package com.njue; public class insertSort { public insertSort(){ inta[]={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51}; int temp=0; for(int i=1;i=0&&temp} } 2，希尔排序（最小增量排序） （1）基本思想：算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。 （2）实例： （3）用java实现 public class shellSort { public shellSort(){ int a[]={1,54,6,3,78,34,12,45,56,100}; double d1=a.length; int temp=0; while(true){ d1= Math.ceil(d1/2); int d=(int) d1; for(int x=0;x=0&&temp} } 3.简单选择排序 （1）基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换； 然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。 （2）实例： （3）用java实现 public class selectSort { public selectSort(){ int a[]={1,54,6,3,78,34,12,45}; int position=0; for(int i=0;i} 4，堆排序 （1）基本思想：堆排序是一种树形选择排序，是对直接选择排序的有效改进。 堆的定义如下：具有n个元素的序列（h1,h2,…,hn),当且仅当满足（hi>=h2i,hi>=2i+1）或（hi （2）实例： 初始序列：46,79,56,38,40,84 建堆： 交换，从堆中踢出最大数 依次类推：最后堆中剩余的最后两个结点交换，踢出一个，排序完成。 （3）用java实现 import java.util.Arrays; public class HeapSort { int a[]={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51}; public HeapSort(){ heapSort(a); } public void heapSort(int[] a){ System.out.println(\"开始排序\"); int arrayLength=a.length; //循环建堆 for(int i=0;i=0;i--){ //k保存正在判断的节点 int k=i; //如果当前k节点的子节点存在 while(k*2+1} 5.冒泡排序 （1）基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。 （2）实例： （3）用java实现 public class bubbleSort { public bubbleSort(){ int a[]={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51}; int temp=0; for(int i=0;ia[j+1]){ temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } } for(int i=0;i} } 6.快速排序 （1）基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。 （2）实例： （3）用java实现 public class quickSort { int a[]={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51}; public quickSort(){ quick(a); for(int i=0;i} public int getMiddle(int[] list, int low, int high) { int tmp = list[low]; //数组的第一个作为中轴 while (low = tmp) { high--; } list[low] = list[high]; //比中轴小的记录移到低端 while (low public void _quickSort(int[] list, int low, int high) { if (low public void quick(int[] a2) { if (a2.length > 0) { //查看数组是否为空 _quickSort(a2, 0, a2.length - 1); } } } 7、归并排序 （1）基本排序：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。 （2）实例： （3）用java实现 import java.util.Arrays; public class mergingSort { int a[]={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51}; public mergingSort(){ sort(a,0,a.length-1); for(int i=0;i} public void sort(int[] data, int left, int right) { // TODO Auto-generated method stub if(left} public void merge(int[] data, int left, int center, int right) { // TODO Auto-generated method stub int [] tmpArr=new int[data.length]; int mid=center+1; //third记录中间数组的索引 int third=left; int tmp=left; while(left //从两个数组中取出最小的放入中间数组 if(data[left]} } 8、基数排序 （1）基本思想：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。 （2）实例： （3）用java实现 import java.util.ArrayList; import java.util.List; public class radixSort { int a[]={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,101,56,17,18,23,34,15,35,25,53,51}; public radixSort(){ sort(a); for(int i=0;i} public void sort(int[] array){ //首先确定排序的趟数; int max=array[0]; for(int i=1;imax){ max=array[i]; } } int time=0; //判断位数; while(max>0){ max/=10; time++; } //建立10个队列; List queue=new ArrayList(); for(int i=0;i queue1=new ArrayList(); queue.add(queue1); } //进行time次分配和收集; for(int i=0;i queue2=queue.get(x); queue2.add(array[j]); queue.set(x, queue2); } int count=0;//元素计数器; //收集队列元素; for(int k=0;k0){ ArrayList queue3=queue.get(k); array[count]=queue3.get(0); queue3.remove(0); count++; } } } } } 5.3Arrays工具类 5.3.1Arrays类排序数组 import java.util.Arrays; import java.util.Scanner; /* * Arrays排序5名学员成绩 * */ public class ArraysSortScore { public static void main(String[] args) { int[] scores=new int[5]; Scanner input=new Scanner(System.in); System.out.println(\"请输入5名学员的成绩：\"); //获取学员成绩 for(int i=0;i=0;i--){ System.out.print(scores[i]+\"\\t\"); } } } 5.3.2Arrays类的常用方法 import java.util.Arrays; public class ArraysMethod { public static void main(String[] args) { //equals(array1,array2) 的作用是：比较两个数组是否相等 System.out.println(\"----equals(array1,array2)方法：----\"); int [] arr1 = {10,50,40,30}; int [] arr2 = {10,50,40,30}; int [] arr3 = {60,50,85}; System.out.println(Arrays.equals(arr1, arr2)); //判断arr1与arr2的长度及元素是否相等 System.out.println(Arrays.equals(arr1, arr3)); //判断arr1与arr3的长度及元素是否相等 //sort(array) 的作用是：对数组array的元素进行升序排列 System.out.println(\"----sort(array)方法：----\"); int [] array = new int[]{80,66,70,54,98}; Arrays.sort(array); System.out.println(\"成绩排序后：\"); for(int i = 0; i 5.4数组高级篇 冒泡排序 相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处。同理，其他的元素就可以排好。 /* * 数组排序之冒泡排序： * 相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处 */ public class ArrayDemo { public static void main(String[] args) { // 定义一个数组 int[] arr = { 24, 69, 80, 57, 13 }; System.out.println(\"排序前：\"); printArray(arr); /* // 第一次比较 // arr.length - 1是为了防止数据越界 // arr.length - 1 - 0是为了减少比较的次数 for (int x = 0; x arr[x + 1]) { int temp = arr[x]; arr[x] = arr[x + 1]; arr[x + 1] = temp; } } System.out.println(\"第一次比较后：\"); printArray(arr); // 第二次比较 // arr.length - 1是为了防止数据越界 // arr.length - 1 - 1是为了减少比较的次数 for (int x = 0; x arr[x + 1]) { int temp = arr[x]; arr[x] = arr[x + 1]; arr[x + 1] = temp; } } System.out.println(\"第二次比较后：\"); printArray(arr); // 第三次比较 // arr.length - 1是为了防止数据越界 // arr.length - 1 - 2是为了减少比较的次数 for (int x = 0; x arr[x + 1]) { int temp = arr[x]; arr[x] = arr[x + 1]; arr[x + 1] = temp; } } System.out.println(\"第三次比较后：\"); printArray(arr); // 第四次比较 // arr.length - 1是为了防止数据越界 // arr.length - 1 - 3是为了减少比较的次数 for (int x = 0; x arr[x + 1]) { int temp = arr[x]; arr[x] = arr[x + 1]; arr[x + 1] = temp; } } System.out.println(\"第四次比较后：\"); printArray(arr); */ // 既然听懂了，那么上面的代码就是排序代码 // 而上面的代码重复度太高了，所以用循环改进 // for (int y = 0; y arr[x + 1]) { // int temp = arr[x]; // arr[x] = arr[x + 1]; // arr[x + 1] = temp; // } // } // } /* // 由于我们知道比较的次数是数组长度-1次，所以改进最终版程序 for (int x = 0; x arr[y + 1]) { int temp = arr[y]; arr[y] = arr[y + 1]; arr[y + 1] = temp; } } } System.out.println(\"排序后：\"); printArray(arr); */ //由于我可能有多个数组要排序，所以我要写成方法 bubbleSort(arr); System.out.println(\"排序后：\"); printArray(arr); } //冒泡排序代码 public static void bubbleSort(int[] arr){ for (int x = 0; x arr[y + 1]) { int temp = arr[y]; arr[y] = arr[y + 1]; arr[y + 1] = temp; } } } } // 遍历功能 public static void printArray(int[] arr) { System.out.print(\"[\"); for (int x = 0; x /* * 数组排序之选择排序： * 从0索引开始，依次和后面元素比较，小的往前放，第一次完毕，最小值出现在了最小索引处 */ public class ArrayDemo { public static void main(String[] args) { // 定义一个数组 int[] arr = { 24, 69, 80, 57, 13 }; System.out.println(\"排序前：\"); printArray(arr); /* // 第一次 int x = 0; for (int y = x + 1; y /* * 把字符串中的字符进行排序。 * 举例：\"dacgebf\" * 结果：\"abcdefg\" * * 分析： * A:定义一个字符串 * B:把字符串转换为字符数组 * C:把字符数组进行排序 * D:把排序后的字符数组转成字符串 * E:输出最后的字符串 */ public class ArrayTest { public static void main(String[] args) { // 定义一个字符串 String s = \"dacgebf\"; // 把字符串转换为字符数组 char[] chs = s.toCharArray(); // 把字符数组进行排序 bubbleSort(chs); //把排序后的字符数组转成字符串 String result = String.valueOf(chs); //输出最后的字符串 System.out.println(\"result:\"+result); } // 冒泡排序 public static void bubbleSort(char[] chs) { for (int x = 0; x chs[y + 1]) { char temp = chs[y]; chs[y] = chs[y + 1]; chs[y + 1] = temp; } } } } } 二分查找 /* * 查找： * 基本查找:数组元素无序(从头找到尾) * 二分查找(折半查找):数组元素有序 * * 分析： * A:定义最大索引，最小索引 * B:计算出中间索引 * C:拿中间索引的值和要查找的值进行比较 * 相等：就返回当前的中间索引 * 不相等： * 大 左边找 * 小 右边找 * D:重新计算出中间索引 * 大 左边找 * max = mid - 1; * 小 右边找 * min = mid + 1; * E:回到B */ public class ArrayDemo { public static void main(String[] args) { //定义一个数组 int[] arr = {11,22,33,44,55,66,77}; //写功能实现 int index = getIndex(arr, 33); System.out.println(\"index:\"+index); //假如这个元素不存在后有什么现象呢? index = getIndex(arr, 333); System.out.println(\"index:\"+index); } /* * 两个明确： * 返回值类型：int * 参数列表：int[] arr,int value */ public static int getIndex(int[] arr,int value){ //定义最大索引，最小索引 int max = arr.length -1; int min = 0; //计算出中间索引 int mid = (max +min)/2; //拿中间索引的值和要查找的值进行比较 while(arr[mid] != value){ if(arr[mid]>value){ max = mid - 1; }else if(arr[mid] max){ return -1; } mid = (max +min)/2; } return mid; } } /* * 注意：下面这种做法是有问题的。 * 因为数组本身是无序的，所以这种情况下的查找不能使用二分查找。 * 所以你先排序了，但是你排序的时候已经改变了我最原始的元素索引。 */ public class ArrayDemo2 { public static void main(String[] args) { // 定义数组 int[] arr = { 24, 69, 80, 57, 13 }; // 先排序 bubbleSort(arr); // 后查找 int index = getIndex(arr, 80); System.out.println(\"index:\" + index); } // 冒泡排序代码 public static void bubbleSort(int[] arr) { for (int x = 0; x arr[y + 1]) { int temp = arr[y]; arr[y] = arr[y + 1]; arr[y + 1] = temp; } } } } // 二分查找 public static int getIndex(int[] arr, int value) { // 定义最大索引，最小索引 int max = arr.length - 1; int min = 0; // 计算出中间索引 int mid = (max + min) / 2; // 拿中间索引的值和要查找的值进行比较 while (arr[mid] != value) { if (arr[mid] > value) { max = mid - 1; } else if (arr[mid] max) { return -1; } mid = (max + min) / 2; } return mid; } } import java.util.Arrays; /* * Arrays:针对数组进行操作的工具类。比如说排序和查找。 * 1:public static String toString(int[] a) 把数组转成字符串 * 2:public static void sort(int[] a) 对数组进行排序 * 3:public static int binarySearch(int[] a,int key) 二分查找 */ public class ArraysDemo { public static void main(String[] args) { // 定义一个数组 int[] arr = { 24, 69, 80, 57, 13 }; // public static String toString(int[] a) 把数组转成字符串 System.out.println(\"排序前：\" + Arrays.toString(arr)); // public static void sort(int[] a) 对数组进行排序 Arrays.sort(arr); System.out.println(\"排序后：\" + Arrays.toString(arr)); // [13, 24, 57, 69, 80] // public static int binarySearch(int[] a,int key) 二分查找 System.out.println(\"binarySearch:\" + Arrays.binarySearch(arr, 57)); System.out.println(\"binarySearch:\" + Arrays.binarySearch(arr, 577)); } } Arrays工具类的方法源码解析 Arrays工具类的方法源码解析 public static String toString(int[] a) public static void sort(int[] a) 底层是快速排序 public static int binarySearch(int[] a,int key) 开发原则： 只要是对象，我们就要判断该对象是否为null。 int[] arr = { 24, 69, 80, 57, 13 }; System.out.println(\"排序前：\" + Arrays.toString(arr)); public static String toString(int[] a) { //a -- arr -- { 24, 69, 80, 57, 13 } if (a == null) return \"null\"; //说明数组对象不存在 int iMax = a.length - 1; //iMax=4; if (iMax == -1) return \"[]\"; //说明数组存在,但是没有元素。 StringBuilder b = new StringBuilder(); b.append('['); //\"[\" for (int i = 0; ; i++) { b.append(a[i]); //\"[24, 69, 80, 57, 13\" if (i == iMax) //\"[24, 69, 80, 57, 13]\" return b.append(']').toString(); b.append(\", \"); //\"[24, 69, 80, 57, \" } } ----------------------------------------------------- int[] arr = {13, 24, 57, 69, 80}; System.out.println(\"binarySearch:\" + Arrays.binarySearch(arr, 577)); public static int binarySearch(int[] a, int key) { //a -- arr -- {13, 24, 57, 69, 80} //key -- 577 return binarySearch0(a, 0, a.length, key); } private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key) { //a -- arr -- {13, 24, 57, 69, 80} //fromIndex -- 0 //toIndex -- 5 //key -- 577 int low = fromIndex; //low=0 int high = toIndex - 1; //high=4 while (low >> 1; //mid=2,mid=3,mid=4 int midVal = a[mid]; //midVal=57,midVal=69,midVal=80 if (midVal key) high = mid - 1; else return mid; // key found } return -(low + 1); // key not found. } 选择排序 把0索引的元素，和索引1以后的元素都进行比较，第一次完毕，最小值出现在了0索引。同理，其他的元素就可以排好。 public static void selectSort(int[] arr) { for(int x=0; x 查找 查找 A:基本查找 针对数组无序的情况 public static int getIndex(int[] arr,int value) { int index = -1; for(int x=0; x value) { max = mid - 1; }else if(arr[mid] max) { return -1; } mid = (min+max)/2; } return mid; } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/array/array.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 12:07:52 "},"object-oriented/object-oriented.html":{"url":"object-oriented/object-oriented.html","title":"面向对象","keywords":"","body":"1-面向对象 1.1类与对象 面向对象作为一种思想及编程语言，为软件开发的整个过程：从分析设计到实现，提供了一个完整解决方案。面向对象堪称是软件发展取得的里程碑式的伟大成就。 从80年代后期开始，进行了面向对象分析（OOA）、面向对象设计（OOD）和面向对象程序设计（OOP）等新的系统开发方式模型的研究 。 类与对象的概念： 对象：现实世界中每个事务都是一个对象；即某一个类型事务的实例。 类：对象的抽象称之为类；分类、类型、模型。 万物皆对象。 对象用来描述客观事物的一个实体，由一组属性和方法构成。 对象有2大特征： 属性：对象具有的各种特征； 方法：对象可以执行的操作或者具备的功能； 类和对象的关系 类是对象的抽象化。 对象是类的具体化。 PS：每一个苹果我们可以把它看作成一个对象，一个实例。将所有的苹果抽象出来的叫做苹果类。蚂蚁和小鸟都是动物类的一个对象、实例。 //定义School类 public class School { //属性或成员变量 String schoolName; //学校名称 int classNumber; //教室数目 int labNumber; //实验室数目 //无参构造器 public School(){} //含参构造器 public School(String schoolName,int classNumber,int labNumber){ this.schoolName=schoolName; this.classNumber=classNumber; this.labNumber=labNumber; } //定义的方法 public void showCenter(){ System.out.println(schoolName + \"培养学生\\n\" + \"具有：\" + classNumber + \"个教室\" + labNumber + \"个实验室\"); } } 1.2创建对象与方法的调用 如果需要去访问类中的属性和方法，则需要先创建该类的对象。 调用属性：对象名.属性名; 调用方法：对象名.方法名(参数列表); public class Person { String name; // 定义属性，人的姓名 int age; // 定义属性，人的年龄 /** * 定义方法，显示人的姓名和年龄 */ public void show() { // +和字符串一起使用的时候表示连接而非加分运算 System.out.println(\"姓名:\" + name + \",年龄:\" + age); } public static void main(String[] args) { Person person = new Person(); // 创建人的对象，即某一个成员 person.name = \"jack\"; // 初始化人的姓名，通过赋值=将jack赋值给该对象的姓名属性 person.age = 34; // 初始化人的年龄，通过赋值=将34赋值给该对象的年龄属性 person.show(); // 调用show()方法 } } PS:通过对象调用属性和方法，可以在同一个类的main方法中调用，也可以在不同的类中进行调用。 public class InitialSchool { public static void main(String[] args) { School center = new School(); System.out.println(\"***初始化成员变量前***\"); center.showCenter(); center.schoolName = \"哈佛大学\"; //给schoolName属性赋值 center.classNumber = 10; //给classNumber属性赋值 center.labNumber = 10; //给labNumber属性赋值 System.out.println(\"\\n***初始化成员变量后***\"); center.showCenter(); } } 1.3对象的内存图 1.4成员变量 属性直接赋值 public class InitialSchool { public static void main(String[] args) { //属性赋值 School mySchool = new School(); mySchool.schoolName = \"哈佛大学\"; //给schoolName属性赋值 mySchool.classNumber = 10; //给classNumber属性赋值 mySchool.labNumber = 10; //给labNumber属性赋值 mySchool.showCenter(); } } 构造器和方法重载 要使用面向对象，首先必须构造对象，并指定它们的初始状态，然后通过对象调用方法。 在java的语言设计种，使用构造函数(constructor)来构造新的实例，一个构造函数是新的方法，它的作用就是构造对象并进行初始化. （1）构造函数的方法名与类名相同。 （2）构造函数没有返回类型。 （3）构造函数的主要作用是完成对类对象的初始化工作。 （4）构造函数不能由编程人员显式地直接调用(用对象调用，使用new关键字掉用)。 （5）在创建一个类的新对象的同时，系统会自动调用该类的构造函数为新对象初始化。 public class Person { String name; int age; //要使用Person的方法，必须先创建Person类的对象，在创建对象的同时对name，age属性进行了初始化 public Person(String name, int age) { super(); this.name = name; this.age = age; } } 构造函数的特点有： （1）构造函数和类具有相同的名字。 （2）一个类可以有多个构造函数。 （3）构造函数可以有0个、1个或多个参数。 （4）构造函数没有返回值。 （5）构造函数总是和new关键字一起被调用。 public class Person { String name; int age; public Person() { } public Person(String name, int age) { super(); this.name = name; this.age = age; } public Person(String name) { super(); this.name = name; } public Person(int age) { super(); this.age = age; } } 构造函数的作用： （1）对象初始化 （2）引入更多的灵活度（成员变量赋值或更复杂的操作） （3）Java中可以不定义构造函数 Java中可以不定义构造函数，此时系统会自动为该系统生成一个默认的构造函数。这个构造函数的名字与类名相同，它没有任何形式参数，也不完成任何操作。 为了避免失去控制，一般将构造函数的声明与创建分开处理. 构造函数重载: 一个类可以有多个构造函数，如果一个类没有定义一个构造函数，Java 编译器将为这个类自动提供缺省构造函数(即无参的构造函数) ，缺省构造函数将成员变量的值初始化为缺省值，一旦创建了自己的构造函数， Java 编译器将不再自动提供无参的构造函数。 重载构造函数提供了一组创建对象的方式，可以根据需要决定是否带初始参数。根据参数列表决定调用的是哪个重载的构造函数。 构造函数重载：一个类中可以有多个构造函数，它们具有不同的参数列表(参数的类型、个数、顺序)。 public class Person { String name; int age; public Person() { System.out.println(\"无参的构造函数\"); } public Person(String name, int age) { this.name = name; this.age = age; System.out.println(\"带两个参数的构造函数1\"); } public Person(int age, String name) { this.name = name; this.age = age; System.out.println(\"带两个参数的构造函数2\"); } public Person(String name) { this.name = name; System.out.println(\"参数为name的构造函数\"); } public Person(int age) { this.age = age; System.out.println(\"参数为age的构造函数\"); } } 构造器赋值 public class InitialSchool { public static void main(String[] args) { //构造器赋值 School mySchool = new School(\"哈佛大学\",10,10); mySchool.showCenter(); } } 成员变量与局部变量区别 (1)在类中的位置不同 成员变量：类中方法外 局部变量：方法定义中或者方法声明上 (2)在内存中的位置不同 成员变量：在堆中 局部变量：在栈中 (3)生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 (4)初始化值不同 成员变量：有默认值 局部变量：没有默认值，必须定义，赋值，然后才能使用 //定义School类 public class School { //属性或成员变量 String schoolName; //学校名称 int classNumber; //教室数目 int labNumber; //实验室数目 public void welcome(){ for(int i=0;i++;i 1.5成员方法 语法 修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) { 方法体语句; return 返回值; } 修饰符：目前就用 public static。后面再详细讲解其他修饰符 返回值类型：就是功能结果的数据类型 方法名：就是起了一个名字，方便我们调用该方法。 参数类型：就是参数的数据类型 参数名：就是变量 参数分类： 实参：实际参与运算的数据 形参：方法上定义的，用于接收实际参数的变量 方法体语句：就是完成功能的代码块 return：结束方法 返回值：就是功能的结果，由return带给调用者。 返回值类型：结果的数据类型 参数列表：参数的个数及对应的数据类型 无参方法 //定义榨汁机 public class FruitMachine { //无参方法 public String zhazhi () { String juice = \"菠萝汁\"; return juice; } public static void main(String[] args){ /*调用水果机方法*/ FruitMachine myFruitMachine = new FruitMachine(); String fruit = \"菠萝\"; String myJuice = myFruitMachine.zhazhi(fruit); System.out.println(myJuice); } } 含参方法 //定义榨汁机 public class FruitMachine { //含参方法 public String zhazhi ( String fruit ) { String juice = fruit + \"汁\"; return juice; } public static void main(String[] args){ /*调用水果机方法*/ FruitMachine myFruitMachine = new FruitMachine(); String fruit = \"菠萝\"; String myJuice = myFruitMachine.zhazhi(fruit); System.out.println(myJuice); } } 数组为参方法 //学生类 public class Student { //属性 public String name;//姓名 public int score; //成绩 //方法 public void showInfo(){ System.out.println(name+\"的成绩是：\"+score); } } public class StudentManager { //输出学员信息(数组为入参) public void showInfo(Student[] stus){ for(Student stu:stus){ stu.showInfo(); } } public static void main(String[] args) { Student s1=new Student(); s1.name=\"吴彦祖\"; s1.score=40; Student s2=new Student(); s2.name=\"王菲\"; s2.score=90; Student s3=new Student(); s3.name=\"鹿晗\"; s3.score=43; Student[]stus=new Student[3]; stus[0]=s1; stus[1]=s2; stus[2]=s3; StudentManager ms=new StudentManager(); ms.showInfo(stus); } } 参数传递 基本数据类型和引用数据类型的区别 1.6方法与方法重载 构造方法重载 在同一个类中，构造方法名相同、参数列表不同、与返回值和访问修饰符无关。 //定义School类 public class School { //属性或成员变量 public String schoolName; //学校名称 public int classNumber; //教室数目 public int labNumber; //实验室数目 //构造方法 public School() { } public School(String schoolName) { this.schoolName = schoolName; } public School(int classNumber) { this.classNumber = classNumber; } public School(String schoolName, int classNumber) { this.schoolName = schoolName; this.classNumber = classNumber; } public School(int classNumber, int labNumber) { this.classNumber = classNumber; this.labNumber = labNumber; } public School(String schoolName, int classNumber, int labNumber) { this.schoolName = schoolName; this.classNumber = classNumber; this.labNumber = labNumber; } } **注意**：默认情况下，系统自行添加无参构造方法（无参构造函数）。 //定义School类 public class School { //属性或成员变量 public String schoolName; //学校名称 public int classNumber; //教室数目 public int labNumber; //实验室数目 //系统默认生成无参构造函数，不需要手写。 /*public School() { *} */ } 一般方法重载 同一个类中多个方法有相同的名字，不同的参数列表（参数的个数，类型，顺序），和返回值类型无关，这种情况称为方法重载。 当重载方法被调用时，Java编译器根据参数的类型、数量、顺序来确定实际调用哪个重载方法的版本。方法重载不考虑方法的返回类型。 public class Calculate { public int getSum(int num1,int num2){ System.out.println(\"int\"); return num1+num2; } public double getSum(double num1,double num2){ System.out.println(\"double\"); return num1+num2; } public double getSum(double num1,double num2,double num3){ return num1+num2+num3; } public static void main(String[] args) { Calculate calc=new Calculate(); System.out.println(calc.getSum(10, 20)); System.out.println(calc.getSum(10.1, 20.2)); System.out.println(calc.getSum(10.1, 20.2,30.3)); } } 1.7this关键字的使用 this关键字：与对象关联，表示当前对象（实例），即new出的是哪个对象，代表的就是哪个对象. this关键字的作用：可以调用调用类中的构造方法，普通方法，成员变量。this调用构造方法只能是在构造方法中使用，必须是第一行. public class Person { String name; int age; public Person() { this(\"jack\");//如果使用this调用构造方法，必须在第一行，只能在构造方法种调用构造方法。 System.out.println(\"无参的构造函数\"); this.show(); } public Person(String name) { this(20); System.out.println(\"参数为name的构造函数\"); } public Person(int age) { System.out.println(\"参数为age的构造函数\"); } public void show(){ //this(); //不可调用。 System.out.println(\"show\"); } public static void main(String[] args) { new Person(); } } 调用属性 //定义School类 public class School { //属性或成员变量 String schoolName; //学校名称 int classNumber; //教室数目 int labNumber; //实验室数目 //使用this调用属性 public void showCenter(){ System.out.println(this.schoolName + \"培养学生\\n\" + \"具有：\" + this.classNumber + \"个教室\" + this.labNumber + \"个实验室\"); } } 调用方法 //定义School类 public class School { //属性或成员变量 String schoolName; //学校名称 int classNumber; //教室数目 int labNumber; //实验室数目 public void welcome(){ System.out.println(\"同学们，大家好！\"); } public void showCenter(){ //使用this调用方法 this.welcome(); System.out.println(schoolName + \"培养学生\\n\" + \"具有：\" + classNumber + \"个教室\" + labNumber + \"个实验室\"); } } 调用构造方法 **注意**：如果使用，必须是构造方法中的第一条语句。 //定义School类 public class School { //属性或成员变量 public String schoolName; //学校名称 public int classNumber; //教室数目 public int labNumber; //实验室数目 public School() { } public School(int classNumber, int labNumber) { this.classNumber = classNumber; this.labNumber = labNumber; } //在构造方法中，使用this关键字 public School(String schoolName, int classNumber, int labNumber) { this(classNumber,labNumber); this.schoolName = schoolName; } } 块级作用域 变量初始化： 任何变量在使用前必须被初始化，对于实例变量，Java 编译器会用缺省初始值自动进行初始化。对于局部变量java编译器不会自动初始化，局部变量在使用之前必须赋初值。 方法的参数： 方法的参数只有两种类型：基本数据类型和引用数据类型。 1.在Java中，参数的传递只有一种方式，就是按值传递（传递自身的拷贝）： 2.对于基本数据类型，传递的值就是变量自身的值 3.对于对象类型，传递的值就是对象的引用（而不是对象自身！） 方法不能改变传递给它的参数的自身 例1：基本数据类型作为参数 **public** **class** Test { **public** **void** change(**int** a){ a=20; } **public** **static** **void** main(String[] args) { **int** a = 10; System.**out**.println(a);//10 Test t = **new** Test(); t.change(a); System.**out**.println(a);//10 } } 例2：对象类型作为参数 当对象作为参数时，在方法中只能改变对象的状态不能改变对象的引用 **public** **class** Test { **public** **void** change(Person person) { person.age = 20;// 试试下面的代码 // Person person1 = new Person(); // person1.age = 30; // person = person1; } **public** **static** **void** main(String[] args) { Person person = **new** Person(); person.age = 10; System.**out**.println(person.age);// 10 Test t = **new** Test(); t.change(person); System.**out**.println(person.age);//20 } } **class** Person { **int** age; } 例3：字符串作为传递参数 **public** **class** Test { **public** **void** change(String str) { str = \"jack\"; } **public** **static** **void** main(String[] args) { //字符串是一个特殊的引用数据类型。它的传递方式和基本数据类型一致 String str = \"tom\"; System.**out**.println(str); Test t = **new** Test(); t.change(str); System.**out**.println(str); } } 例4：数组作为传递参数 **public** **class** Test { **public** **void** change(**int**[] arr) { // arr[0]=20;//试试看 **int**[] arr2 = { 30 }; arr = arr2; } **public** **static** **void** main(String[] args) { **int**[] arr = { 10 }; System.**out**.println(arr[0]);// 10 Test t = **new** Test(); t.change(arr); System.**out**.println(arr[0]); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/object-oriented/object-oriented.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 17:23:29 "},"packaging/packaging.html":{"url":"packaging/packaging.html","title":"封装","keywords":"","body":"2-封装 2.1封装定义 a)封装是对象的一种隐藏技术，其目的是将对象中的属性和方法组织起来。同时隐藏不想暴露的属性和方法及实现细节。 b)用户或其它对象不能看到也无法修改其实现。只能通过接口去调用对象的方法，达到互相通信的目的。 c)封闭的目的在于将设计者与使用者分开。使用者不必知道实现的细节，只需用设计者提供的方法来访问该对象。 d)封装的手段是通过private**关键子来修饰需要封装的属性和方法** //定义School类 public class School { //属性的访问修饰符改成private private String schoolName; //学校名称 private int classNumber; //教室数目 private int labNumber; //实验室数目 //定义setter/getter方法 public String getSchoolName() { return schoolName; } public void setSchoolName(String schoolName) { this.schoolName = schoolName; } public int getClassNumber() { return classNumber; } public void setClassNumber(int classNumber) { this.classNumber = classNumber; } public int getLabNumber() { return labNumber; } public void setLabNumber(int labNumber) { this.labNumber = labNumber; } //定义的方法 public void showInfo(){ System.out.println(schoolName + \"培养学生\\n\" + \"具有：\" + classNumber + \"个教室\" + labNumber + \"个实验室\"); } public static void main(String[] args) { School school=new School(); school.setClassNumber(30); school.setLabNumber(10); school.setSchoolName(\"清华大学\"); school.showInfo(); } } 2.2包的定义和使用和导入 包名由小写字母组成，不能以圆点开头或结尾。 包名之前最好加上唯一的前缀，通常使用组织倒置的网络域名。 包名后续部分依不同机构内部的规范不同而不同。 一个类同时引用了两个来自不同包的同名类 必须通过完整类名来区分 每个包都是独立的，顶层包不会包含子包的类 package和import的顺序是固定的 package必须位于第一行（忽略注释行） 只允许有一个package语句 其次是import 接着是类的声明 //通过package定义包 package com.web; //通过import导入包 import java.util.*; //定义School类 public class School { } 2.3访问权限控制 属性的隐藏 属性的私有化，同时定义setter/getter方法访问属性。 包机制 包本质也是一种封装。 类的访问修饰符 public修饰符：公有访问级别 //public 修饰class,该类可以被一切访问 public class School { } 默认修饰符：包级私有访问级别 //默认修饰，该类只能被本包访问 class School { } 类成员的访问修饰符 本类 本包 子包 其他 private 可以 不可以 不可以 不可以 默认（default） 可以 可以 不可以 不可以 protected 可以 可以 可以 不可以 public 可以 可以 可以 可以 2.4static关键字** 修饰成员变量 静态变量，可以直接通过类名访问。 /* * 一群选民进行投票，每个选民只允许投一次票，并且当投票总数达到100时，就停止投票 * Voter：选民类 * */ public class Voter { private static int count; // 所有选民都会改变同一个数据：投票次数 private static final int MAX_COUNT = 100; // 最大投票数100适用于所有选民 private String name;// 投票人姓名 public Voter(String name) { this.name = name; } //投票 public void voteFor() { if(count==MAX_COUNT){ System.out.println(\"投票活动已经结束\"); return; }else{ count++; System.out.println(this.name + \"：感谢您投票！\"); } } } public class TestVoter { public static void main(String[] args) { Voter fan=new Voter(\"范冰冰\"); Voter liu=new Voter(\"刘亦菲\"); Voter wang=new Voter(\"王祖蓝\"); fan.voteFor(); liu.voteFor(); wang.voteFor(); for(int i=1;i static变量的作用： （1）能被类的所有实例共享，可作为实例之间进行交流的共享数据 （2）如果类的所有实例都包含一个相同的常量属性，可把这个属性定义为静态常量类型，从而节省内存空间. public class StaticTest { static int num; public static void main(String[] args) { num++; StaticTest st1=new StaticTest(); st1.num++; StaticTest st2=new StaticTest(); st2.num++; StaticTest.num++; System.out.println(num); } } 修饰成员变量的内存图 /* 定义一个人类 姓名和年龄都是变化的，这个我能接收，因为每个人的姓名和年龄是不同的。 但是，我们现在选取的几个人都是中国人，他们的国籍是一样的。 一样的国籍，我每次创建对象，在堆内存都要开辟这样的空间， 我就觉得有点浪费了。怎么办呢? 针对多个对象有共同的这样的成员变量值的时候， Java就提高了一个关键字来修饰：static。 */ class Person { //姓名 String name; //年龄 int age; //国籍 //String country; static String country; public Person(){} public Person(String name,int age) { this.name = name; this.age = age; } public Person(String name,int age,String country) { this.name = name; this.age = age; this.country = country; } public void show() { System.out.println(\"姓名：\"+name+\",年龄：\"+age+\",国籍：\"+country); } } class PersonDemo { public static void main(String[] args) { //创建对象1 Person p1 = new Person(\"邓丽君\",16,\"中国\"); p1.show(); //创建对象2 Person p2 = new Person(\"杨幂\",22); p2.show(); //创建对象3 Person p3 = new Person(\"凤姐\",20); p3.show(); p3.country = \"美国\"; p3.show(); p1.show(); p2.show(); } } 修饰成员方法 随着类的加载而加载，比如main方法。 优先于对象存在，被类的所有对象共享 可以通过类名调用，其实它本身也可以通过对象名调用。推荐使用类名调用。 静态方法只能访问静态变量和静态方法。 class Student { //非静态变量 int num = 10; //静态变量 static int num2 = 20; } class StudentDemo { public static void main(String[] args) { Student s = new Student(); System.out.println(s.num); System.out.println(Student.num2); System.out.println(s.num2); } } /* static关键字注意事项 A:在静态方法中是没有this关键字的 如何理解呢? 静态是随着类的加载而加载，this是随着对象的创建而存在。 静态比对象先存在。 B:静态方法只能访问静态的成员变量和静态的成员方法 静态方法： 成员变量：只能访问静态变量 成员方法：只能访问静态成员方法 非静态方法： 成员变量：可以是静态的，也可以是非静态的 成员方法：可是是静态的成员方法，也可以是非静态的成员方法。 简单记： 静态只能访问静态。 */ class Teacher { public int num = 10; public static int num2 = 20; public void show() { System.out.println(num); //隐含的告诉你访问的是成员变量 System.out.println(this.num); //明确的告诉你访问的是成员变量 System.out.println(num2); //function(); //function2(); } public static void method() { //无法从静态上下文中引用非静态 变量 num //System.out.println(num); System.out.println(num2); //无法从静态上下文中引用非静态 方法 function() //function(); function2(); } public void function() { } public static void function2() { } } class TeacherDemo { public static void main(String[] args) { //创建对象 Teacher t = new Teacher(); t.show(); System.out.println(\"------------\"); t.method(); } } /* * 一群选民进行投票，每个选民只允许投一次票，并且当投票总数达到100时，就停止投票 * Voter：选民类 * */ public class Voter { private static int count; // 所有选民都会改变同一个数据：投票次数 private static final int MAX_COUNT = 100; // 最大投票数100适用于所有选民 private String name;// 投票人姓名 public Voter(String name) { this.name = name; } //投票 public void voteFor() { if(count==MAX_COUNT){ System.out.println(\"投票活动已经结束\"); return; }else{ count++; System.out.println(this.name + \"：感谢您投票！\"); } } //打印投票结果;static修饰方法 public static void printResult(){ System.out.println(\"选民投票总数为：\"+count); //无法访问实例变量 //System.out.println(name); } } public class TestVoter { public static void main(String[] args) { Voter fan=new Voter(\"范冰冰\"); Voter liu=new Voter(\"刘亦菲\"); Voter wang=new Voter(\"王祖蓝\"); fan.voteFor(); liu.voteFor(); wang.voteFor(); for(int i=1;i 在实例方法里不可以定义static变量 。 public class Dog { private String name = \"泰迪\"; // 昵称 public void play(int n) { static int age=5; //是错误的 System.out.println(name+\" \"+age+\" \"); } public static void main(String[] args) { Dog d=new Dog(); d.play(5); } } 修饰代码块 静态代码块，当Java虚拟机加载类时，就会执行该代码块。如果有多个静态块，按顺序加载。 每个静态代码块只会被执行一次。 public class StaticTest { static int num=100; static{ num+=100; System.out.println(num); } static{ num+=100; System.out.println(num); } StaticTest st1=new StaticTest(); StaticTest st2=new StaticTest(); System.out.println(StaticTest.num); 2.5代码块 /* 代码块：在Java中，使用{}括起来的代码被称为代码块。 根据其位置和声明的不同，可以分为 局部代码块:局部位置,用于限定变量的生命周期。 构造代码块:在类中的成员位置,用{}括起来的代码。每次调用构造方法执行前，都会先执行构造代码块。 作用：可以把多个构造方法中的共同代码放到一起，对对象进行初始化。 静态代码块:在类中的成员位置,用{}括起来的代码,只不过它用static修饰了。 作用：一般是对类进行初始化。 面试题? 静态代码块,构造代码块,构造方法的执行顺序? 静态代码块 -- 构造代码块 -- 构造方法 静态代码块：只执行一次 构造代码块：每次调用构造方法都执行 */ class Code { static { int a = 1000; System.out.println(a); } //构造代码块 { int x = 100; System.out.println(x); } //构造方法 public Code(){ System.out.println(\"code\"); } //构造方法 public Code(int a){ System.out.println(\"code\"); } //构造代码块 { int y = 200; System.out.println(y); } //静态代码块 static { int b = 2000; System.out.println(b); } } class CodeDemo { public static void main(String[] args) { //局部代码块 { int x = 10; System.out.println(x); } //找不到符号 //System.out.println(x); { int y = 20; System.out.println(y); } System.out.println(\"---------------\"); Code c = new Code(); System.out.println(\"---------------\"); Code c2 = new Code(); System.out.println(\"---------------\"); Code c3 = new Code(1); } } /* 写程序的执行结果。 */ class Student { static { System.out.println(\"Student 静态代码块\"); } { System.out.println(\"Student 构造代码块\"); } public Student() { System.out.println(\"Student 构造方法\"); } } class StudentDemo { static { System.out.println(“StudentDemo中的静态代码块\"); } public static void main(String[] args) { System.out.println(\"我是main方法\"); Student s1 = new Student(); Student s2 = new Student(); } } // StudentDemo中的静态代码块 我是main方法 Student 静态代码块 Student 构造代码块 Student 构造方法 Student 构造代码块 Student 构造方法 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/packaging/packaging.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 17:39:49 "},"inherit/inherit.html":{"url":"inherit/inherit.html","title":"继承","keywords":"","body":"3-继承 3.1继承定义 (1)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系， 这多个类就具备了这些内容。这个关系叫继承。 (2)Java中如何表示继承呢?格式是什么呢? A:用关键字extends表示 B:格式： class 子类名 extends 父类名 {} (3)继承的好处： A:提高了代码的复用性 B:提高了代码的维护性 C:让类与类产生了一个关系，是多态的前提 (4)继承的弊端： A:让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。 原则：低耦合，高内聚。 耦合：类与类的关系 内聚：自己完成某件事情的能力 B:打破了封装性 (5)Java中继承的特点 A:Java中类只支持单继承 B:Java中可以多层(重)继承(继承体系) (6)继承的注意事项： A:子类不能继承父类的私有成员 B:子类不能继承父类的构造方法，但是可以通过super去访问 C:不要为了部分功能而去继承 (7)什么时候使用继承呢? A:继承体现的是：is a的关系。 B:采用假设法 (8)Java继承中的成员关系 A:成员变量 a:子类的成员变量名称和父类中的成员变量名称不一样，这个太简单 b:子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢? 子类的方法访问变量的查找顺序： 在子类方法的局部范围找，有就使用。 在子类的成员范围找，有就使用。 在父类的成员范围找，有就使用。 找不到，就报错。 B:构造方法 a:子类的构造方法默认会去访问父类的无参构造方法 是为了子类访问父类数据的初始化 b:父类中如果没有无参构造方法，怎么办? 子类通过super去明确调用带参构造 子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造 让父类提供无参构造 C:成员方法 a:子类的成员方法和父类中的成员方法名称不一样，这个太简单 b:子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢? 通过子类对象访问一个方法的查找顺序： 在子类中找，有就使用 在父类中找，有就使用 找不到，就报错 继承总结： 子类继承父类，继承了父类的所有属性和方法(包含私有的)，私有的不能直接访问； 一个类如果没有使用extends，那么它将继承Object类，Object类是所有类的父类，始祖类； 一个类可以继承多个类，但java中规定一个类只能直接继承一个类；可以间接继承； 子类具有扩展的功能，扩展子类特有的属性和方法； 继承大大提供了代码的重复利用性； 继承是Java中实现代码重用的重要手段之一。Java中只支持单根继承，即一个类只能有一个直接父类。将重复的代码抽取到父类。子类和父类是is-a的关系，比如猫是一个宠物。小狗是一个宠物。 /** * 宠物类，小狗和小猫的父类 */ public class Pet { private String name = \"待定\";// 昵称 private int health = 100;// 健康值 private int love = 20;// 亲密度 /** * 无参构造方法 */ public Pet() { } /** * 有参构造方法 * @param name 昵称 */ public Pet(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getHealth() { return health; } public void setHealth(int health) { if(health100){ System.out.println(\"健康值应该在0至100之间，默认值为60。\"); this.health=60; return; } this.health = health; } public int getLove() { return love; } public void setLove(int love) { if(love100){ System.out.println(\"亲密度应该在0至100之间，默认值为10。\"); this.love=10; return; } this.love = love; } /** * 输出宠物信息 */ public void print() { System.out.println(\"宠物的自我介绍：\\n我的名字叫\" + this.name + \"，我的健康值是\" + this.health + \"，我和主人的亲密程度是\" + this.love + \"。\"); } } /** * 狗狗类，宠物的子类 */ public class Dog extends Pet { private String strain=\"泰迪\";// 品种 //无参构造方法 public Dog() { } public String getStrain() { return strain; } public void setStrain(String strain) { this.strain = strain; } } /** * 小猫类，宠物的子类 */ public class Cat extends Pet { private String sex=\"公猫\";// 性别 //无参构造方法 public Cat() { } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } //测试类 public class Test { public static void main(String[] args) { // 1、创建宠物对象pet并输出信息 Pet pet = new Pet(\"欢喜宠物\"); pet.print(); // 2、创建狗狗对象dog并输出信息 Dog dog = new Dog(); dog.setName(\"旺财狗\"); dog.setHealth(90); dog.setLove(80); dog.setStrain(\"土狗\"); dog.print(); // 3、创建小猫对象cat并输出信息 Cat cat = new Cat(); cat.setName(\"大黑猫\"); cat.setHealth(98); cat.setLove(99); cat.setSex(\"母猫\"); cat.print(); } } 3.2super关键字 （1）使用super关键字,super代表父类对象 。 （2）super只能出现在子类的方法和构造方法中。 （3）在子类构造方法中调用且必须是第一句。 （4）不可以访问父类中定义为private的属性和方法。 子类访问父类构造器 /** * 狗狗类，宠物的子类 */ /*继承中构造方法的关系 A:子类中所有的构造方法默认都会访问父类中空参数的构造方法 B:为什么呢? 因为子类会继承父类中的数据，可能还会使用父类的数据。 所以，子类初始化之前，一定要先完成父类数据的初始化。 注意：子类每一个构造方法的第一条语句默认都是：super();*/ public class Dog extends Pet { private String strain=\"泰迪\";// 品种 //无参构造方法 public Dog() { } //通过supper，子类访问父类构造器 public Dog(String name,String strain){ supper(name); //supper的使用 this.strain=strain; } public String getStrain() { return strain; } public void setStrain(String strain) { this.strain = strain; } } /*----------------------------------分割线--------------------------------------------*/ public class Test { public static void main(String[] args) { Dog dog=new Dog(\"傻蛋狗\",\"哈士奇\"); dog.print(); } } /* 如果父类没有无参构造方法，那么子类的构造方法会出现什么现象呢? 报错。 如何解决呢? A:在父类中加一个无参构造方法 B:通过使用super关键字去显示的调用父类的带参构造方法 C:子类通过this去调用本类的其他构造方法 子类中一定要有一个去访问了父类的构造方法，否则父类数据就没有初始化。 注意事项： this(...)或者super(...)必须出现在第一条语句上。 如果不是放在第一条语句上，就可能对父类的数据进行了多次初始化，所以必须放在第一条语句上。 */ class Father { /* public Father() { System.out.println(\"Father的无参构造方法\"); } */ public Father(String name) { System.out.println(\"Father的带参构造方法\"); } } class Son extends Father { public Son() { super(\"随便给\"); System.out.println(\"Son的无参构造方法\"); //super(\"随便给\"); } public Son(String name) { //super(\"随便给\"); this(); System.out.println(\"Son的带参构造方法\"); } } class ExtendsDemo7 { public static void main(String[] args) { Son s = new Son(); System.out.println(\"----------------\"); Son ss = new Son(\"吴亦凡\"); } } 子类访问父类属性 super.成员变量 调用父类的成员变量 class Father { public int num = 10; } class Son extends Father { public int num = 20; public void show() { int num = 30; System.out.println(num); System.out.println(this.num); System.out.println(super.num); } } class ExtendsDemo5 { public static void main(String[] args) { Son s = new Son(); s.show(); } } 子类访问父类方法 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。 class Phone { public void call(String name) { System.out.println(\"给\"+name+\"打电话\"); } } class NewPhone extends Phone { public void call(String name) { //System.out.println(\"给\"+name+\"打电话\"); super.call(name); System.out.println(\"可以听天气预报了\"); } } class ExtendsDemo9 { public static void main(String[] args) { NewPhone np = new NewPhone(); np.call(\"吴亦凡\"); } } 3.3final关键字 (1)是最终的意思，可以修饰类，方法，变量。 (2)特点： A:它修饰的类，不能被继承。 B:它修饰的方法，不能被重写。 C:它修饰的变量，是一个常量。 (3)面试相关： A:局部变量 a:基本类型 值不能发生改变 b:引用类型 地址值不能发生改变，但是对象的内容是可以改变的 B:初始化时机 a:只能初始化一次。 b:常见的给值 定义的时候。(推荐) 构造方法中 /* final可以修饰类，方法，变量 特点： final可以修饰类，该类不能被继承。 final可以修饰方法，该方法不能被重写。(覆盖，复写) final可以修饰变量，该变量不能被重新赋值。因为这个变量其实常量。 常量： A:字面值常量 \"hello\",10,true B:自定义常量 final int x = 10; */ //final class Fu //无法从最终Fu进行继承 class Fu { public int num = 10; public final int num2 = 20; /* public final void show() { } */ } class Zi extends Fu { // Zi中的show()无法覆盖Fu中的show() public void show() { num = 100; System.out.println(num); //无法为最终变量num2分配值 //num2 = 200; System.out.println(num2); } } class FinalDemo { public static void main(String[] args) { Zi z = new Zi(); z.show(); } } /* 面试题：final修饰局部变量的问题 基本类型：基本类型的值不能发生改变。 引用类型：引用类型的地址值不能发生改变，但是，该对象的堆内存的值是可以改变的。 */ class Student { int age = 10; } class FinalTest { public static void main(String[] args) { //局部变量是基本数据类型 int x = 10; x = 100; System.out.println(x); final int y = 10; //无法为最终变量y分配值 //y = 100; System.out.println(y); System.out.println(\"--------------\"); //局部变量是引用数据类型 Student s = new Student(); System.out.println(s.age); s.age = 100; System.out.println(s.age); System.out.println(\"--------------\"); final Student ss = new Student(); System.out.println(ss.age); ss.age = 100; System.out.println(ss.age); //重新分配内存空间 //无法为最终变量ss分配值 ss = new Student(); } } /* final修饰变量的初始化时机 A:被final修饰的变量只能赋值一次。 B:在构造方法完毕前。(非静态的常量) */ class Demo { //int num = 10; //final int num2 = 20; int num; final int num2; { //num2 = 10; } public Demo() { num = 100; //无法为最终变量num2分配值 num2 = 200; } } class FinalTest2 { public static void main(String[] args) { Demo d = new Demo(); System.out.println(d.num); System.out.println(d.num2); } } /* 继承的代码体现 由于继承中方法有一个现象：方法重写。 所以，父类的功能，就会被子类给覆盖调。 有些时候，我们不想让子类去覆盖掉父类的功能，只能让他使用。 这个时候，针对这种情况，Java就提供了一个关键字：final final:最终的意思。常见的是它可以修饰类，方法，变量。 */ class Fu { public final void show() { System.out.println(\"这里是绝密资源,任何人都不能修改\"); } } class Zi extends Fu { // Zi中的show()无法覆盖Fu中的show() public void show() { System.out.println(\"这是一堆垃圾\"); } } class ZiDemo { public static void main(String[] args) { Zi z = new Zi(); z.show(); } } 3.4方法重写 方法重写 子类根据需求对从父类继承的方法进行重新编写。 重写时，可以用super.方法的方式来保留父类的方法。 构造方法不能被重写。 方法名相同,参数列表相同,返回值类型相同或是其子类。 访问权限不能严于父类。 父类的静态方法不能被子类覆盖为非静态方法,父类的非静态方法不能被子类覆盖为静态方法 子类可以定义与父类同名的静态方法，以便在子类中隐藏父类的静态方法(注：静态方法中无法使用super) 父类的私有方法不能被子类覆盖 不能抛出比父类方法更多的异常 public class Base { public void method1(){ System.out.println(\"父类的实例方法\"); } public static void method2(){ System.out.println(\"父类的静态方法\"); } public Base method3(){ System.out.println(\"父类返回值类型为base的方法\"); return new Base(); } private void method4(){ System.out.println(\"父类的私有方法\"); } } public class Sub extends Base{ //private void method1(){ //访问权限不能严于父类 //public static void method1(){ //父类的非静态方法不能被子类覆盖为静态方法 public void method1(){ System.out.println(\"子类的实例方法\"); } //public void method2(){ //父类的静态方法不能被子类覆盖为非静态方法 //子类可以定义与父类同名的静态方法，以便在子类中\"隐藏\"父类的静态方法 public static void method2(){ System.out.println(\"子类的静态方法\"); } //返回值类型相同或者是其子类 public Sub method3(){ System.out.println(\"子类返回值为Sub的方法\"); return new Sub(); } //父类的私有方法不能被子类覆盖,这样写可以，但是是独立的方法 public void method4(){ System.out.println(\"子类的私有方法\"); } } 示例：重写Object的equal（）方法 //学生类 public class Student extends Object { //属性 private int sid;//学员学号 private String name;//姓名 private int age;//年龄 private double weight;//体重 //无参构造方法 public Student() { //使用无参构造方法构造学员时，为其属性赋值 this.name=\"无名氏\"; this.age=18; this.weight=50; } //构造方法重载 ：带参构造方法 public Student(int sid,String name, int age, double weight) { this.sid=sid; this.name = name; this.weight = weight; if(age30){ System.out.println(\"***输入的年龄为：\"+age+\"，该年龄不合法，将重置!***\"); this.age=18; }else{ this.age = age; } } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { if(age30){ System.out.println(\"***输入的年龄为：\"+age+\"，该年龄不合法，将重置!***\"); return; } this.age = age; } public double getWeight() { return weight; } public void setWeight(double weight) { this.weight = weight; } public int getSid() { return sid; } public void setSid(int sid) { this.sid = sid; } //重写equals()方法，如果学员学号、姓名都相同，证明是同一个学生 //instanceof操作符用于判断一个引用类型所引用的对象是否是一个类的实例 public boolean equals(Object o){ if(this==o){ return true; } if(! (o instanceof Student)){ return false; } Student obj=(Student)o; if(this.sid==obj.sid && this.name.equals(obj.name)){ return true; }else{ return false; } } public static void main(String[] args) { //Student没有重写equals()时,下列两行代码结果：false；重写后，结果：true Student s1=new Student(1,\"张三\",20,55); Student s2=new Student(1,\"张三\",20,55); System.out.println(s1.equals(s2)); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/inherit/inherit.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 12:40:02 "},"abstract-class/abstract-class.html":{"url":"abstract-class/abstract-class.html","title":"抽象类","keywords":"","body":"4-抽象类 抽象类与抽象方法 (1)把多个共性的东西提取到一个类中，这是继承的做法。 但是呢，这多个共性的东西，在有些时候，方法声明一样，但是方法体。 也就是说，方法声明一样，但是每个具体的对象在具体实现的时候内容不一样。 所以，我们在定义这些共性的方法的时候，就不能给出具体的方法体。 而一个没有具体的方法体的方法是抽象的方法。 在一个类中如果有抽象方法，该类必须定义为抽象类。 (2)抽象类的特点 A:抽象类和抽象方法必须用关键字abstract修饰 B:抽象类中不一定有抽象方法,但是有抽象方法的类一定是抽象类 C:抽象类不能实例化 D:抽象类的子类 a:是一个抽象类。 b:是一个具体类。这个类必须重写抽象类中的所有抽象方法。 (3)抽象类的成员特点： A:成员变量 有变量，有常量 B:构造方法 有构造方法 C:成员方法 有抽象，有非抽象 public abstract class Base { //抽象类中可以没有抽象方法,但包含了抽象方法的类就必须被定义为抽象类 public abstract void method1(); public abstract void method2(); public void method3(){} //没有抽象的构造方法 //public abstract Base(){} //没有抽象的静态方法 //static abstract void method4(); public Base(){ System.out.println(\"父类的无参构造方法\"); } static void method4(){ System.out.print(\"静态方法表示类所特有的功能，这种功能的实现不依赖于类的具体实例，也不依赖于它的子类。因此，当前类必须为静态方法提供实现\"); } } //如果子类没有实现父类的所有抽象方法，子类必须被定义为抽象类 public abstract class Sub1 extends Base { public void method1() { System.out.println(\"重写父类的method1\"); } } //否则就必须实现父类的所有抽象方法 public class Sub2 extends Base { public Sub2(){ System.out.println(\"子类的无参构造方法\"); } @Override public void method1() { System.out.println(\"重写父类的抽象方法method1\"); } @Override public void method2() { System.out.println(\"重写父类的抽象方法method2\"); } } public class Test { public static void main(String[] args) { //抽象类不允许实例化 //Base base=new Base(); //抽象类中可以有非抽象的构造方法，创建子类的实例时可能调用 //抽象类不能被实例化,但可以创建一个引用变量，其类型是一个抽象类，指向非抽象的子类实例 Base sub=new Sub2(); sub.method1(); sub.method4(); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/abstract-class/abstract-class.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 12:42:55 "},"inner-class/inner-class.html":{"url":"inner-class/inner-class.html","title":"内部类","keywords":"","body":"5-内部类 /* 内部类概述: 把类定义在其他类的内部，这个类就被称为内部类。 举例：在类A中定义了一个类B，类B就是内部类。 内部的访问特点： A:内部类可以直接访问外部类的成员，包括私有。 B:外部类要访问内部类的成员，必须创建对象。 */ class Outer { private int num = 10; class Inner { public void show() { System.out.println(num); } } public void method() { //找不到符号 //show(); Inner i = new Inner(); i.show(); } } class InnerClassDemo { public static void main(String[] args) { } } /* 内部类位置 成员位置:在成员位置定义的类，被称为成员内部类。 局部位置:在局部位置定义的类，被称为局部内部类。 成员位置:在成员位置定义的类，被称为成员内部类。 */ class Outer { private int num = 10; //成员位置 /* class Inner { } */ public void method() { //局部位置 class Inner { } } } class InnerClassDemo2 { public static void main(String[] args) { } } /* 成员内部类: 如何直接访问内部类的成员。 外部类名.内部类名 对象名 = 外部类对象.内部类对象; */ class Outer { private int num = 10; class Inner { public void show() { System.out.println(num); } } } class InnerClassDemo3 { public static void main(String[] args) { //需求：我要访问Inner类的show()方法 //Inner i = new Inner(); //i.show(); //格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象; Outer.Inner oi = new Outer().new Inner(); oi.show(); } } /* 成员内部类的修饰符： private 为了保证数据的安全性 static 为了方便访问数据 注意：静态内部类访问的外部类数据必须用静态修饰。 案例：我有一个人(人有身体，身体内有心脏。) class Body { private class Heart { public void operator() { System.out.println(\"心脏搭桥\"); } } public void method() { if(如果你是外科医生) { Heart h = new Heart(); h.operator(); } } } 按照我们刚才的讲解，来使用一下 Body.Heart bh = new Body().new Heart(); bh.operator(); //加了private后，就不能被访问了，那么，怎么玩呢? Body b = new Body(); b.method(); */ class Outer { private int num = 10; private static int num2 = 100; //内部类用静态修饰是因为内部类可以看出是外部类的成员 public static class Inner { public void show() { //System.out.println(num); System.out.println(num2); } public static void show2() { //System.out.println(num); System.out.println(num2); } } } class InnerClassDemo4 { public static void main(String[] args) { //使用内部类 // 限定的新静态类 //Outer.Inner oi = new Outer().new Inner(); //oi.show(); //oi.show2(); //成员内部类被静态修饰后的访问方式是: //格式：外部类名.内部类名 对象名 = new 外部类名.内部类名(); Outer.Inner oi = new Outer.Inner(); oi.show(); oi.show2(); //show2()的另一种调用方式 Outer.Inner.show2(); } } /* 局部内部类 A:可以直接访问外部类的成员 B:在局部位置，可以创建内部类对象，通过对象调用内部类方法，来使用局部内部类功能 面试题： 局部内部类访问局部变量的注意事项? A:局部内部类访问局部变量必须用final修饰 B:为什么呢? 局部变量是随着方法的调用而调用，随着调用完毕而消失。 而堆内存的内容并不会立即消失。所以，我们加final修饰。 加入final修饰后，这个变量就成了常量。既然是常量。你消失了。 我在内存中存储的是数据20，所以，我还是有数据在使用。 */ class Outer { private int num = 10; public void method() { //int num2 = 20; //final int num2 = 20; class Inner { public void show() { System.out.println(num); //从内部类中访问本地变量num2; 需要被声明为最终类型 System.out.println(num2);//20 } } //System.out.println(num2); Inner i = new Inner(); i.show(); } } class InnerClassDemo5 { public static void main(String[] args) { Outer o = new Outer(); o.method(); } } /* 匿名内部类 就是内部类的简化写法。 前提：存在一个类或者接口 这里的类可以是具体类也可以是抽象类。 格式： new 类名或者接口名(){ 重写方法; } 本质是什么呢? 是一个继承了该类或者实现了该接口的子类匿名对象。 */ interface Inter { public abstract void show(); public abstract void show2(); } class Outer { public void method() { //一个方法的时候 /* new Inter() { public void show() { System.out.println(\"show\"); } }.show(); */ //二个方法的时候 /* new Inter() { public void show() { System.out.println(\"show\"); } public void show2() { System.out.println(\"show2\"); } }.show(); new Inter() { public void show() { System.out.println(\"show\"); } public void show2() { System.out.println(\"show2\"); } }.show2(); */ //如果我是很多个方法，就很麻烦了 //那么，我们有没有改进的方案呢? Inter i = new Inter() { //多态 public void show() { System.out.println(\"show\"); } public void show2() { System.out.println(\"show2\"); } }; i.show(); i.show2(); } } class InnerClassDemo6 { public static void main(String[] args) { Outer o = new Outer(); o.method(); } } 练习 /* 面试题： 要求请填空分别输出30，20，10。 注意： 1:内部类和外部类没有继承关系。 2:通过外部类名限定this对象 Outer.this */ class Outer { public int num = 10; class Inner { public int num = 20; public void show() { int num = 30; System.out.println(num); System.out.println(this.num); //System.out.println(new Outer().num); System.out.println(Outer.this.num); } } } class InnerClassTest { public static void main(String[] args) { Outer.Inner oi = new Outer().new Inner(); oi.show(); } } /* 匿名内部类在开发中的使用 */ interface Person { public abstract void study(); } class PersonDemo { //接口名作为形式参数 //其实这里需要的不是接口，而是该接口的实现类的对象 public void method(Person p) { p.study(); } } //实现类 class Student implements Person { public void study() { System.out.println(\"好好学习,天天向上\"); } } class InnerClassTest2 { public static void main(String[] args) { //测试 PersonDemo pd = new PersonDemo(); Person p = new Student(); pd.method(p); System.out.println(\"--------------------\"); //匿名内部类在开发中的使用 //匿名内部类的本质是继承类或者实现了接口的子类匿名对象 pd.method(new Person(){ public void study() { System.out.println(\"好好学习,天天向上\"); } }); } } /* 匿名内部类面试题： 按照要求，补齐代码 interface Inter { void show(); } class Outer { //补齐代码 } class OuterDemo { public static void main(String[] args) { Outer.method().show(); } } 要求在控制台输出”HelloWorld” */ interface Inter { void show(); //public abstract } class Outer { //补齐代码 public static Inter method() { //子类对象 -- 子类匿名对象 return new Inter() { public void show() { System.out.println(\"HelloWorld\"); } }; } } class OuterDemo { public static void main(String[] args) { Outer.method().show(); /* 1:Outer.method()可以看出method()应该是Outer中的一个静态方法。 2:Outer.method().show()可以看出method()方法的返回值是一个对象。 又由于接口Inter中有一个show()方法,所以我认为method()方法的返回值类型是一个接口。 */ } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/inner-class/inner-class.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 12:43:23 "},"polymorphism/polymorphism.html":{"url":"polymorphism/polymorphism.html","title":"多态","keywords":"","body":"6-多态 (1)同一个对象在不同时刻体现出来的不同状态。 (2)多态的前提： A:有继承或者实现关系。 B:有方法重写。 C:有父类或者父接口引用指向子类对象。 多态的分类： a:具体类多态 class Fu {} class Zi extends Fu {} Fu f = new Zi(); b:抽象类多态 abstract class Fu {} class Zi extends Fu {} Fu f = new Zi(); c:接口多态 interface Fu {} class Zi implements Fu {} Fu f = new Zi(); (3)多态中的成员访问特点 A:成员变量 编译看左边，运行看左边 B:构造方法 子类的构造都会默认访问父类构造 C:成员方法 编译看左边，运行看右边 D:静态方法 编译看左边，运行看左边 (4)多态的好处： A:提高代码的维护性(继承体现) B:提高代码的扩展性(多态体现) (5)多态的弊端： 父不能使用子的特有功能 现象： 子可以当作父使用，父不能当作子使用。 (6)多态中的转型 A:向上转型 从子到父 B:向下转型 从父到子 向上转型和向下转型 /** * 宠物类，狗狗和猫猫的父类 */ public class Pet { private String name = \"待定\";// 昵称 private int health = 100;// 健康值 private int love = 20;// 亲密度 /** * 无参构造方法 */ public Pet() { } /** * 有参构造方法 * @param name 昵称 */ public Pet(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getHealth() { return health; } public void setHealth(int health) { if(health100){ System.out.println(\"健康值应该在0至100之间，默认值为60。\"); this.health=60; return; } this.health = health; } public int getLove() { return love; } public void setLove(int love) { if(love100){ System.out.println(\"亲密度应该在0至100之间，默认值为10。\"); this.love=10; return; } this.love = love; } /** * 输出宠物信息 */ public void print() { System.out.println(\"宠物的自我介绍：\\n我的名字叫\" + this.name + \"，我的健康值是\" + this.health + \"，我和主人的亲密程度是\" + this.love + \"。\"); } //去医院 public void toHospital() { } } /** * 狗狗类，宠物的子类。 */ public class Dog extends Pet { private String strain=\"泰迪\";// 品种 public Dog(){} /** * 有参构造方法。 * @param name 昵称 * @param strain 品种 */ public Dog(String name, String strain) { super(name); this.strain = strain; } public void setStrain(String strain) { this.strain = strain; } public String getStrain() { return strain; } //对父类方法进行重写，同时使用supper继承父类方法 public void print(){ super.print(); System.out.println(\"我是一只\"+this.getStrain()+\"犬。\"); } //对父类方法进行重写 public void toHospital() { System.out.println(\"给狗狗打针、吃药\"); this.setHealth(60); } //狗狗跳墙(狗狗具有的独特方法) public void jumpWall(){ System.out.println(\"狗急跳墙\"); } } /** * 小猫类，宠物的子类。 */ public class Cat extends Pet { private String sex;// 性别 /** * 有参构造方法。 * @param name 昵称 * @param sex 性别 */ public Cat(String name, String sex) { super(name); this.sex = sex; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } //对父类方法进行重写，同时使用supper继承父类的方法 public void print(){ super.print(); System.out.println(\"我的性别是\"+this.getSex()+\"。\"); } //对父类方法进行重写 public void toHospital() { System.out.println(\"给猫猫吃药、疗养\"); this.setHealth(60); } } public class Master { // 给宠物看病,入参为父类 public void cure(Pet pet) { if (pet.getHealth() public class Test { public static void main(String[] args) { //向上转型 Dog 转成 Pet(使用多态思想) Pet dogP=new Dog(); dogP.setHealth(10); dogP.print(); System.out.println(\"*************************\"); Master master=new Master(); master.cure(dogP); dogP.print(); //向下转型,调用狗狗独有的方法（使用多态思想） if(dogP instanceof Dog){ Dog dog=(Dog)dogP; dog.jumpWall(); } } } 工厂模式：父类作为方法的返回值 //动物类 public abstract class Animal{ //叫 public abstract void cry(); } //Dog子类继承Animal父类 public class Dog extends Animal{ public void cry() { System.out.println(\"狗狗叫\"); } } //Cat子类继承Animal父类 public class Cat extends Animal{ public void cry() { System.out.println(\"猫猫叫\"); } } //Duck子类继承Animal父类 public class Duck extends Animal{ public void cry() { System.out.println(\"鸭鸭叫\"); } } //主人类(工厂类) public class Host { public void letCry(Animal animal) { animal.cry();//调用动物叫的方法 } //赠送动物，该方法返回父类类型 public Animal donateAnimal(String type) { Animal animal; if(type.equals(\"dog\")){ //向上转型 animal=new Dog(); } else if(type.equals(\"cat\")){ animal=new Cat(); } else{ animal=new Duck(); } return animal; } } public class Test { public static void main(String[] args) { Host host=new Host(); Animal animal; animal=host.donateAnimal(\"dog\"); animal.cry();//狗叫 animal=host.donateAnimal(\"cat\"); animal.cry();//猫叫 } } 设计模式之工厂模式 1） 简单工厂模式 step-1：请用面向对象的思想实现计算机控制程序，要求输入两个数和运算符号得到结果 public** **class** TestDemo { **public** **static** **void** main(String[] args) { Scanner sc = **new** Scanner(System.**in**); System.**out**.println(\"请输入数字A:\"); **int** a = sc.nextInt(); System.**out**.println(\"请输入运算符号:\"); sc = **new** Scanner(System.**in**); String c = sc.nextLine(); System.**out**.println(\"请输入数字B:\"); sc = **new** Scanner(System.**in**); **int** b = sc.nextInt(); **int** result = 0; **switch** (c) { **case** \"+\": result = a + b; **break**; **case** \"-\": result = a - b; **break**; **case** \"*\": result = a * b; **break**; **case** \"/\": result = a / b; **break**; **default**: System.**out**.println(a+c+b+\":运算符异常...\"); **return**; } System.**out**.println(a+c+b+\"=\"+result); } } step-2：使用面向对象的思想进行编程，上面的写法只能说是实现了功能，如果现在有一个层序需要调用这个计算呢？那么上面这种写法就不能满足。根据这个思路我们需要将上面的计算设计成一个类，提供对外访问的接口。让业务逻辑和界面逻辑分开，降低它们之间的耦合度，分开后才能达到容易维护和扩展。 public class Operation { **public** **static** **int** getResult(**int** numberA, **int** numberB, String operate) { **int** result = 0; **switch** (operate) { **case** \"+\": result = numberA + numberB; **break**; **case** \"-\": result = numberA - numberB; **break**; **case** \"*\": result = numberA * numberB; **break**; **case** \"/\": result = numberA / numberB; **break**; **default**: System.**out**.println(\"运算符异常...\"); } **return** result; } } public class Test { **public** **static** **void** main(String[] args) { Scanner sc = **new** Scanner(System.**in**); System.**out**.println(\"请输入数字A:\"); **int** numberA = sc.nextInt(); System.**out**.println(\"请输入运算符号:\"); sc = **new** Scanner(System.**in**); String operate = sc.nextLine(); System.**out**.println(\"请输入数字B:\"); sc = **new** Scanner(System.**in**); **int** numberB = sc.nextInt(); System.**out**.println(Operation.*getResult*(numberA, numberB, operate)); } } step-3：上面的写法用到了面向对象的封装，将业务逻辑和界面逻辑分开了，业务进一步增加现在需要一个平方根的运算，再进一步需要将+、-、*、/参与到运算中，这样的业务就有了一定的复杂度，那么如果在操作的过程中不小心输错了一个符号，将会导致运行结果错误。下面就要用到所学的继承和多态。 加减乘除无论如何计算，至少都需要的是两个数，可以设计为类的属性，而不同的知识它的操作，最终都需要返回一个结果，中间的操作过程不同。实现的代码如下 public abstract class Operation { **private** **double** numberA; **private** **double** numberB; **public** **abstract** **double** getResult(); **public** **void** setNumberA(**double** numberA) { **this**.numberA = numberA; } **public** **void** setNumberB(**double** numberB) { **this**.numberB = numberB; } **public** **double** getNumberA() { **return** numberA; } **public** **double** getNumberB() { **return** numberB; } } public class Add extends Operation { @Override **public** **double** getResult() { **return** getNumberA() + getNumberB(); } } public class Divide extends Operation { @Override **public** **double** getResult() { **return** getNumberA() / getNumberB(); } } public class Minus extends Operation { @Override **public** **double** getResult() { **return** getNumberA() - getNumberB(); } } public class Multiply extends Operation { @Override **public** **double** getResult() { **return** getNumberA() * getNumberB(); } } public class OperationFactory { **public** **static** Operation createOperation(String operate) { Operation op = **null**; **switch** (operate) { **case** \"+\": op = **new** Add(); **break**; **case** \"-\": op = **new** Minus(); **break**; **case** \"*\": op = **new** Multiply(); **break**; **case** \"/\": op = **new** Divide(); **break**; } **return** op; } } public class Test { ​ **public** **static** **void** main(String[] args) { Operation o = OperationFactory.*createOperation*(\"+\"); o.setNumberA(9.8); o.setNumberB(5.6); System.**out**.println(o.getResult()); } } 分析：利用了简单工厂模式实现了解耦，如果现在需要一个平方根的运算，只需要继承Operation这个类重写它的方法就可以了，而不需要去改动加减乘除的类。利于代码的维护和扩展。通过OperationFactory工厂根据运算的需要去创建对象。 2） 工厂方法模式 对于简单工厂模式我们已经实现了初步的解耦，加强了程序的可维护性和可扩展性，在运算类上已经做到了这一点，如果需要增加一个平方根的运算，我们可以去继承Operation这个类，但是在工厂类中我们还是需要增加一个case来判断，这样对于工厂类的维护和扩展就比较麻烦，需要去修改原有的代码，从而给维护和扩展带来了困难。 工厂方法模式的UML图： 实现的代码如下： public abstract class Operation { **private** **double** numberA; **private** **double** numberB; **public** **abstract** **double** getResult(); **public** **void** setNumberA(**double** numberA) { **this**.numberA = numberA; } **public** **void** setNumberB(**double** numberB) { **this**.numberB = numberB; } **public** **double** getNumberA() { **return** numberA; } **public** **double** getNumberB() { **return** numberB; } } public class Add extends Operation { @Override **public** **double** getResult() { **return** getNumberA() + getNumberB(); } } public class Divide extends Operation { @Override **public** **double** getResult() { **return** getNumberA() / getNumberB(); } } public class Minus extends Operation { @Override **public** **double** getResult() { **return** getNumberA() - getNumberB(); } } public class Multiply extends Operation { @Override **public** **double** getResult() { **return** getNumberA() * getNumberB(); } } public abstract class OperationFactory { **public** **abstract** Operation createOperation(); } public class AddFactory extends OperationFactory{ @Override **public** Operation createOperation() { **return** **new** Add(); } } public class DivideFactory extends OperationFactory{ @Override **public** Operation createOperation() { **return** **new** Divide(); } } public class MinusFactory extends OperationFactory{ @Override **public** Operation createOperation() { **return** **new** Minus(); } } public class MultiplyFactory extends OperationFactory { @Override **public** Operation createOperation() { **return** **new** Multiply(); } } public class Test { **public** **static** **void** main(String[] args) { OperationFactory of = **new** AddFactory(); Operation o = of.createOperation(); o.setNumberA(10); o.setNumberB(20); System.**out**.println(o.getResult()); } } 分析：通过工厂方法模式，如果需要增加一个平方根的运算，只需要继承Operation和OperationFactory类重写它的方法，原来的代码结构并不会发生改变，而需要修改的知识客户端。解耦的同时提高了程序的可维护性和可扩展性。 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/polymorphism/polymorphism.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 17:04:09 "},"object-class/object-class.html":{"url":"object-class/object-class.html","title":"Object 类","keywords":"","body":"7-Object类 (1)Object是类层次结构的根类，所有的类都直接或者间接的继承自Object类。 (2)Object类的构造方法有一个，并且是无参构造 这其实就是理解当时我们说过，子类构造方法默认访问父类的构造是无参构造 (3)要掌握的方法： A:toString() 返回对象的字符串表示，默认是由类的全路径+'@'+哈希值的十六进制表示。 这个表示其实是没有意义的，一般子类都会重写该方法。 如何重写呢?过程我也讲解过了，基本上就是要求信息简单明了。 但是最终还是自动生成。 B:equals() 比较两个对象是否相同。默认情况下，比较的是地址值是否相同。 而比较地址值是没有意义的，所以，一般子类也会重写该方法。 重写过程，我也详细的讲解和分析了。 但是最终还是自动生成。 (4)要了解的方法： A:hashCode() 返回对象的哈希值。不是实际地址值，可以理解为地址值。 B:getClass() 返回对象的字节码文件对象，反射中我们会详细讲解。 C:finalize() 用于垃圾回收，在不确定的时候。 D:clone() 可以实现对象的克隆，包括成员变量的数据复制，但是它和两个引用指向同一个对象是有区别的。 (5)两个注意问题； A:直接输出一个对象名称，其实默认调用了该对象的toString()方法。 B:面试题 ==和equals()的区别? A:== 基本类型：比较的是值是否相同 引用类型：比较的是地址值是否相同 B:equals() 只能比较引用类型。默认情况下，比较的是地址值是否相同。 但是，我们可以根据自己的需要重写该方法。 /* * Object:类 Object 是类层次结构的根类。每个类都使用 Object 作为超类。 * 每个类都直接或者间接的继承自Object类。 * * Object类的方法： * public int hashCode():返回该对象的哈希码值。 * 注意：哈希值是根据哈希算法计算出来的一个值，这个值和地址值有关，但是不是实际地址值。 * 你可以理解为地址值。 * * public final Class getClass():返回此 Object 的运行时类 * Class类的方法： * public String getName()：以 String 的形式返回此 Class 对象所表示的实体 */ public class StudentTest { public static void main(String[] args) { Student s1 = new Student(); System.out.println(s1.hashCode()); // 11299397 Student s2 = new Student(); System.out.println(s2.hashCode());// 24446859 Student s3 = s1; System.out.println(s3.hashCode()); // 11299397 System.out.println(\"-----------\"); Student s = new Student(); Class c = s.getClass(); String str = c.getName(); System.out.println(str); // cn.companyName_01.Student //链式编程 String str2 = s.getClass().getName(); System.out.println(str2); } } /* * public String toString():返回该对象的字符串表示。 * * Integer类下的一个静态方法： * public static String toHexString(int i)：把一个整数转成一个十六进制表示的字符串 * * 这个信息的组成我们讲解完毕了，但是这个信息是没有任何意义的。所以，建议所有子类都重写该方法。 * 怎么重写呢? * 把该类的所有成员变量值组成返回即可。 * 重写的最终版方案就是自动生成toString()方法。 * * 注意： * 直接输出一个对象的名称，其实就是调用该对象的toString()方法。 */ public class StudentDemo { public static void main(String[] args) { Student s = new Student(); System.out.println(s.hashCode()); System.out.println(s.getClass().getName()); System.out.println(\"--------------------\"); System.out.println(s.toString());// cn.companyName.Student@42552c System.out.println(\"--------------------\"); // toString()方法的值等价于它 // getClass().getName() + '@' + Integer.toHexString(hashCode()) // this.getClass().getName()+'@'+Integer.toHexString(this.hashCode()) // cn.companyName.Student@42552c // cn.companyName.Student@42552c System.out.println(s.getClass().getName() + '@' + Integer.toHexString(s.hashCode())); System.out.println(s.toString()); // 直接输出对象的名称 System.out.println(s); } } /* * public boolean equals(Object obj):指示其他某个对象是否与此对象“相等”。 * 这个方法，默认情况下比较的是地址值。比较地址值一般来说意义不大，所以我们要重写该方法。 * 怎么重写呢? * 一般都是用来比较对象的成员变量值是否相同。 * 重写的代码优化：提高效率，提高程序的健壮性。 * 最终版： * 其实还是自动生成。 * * 看源码： * public boolean equals(Object obj) { * //this - s1 * //obj - s2 * return (this == obj); * } * * ==: * 基本类型：比较的就是值是否相同 * 引用类型：比较的就是地址值是否相同 * equals: * 引用类型：默认情况下，比较的是地址值。 * 不过，我们可以根据情况自己重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同 */ public class StudentDemo { public static void main(String[] args) { Student s1 = new Student(\"王菲\", 27); Student s2 = new Student(\"王菲\", 27); System.out.println(s1 == s2); // false Student s3 = s1; System.out.println(s1 == s3);// true System.out.println(\"---------------\"); System.out.println(s1.equals(s2)); // obj = s2; //false System.out.println(s1.equals(s1)); // true System.out.println(s1.equals(s3)); // true Student s4 = new Student(\"王力宏\",30); System.out.println(s1.equals(s4)); //false Demo d = new Demo(); System.out.println(s1.equals(d)); //ClassCastException } } class Demo {} /* * protected void finalize()：当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。用于垃圾回收，但是什么时候回收不确定。 * protected Object clone():创建并返回此对象的一个副本。 * A:重写该方法 * * Cloneable:此类实现了 Cloneable 接口，以指示 Object.clone() 方法可以合法地对该类实例进行按字段复制。 * 这个接口是标记接口，告诉我们实现该接口的类就可以实现对象的复制了。 */ public class StudentDemo { public static void main(String[] args) throws CloneNotSupportedException { //创建学生对象 Student s = new Student(); s.setName(\"王菲\"); s.setAge(27); //克隆学生对象 Object obj = s.clone(); Student s2 = (Student)obj; System.out.println(\"---------\"); System.out.println(s.getName()+\"---\"+s.getAge()); System.out.println(s2.getName()+\"---\"+s2.getAge()); //以前的做法 Student s3 = s; System.out.println(s3.getName()+\"---\"+s3.getAge()); System.out.println(\"---------\"); //其实是有区别的 s3.setName(\"鹿晗\"); s3.setAge(30); System.out.println(s.getName()+\"---\"+s.getAge()); System.out.println(s2.getName()+\"---\"+s2.getAge()); System.out.println(s3.getName()+\"---\"+s3.getAge()); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/object-class/object-class.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 12:46:40 "},"oop-idea/oop-idea.html":{"url":"oop-idea/oop-idea.html","title":"面向对象编程思想","keywords":"","body":"8-面向对象编程思想 8.1简介 从面向对象编程思想是如何解决软件开发中各种疑难问题的角度，讲述面向对象编程思想的理解，梳理面向对象四大基本特性、七大设计原则和23种设计模式之间的关系。 软件开发中疑难问题： 软件复杂庞大； 很多软件很难维护； 需求不断变更； 软件开发中存在很多很多的问题，上面三个问题只是从程序开发和设计的角度看到的部分问题。要解决上面软件开发的问题，就要求我们编写（设计）的软件具有很好的可读性、可维护性和可扩展性，并且还要保证代码具有高内聚低耦合。 8.2四大基本特性 OOP（面向对象编程）的四大特性：抽象、封装、多态、继承。 抽象：抽象是提取现实世界中某事物的关键特性，为该事物构建模型的过程。对同一事物中不同的需求下，需要提取的特性可能不一样。得到的抽象模型中一般包含：属性（数据）和操作（行为）。这个抽象模型我们称之为类，通过对类进行实例化得到具体的对象。 封装：封装可以使类具有独立性和隔离性，从而保证类的高内聚。只暴露给类外部或者子类必须的属性和操作。类封装的实现依赖类的修饰符（public、protected和private）。 继承：继承是对现有类的一种复用机制。一个类如果继承现有的类，则这个类将拥有被继承类的所有非私有特性（属性和操作）。这里指的继承包含类的继承和接口的实现。常见的继承方法有共有继承、私有继承、多重继承、多层继承。 多态：多态是中继承的基础上实现的。多态的三个要素：继承、重写和父类引用指向子类的对象。父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的行为；就是类的多态性。多态还可分为编译时多态（静态多态性）和运行时多态（动态多态性）。另外类的函数重载、运算符重载，也可算为多态的特性。 8.3七大设计原则 在面向对象四大基础特性之上，我们在做面向对象设计时，还需要遵循一些基本设计原则。 SOLID原则（单一职责原则、开放关闭原则、里氏替换原则、接口隔离原则和依赖倒置原则）； 迪米特法则； 组合优于继承原则（合成复用原则）； 下面是这七大原则的详细描述： 单一责任原则：一个类应该只有一个引起变化的原因。 开放关闭原则：类应该对扩展开放，对修改关闭；我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。 里氏替换原则：所有引用基类的地方必须能透明地使用其子类对象。只要有父类出现的地方，都可以用子类来替代。 接口隔离原则：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上； 赖倒置原则（Dependency Inversion Principle）：要依赖抽象，不要依赖具体类依。 迪米特法则：又叫最少知识原则，只和你的密友谈话。 组合优于继承原则：多用组合，少用继承；使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以“在运行时动态地改变行为”，只要组合的行为对象符合正确的接口标准即可。 另外还有如下几个常用的原则： 好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你。 封装变化：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，不要对实现编程；针对接口编程真正的意思是针对超类型（supertype）编程，这样可以在运行时才指定具体实现的对象。 为了交互对象之间的松耦合设计而努力：松耦合的设计之所以能让我们建立有弹性的OO系统，能够应付变化，是因为对象之间的互相依赖降到了最低。 8.4.24种设计模式 在遵循上面这些面向对象设计原则的基础上，总结出一些解决不同问题场景的通用设计模式。 创建型模式 简单工厂模式 工厂模式 抽象工厂模式 单例模式 原型模式 创建者模式 结构型模式 组合模式 装饰者模式 外观模式 适配器模式 代理模式 享元模式 桥接模式 行为型模式 观察者模式 策略模式 状态模式 中介模式 模版方法 命令模式 备忘录模式 访问者模式 解释器模式 迭代器模式 职责链模式 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/oop-idea/oop-idea.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 17:35:44 "},"interface/interface.html":{"url":"interface/interface.html","title":"接口","keywords":"","body":"9-接口 (1)接口是一种能力和约定，解决了单继承的局限。 (2)接口的特点： A:接口用关键字interface修饰 interface 接口名 {} B:类实现接口用implements修饰 class 类名 implements 接口名 {} C:接口不能实例化 D:接口的实现类 a:是一个抽象类。 b:是一个具体类，这个类必须重写接口中的所有抽象方法。 (3)接口的成员特点： A:成员变量 只能是常量 默认修饰符：public static final B:构造方法 没有构造方法 C:成员方法 只能是抽象的 默认修饰符：public abstract //父类 public abstract class Door { //防盗门是一个门 is a 的关系 //开门功能 public void openDoor() {}; //关门功能 public void closeDoor() {}; } //接口 public interface Lock { //防盗门上有一个把锁 has a 的关系 //锁门功能 public void lockDoor(); //解锁功能 public void unlockDoor(); } public class TheftDoor extends Door implements Lock{ //开门的实现方法 public void openDoor() { System.out.println(\"开始开门。开门中。开门结束\"); } //关门的实现方法 public void closeDoor() { System.out.println(\"准备关门。关门中。关门结束\"); } //锁门功能 @Override public void lockDoor() { System.out.println(\"插入钥匙，转动，锁上，拔出钥匙\"); } //解锁功能 @Override public void unlockDoor() { System.out.println(\"插入钥匙，转动，解锁，拔出钥匙\"); } } import org.junit.Test; public class Mytest { @Test public void test1() { //不使用接口调用 TheftDoor theftDoor= new TheftDoor(); //出门步骤：关门---》锁门 theftDoor.closeDoor(); theftDoor.lockDoor(); //回家步骤：开锁---》开门 theftDoor.unlockDoor(); theftDoor.openDoor(); System.out.println(\"+++++++++++++++++++++++++++\"); //调用接口中的方法，实现实现类中的方法 Lock lock= new TheftDoor(); lock.unlockDoor(); lock.lockDoor(); System.out.println(\"++++++++++++++++++++++++++\"); //调用抽象类中的方法，实现实现类中的方法 Door door= new TheftDoor(); door.closeDoor(); door.openDoor(); /** * 门和防盗门是继承关系； * 但是门和锁是非继承关系，如何实现继承呢？ * java的设计者想到了interface接口。 * */ } } 练习 1、设计USB接口？ /** * USB接口。 */ public interface UsbInterface { /** * USB接口提供服务。 */ void service(); } /** * U盘。 */ public class UDisk implements UsbInterface { public void service() { System.out.println(\"连接USB口，开始传输数据。\"); } } /** * USB风扇。 */ public class UsbFan implements UsbInterface { public void service() { System.out.println(\"连接USB口，获得电流，风扇开始转动。\"); } } /** * 测试类。 * @param args */ public class Test { public static void main(String[] args) { //1、U盘 UsbInterface uDisk = new UDisk(); uDisk.service(); //2、USB风扇 UsbInterface usbFan= new UsbFan(); usbFan.service(); } } 2、设计打印机？ /** * 墨盒接口。 */ public interface InkBox { /** * 得到墨盒颜色 * @return 墨盒颜色 */ public String getColor(); } /** * 彩色墨盒。 */ public class ColorInkBox implements InkBox { public String getColor() { return \"彩色\"; } } /** * 黑白墨盒。 */ public class GrayInkBox implements InkBox { public String getColor() { return \"黑白\"; } } /** * 纸张接口。 */ public interface Paper { /** * 得到纸张大小 * @return 纸张大小 */ public String getSize(); } /** * A4纸类。 */ public class A4Paper implements Paper { public String getSize() { return \"A4\"; } } /** * B5纸类。 */ public class B5Paper implements Paper { public String getSize() { return \"B5\"; } } /** * 打印机类。 */ public class Printer { InkBox inkBox; //墨盒 Paper paper; //纸张 /** * 设置打印机墨盒 * @param inkBox 打印使用的墨盒 */ public void setInkBox(InkBox inkBox){ this.inkBox=inkBox; } /** * 设置打印机纸张 * @param paper 打印使用的纸张 */ public void setPaper(Paper paper){ this.paper=paper; } /** * 使用墨盒在纸张上打印 */ public void print(){ System.out.println(\"使用\"+inkBox.getColor()+ \"墨盒在\"+paper.getSize()+\"纸张上打印。\"); } } /** * 测试类 */ public class Test { public static void main(String[] args) { //1、定义打印机 InkBox inkBox = null; Paper paper = null; Printer printer=new Printer(); //2.1、使用黑白墨盒在A4纸上打印 inkBox=new GrayInkBox(); paper=new A4Paper(); printer.setInkBox(inkBox); printer.setPaper(paper); printer.print(); //2.2、使用彩色墨盒在B5纸上打印 inkBox=new ColorInkBox(); paper=new B5Paper(); printer.setInkBox(inkBox); printer.setPaper(paper); printer.print(); //2.3使用彩色墨盒在A4纸上打印 paper=new A4Paper(); printer.setPaper(paper); printer.print(); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/interface/interface.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 12:47:56 "},"exception/exceptions.html":{"url":"exception/exceptions.html","title":"异常","keywords":"","body":"10-异常 (1)程序出现的不正常的情况，跳出提示。 (2)异常的体系 Throwable |--Error 严重问题，程序员一般无法处理的异常。 |--Exception |--RuntimeException 运行期异常，我们需要修正代码 |--非RuntimeException 编译期异常，必须处理的，否则程序编译不通过 (3)异常的处理 A:JVM的默认处理 把异常的名称,原因,位置等信息输出在控制台，但是呢程序不能继续执行了 B:自己处理 a:try...catch...finally 自己编写处理代码,后面的程序可以继续执行 b:throws 把自己处理不了的，在方法上声明，告诉调用者，这里有问题 程序中的异常 import java.util.Scanner; /** * 演示程序中的异常 */ public class Test1 { public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.print(\"请输入被除数（整型）:\"); int num1 = in.nextInt(); System.out.print(\"请输入除数（整型）:\"); int num2 = in.nextInt(); System.out.println(num1+\"/\"+ num2 +\"=\"+ num1/ num2); System.out.println(\"感谢使用本程序！\"); } } 传统处理程序中的异常 import java.util.Scanner; /** * 传统处理程序中的异常 */ public class Test2 { public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.print(\"请输入被除数:\"); int num1 = in.nextInt(); System.out.print(\"请输入除数:\"); int num2 = 0; if (in.hasNextInt()) { // 如果输入的除数是整数 num2 = in.nextInt(); if (0 == num2) { // 如果输入的除数是0 System.err.println(\"输入的除数是0，程序退出。\"); System.exit(1); } System.out.println(num1+\"/\"+ num2 +\"=\"+ num1/ num2); System.out.println(\"感谢使用本程序！\"); } else { // 如果输入的除数不是整数 System.err.println(\"输入的除数不是整数，程序退出。\"); System.exit(1); } } } 使用try-catch处理异常 import java.util.Scanner; /** * 使用try-catch进行异常处理。 */ public class Test3 { public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.print(\"请输入被除数:\"); try { int num1 = in.nextInt(); System.out.print(\"请输入除数:\"); int num2 = in.nextInt(); System.out.println(num1+\"/\"+ num2 +\"=\"+ num1/ num2); } catch (Exception e) { System.err.println(\"出现错误:被除数和除数必须是整数,除数不能为零。\"); e.printStackTrace(); } System.out.println(\"感谢使用本程序!\"); } } 使用try-catch-finally处理异常 import java.util.Scanner; /** * 使用try-catch-finally进行异常处理。 */ public class Test4 { public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.print(\"请输入被除数:\"); try { int num1 = in.nextInt(); System.out.print(\"请输入除数:\"); int num2 = in.nextInt(); System.out.println(num1+\"/\"+ num2 +\"=\"+ num1/ num2); } catch (Exception e) { System.err.println(\"出现错误:被除数和除数必须是整数,除数不能为零。\"); //System.exit(1); // finally语句块不执行的唯一情况 } finally { System.out.println(\"感谢使用本程序!\"); } } } try块和catch块中return语句的执行 import java.util.Scanner; /** * 测试try块和catch块中return语句的执行。 * */ public class Test5 { public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.print(\"请输入被除数:\"); try { int num1 = in.nextInt(); System.out.print(\"请输入除数:\"); int num2 = in.nextInt(); System.out.println(num1+\"/\"+ num2 +\"=\"+ num1/ num2); return; //finally语句块仍旧会执行 } catch (Exception e) { System.err.println(\"出现错误:被除数和除数必须是整数,除数不能为零\"); return; //finally语句块仍旧会执行 } finally { System.out.println(\"感谢使用本程序!\"); } } } 使用多重catch处理异常 import java.util.Scanner; import java.util.InputMismatchException; /** * 多重catch块 * */ public class Test6 { public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.print(\"请输入被除数:\"); try { int num1 = in.nextInt(); System.out.print(\"请输入除数:\"); int num2 = in.nextInt(); System.out.println(num1+\"/\"+ num2 +\"=\"+ num1/ num2); } catch (InputMismatchException e) { System.err.println(\"被除数和除数必须是整数。\"); } catch (ArithmeticException e) { System.err.println(\"除数不能为零。\"); } catch (Exception e) { //该异常捕捉在前，报错 System.err.println(\"其他未知异常。\"); } finally { System.out.println(\"感谢使用本程序!\"); } } } 使用throws声明异常 import java.util.Scanner; /** * 使用throws声明异常。 */ public class Test7 { /** * 通过try-catch捕获并处理异常。 * @param args */ public static void main(String[] args) { try { divide(); } catch (Exception e) { System.err.println(\"出现错误:被除数和除数必须是整数,除数不能为零\"); e.printStackTrace(); } } // /** // * 通过throws继续声明异常。 // */ // public static void main(String[] args) throws Exception { // divide(); // } /** * 输入被除数和除数,计算商并输出。 * @throws Exception */ public static void divide() throws Exception { Scanner in = new Scanner(System.in); System.out.print(\"请输入被除数:\"); int num1 = in.nextInt(); System.out.print(\"请输入除数:\"); int num2 = in.nextInt(); System.out.println(num1+\"/\"+ num2 +\"=\"+ num1/ num2); } } 使用throw抛出异常 /** * 使用throw在方法内抛出异常。 */ public class Person { private String name = \"\";// 姓名 private int age = 0;// 年龄 private String sex = \"男\";// 性别 /** * 设置性别。 * @param sex 性别 * @throws Exception */ public void setSex(String sex) throws Exception { if (\"男\".equals(sex) || \"女\".equals(sex)) this.sex = sex; else { throw new Exception(\"性别必须是“男”或者“女”！\"); } } /** * 打印基本信息。 */ public void print() { System.out.println(this.name + \"（\" + this.sex + \"，\" + this.age + \"岁）\"); } } /** * 捕获throw抛出的异常。 */ public class Test8 { public static void main(String[] args) { Person person = new Person(); try { person.setSex(\"Male\"); person.print(); } catch (Exception e) { e.printStackTrace(); } } } Checked异常必须处理 import java.io.*; /** * 不处理Checked异常。 */ public class Test9 { public static void main(String[] args) { FileInputStream fis = null; // 创建指定文件的流。 fis = new FileInputStream(new File(\"accp.txt\")); // 创建指定文件的流。 fis.close(); } } import java.io.*; /** * 处理Checked异常。 */ public class Test10 { public static void main(String[] args) { FileInputStream fis = null; try { // 创建指定文件的流。 fis = new FileInputStream(new File(\"accp.txt\")); } catch (FileNotFoundException e) { System.err.println(\"无法找到指定文件！\"); e.printStackTrace(); } try { // 关闭指定文件的流。 fis.close(); } catch (IOException e) { System.err.println(\"关闭指定文件输入流时出现异常！\"); e.printStackTrace(); } } } 自定义异常 public class GenderException extends Exception{ //构造方法1 public GenderException(String message) { super(message); } } class Person{ private String name=\"\"; //姓名 private int age=0; //年龄 private String sex=\"男\"; //性别 //设置性别 public void setSex(String sex) throws GenderException { if (\"男\".equals(sex) || \"女\".equals(sex)) this.sex = sex; else { throw new GenderException(\"性别必须是“男”或者“女”！\"); } } //打印基本信息 public void print(){ System.out.println(this.name+\"（\"+this.sex+\"，\"+this.age+\"岁）\"); } } public class Test{ public static void main(String[] args){ Person person = new Person(); try { person.setSex(\"Male\"); person.print(); } catch (GenderException e) { e.printStackTrace(); } } } 练习 1、根据编号输出课程名称? import java.util.Scanner; /** * 测试try-catch-finally的使用，根据编号输出课程名称 */ public class TestException1 { public static void main(String[] args) { System.out.print(\"请输入课程代号(1～3之间的数字):\"); Scanner in = new Scanner(System.in); try { int courseCode = in.nextInt(); switch (courseCode) { case 1: System.out.println(\"C#编程\"); break; case 2: System.out.println(\"Java编程\"); break; case 3: System.out.println(\"SQL基础\"); } } catch (Exception ex) { System.out.println(\"输入不为数字!\"); ex.printStackTrace(); } finally { System.out.println(\"欢迎提出建议!\"); } } } 2、使用throw抛出年龄异常? /** * 使用throw在方法内抛出异常。 */ public class Person { private String name = \"\";// 姓名 private int age = 0;// 年龄 private String sex = \"男\";// 性别 /** * 设置性别。 * @param sex 性别 * @throws Exception */ public void setSex(String sex) throws Exception { if (\"男\".equals(sex) || \"女\".equals(sex)) this.sex = sex; else { throw new Exception(\"性别必须是“男”或者“女”！\"); } } public void setAge(int age) throws Exception { if (age>=1 && age /** * 捕获throw抛出的异常。 */ public class TestException2{ public static void main(String[] args) { Person person = new Person(); try { person.setAge(110); person.print(); } catch (Exception e) { e.printStackTrace(); } } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/exception/exceptions.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 12:47:56 "},"collection/collection.html":{"url":"collection/collection.html","title":"集合","keywords":"","body":"1-Java集合 Java集合框架提供了一套性能优良、使用方便的接口和类，它们位于java.util包中。 1.1Collection Collection 接口存储一组不唯一，无序的对象。 Collection接口有下面两个基本方法 boolean add(Object obj) Iterator iterator() add方法用于将对象添加给集合。如果添加对象后，该集合确实发生了变化，那么该方法返回true；如果该集合没有变化，则返回false。例如，如果你试图将一个对象添加给一个集合，而该集合中已经有该对象了，那么add请求将被拒绝，因为该集合拒绝纳入重复的对象 iterator方法用于返回一个实现了Iterator接口的类的对象。 Iterator类型的对象称为迭代子对象，它专门用于访问集合中的各个元素 具体的集合 Java库提供了下面10个具体的集合类：LinkedList、ArrayList 、HashSet 、TreeSet 、HashMap 、TreeMap 、Vector 、Stack 、HashTable、Properties 1.1.1List接口 List 接口存储一组不唯一，有序（插入顺序）的对象。常用的实现类：ArrayList、LinkedList等 List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。 和下面要提到的Set不同，List允许有相同的元素。 除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历。 实现List接口的常用类有LinkedList，ArrayList，Vector和Stack ArrayList类 ArrayList实现了长度可变的数组，在内存中分配连续的空间，遍历元素和随机访问元素的效率比较高。 链接列表是一个有序集合，将每个对象存放在独立的链接中，每个链接中还存放着序列中下一个链接的索引。在**java**中，所有的链接列表实际上是双重链接的，即每个链接中还存放着对它的前面的链接的索引链接列表适合于处理数据序列中数据数目不定，且频繁进行插入和删除操作的问题－－插入或删除一个元素时，只需要更新其它元素的索引即可，不必移动元素的位置，效率很高。 ListIterator**（列表迭代子）接口中定义了许多方法用于访问链接列表LinkedList，LinkedList 类中有一个listIterator方法，可以返回一个ListIterator对象**: ListIterator iter=list. listIterator(); Object oldValue=iter. next(); Iter. set(newValue); 链接列表不支持快速随机访问。如果你想查看列表中的第**n个元素，你必须从头开始查看，然后跳过前面的n-1**个元素 如果你需要随机访问某个集合的话，请使用数组或者**ArrayList，而不要使用LinkedList 。** 常用方法 方法名 说明 boolean add(Object o) 在列表的末尾顺序添加元素，起始索引位置从0开始 void add(int index,Object o) 在指定的索引位置添加元素，索引位置必须介于0和列表中元素个数之间 int size() 返回列表中的元素个数 Object get(int index) 返回指定索引位置处的元素。取到的元素是Object类型 boolean contains(Object o) 判断列表中是否存在指定元素 boolean remove(Object o) 从列表中删除元素 Object remove(int index) 从列表中删除指定位置元素，起始索引位置从0开始 /* * 需求：List集合存储字符串并遍历。 */ public class ListDemo { public static void main(String[] args) { // 创建集合对象 List list = new ArrayList(); // 创建字符串并添加字符串 list.add(\"hello\"); list.add(\"world\"); list.add(\"java\"); // 遍历集合 Iterator it = list.iterator(); while (it.hasNext()) { String s = (String) it.next(); System.out.println(s); } } } /* * List集合的特点： * 有序(存储和取出的元素一致)，可重复的。 */ public class ListDemo2 { public static void main(String[] args) { // 创建集合对象 List list = new ArrayList(); // 存储元素 list.add(\"hello\"); list.add(\"world\"); list.add(\"java\"); list.add(\"javaee\"); list.add(\"android\"); list.add(\"javaee\"); list.add(\"android\"); // 遍历集合 Iterator it = list.iterator(); while (it.hasNext()) { String s = (String) it.next(); System.out.println(s); } } } 存储自定义对象并遍历 //定义新闻类 public class News { public int id; //新闻id编号 public String title; //新闻标题 public String author; //新闻作者 //无参构造器 public News() {} //含参构造器 public News(int id,String title,String author ) { this.id=id; this.title=title; this.author=author; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } } import java.util.ArrayList; import java.util.Iterator; import java.util.List; //测试类 public class MyTest { public static void main(String[] args) { // TODO Auto-generated method stub //创建2条新闻 News car =new News(1,\"汽车\",\"小李\"); News art =new News(2,\"艺术\",\"小王\"); //将新闻保存到List容器中 List list=new ArrayList(); //add(Object o)返回的是boolean类型 list.add(car); list.add(art); System.out.println(\"++++++++++++++++++++++++++\"); //增强for遍历出集合 for(Object o: list) { News n=(News)o; System.out.println(n.id+n.title+n.author); } System.out.println(\"++++++++++++++++++++++++++\"); // 循环遍历 for(int i=0;i /* * List集合的特有功能： * A:添加功能 * void add(int index,Object element):在指定位置添加元素 * B:获取功能 * Object get(int index):获取指定位置的元素 * C:列表迭代器 * ListIterator listIterator()：List集合特有的迭代器 * D:删除功能 * Object remove(int index)：根据索引删除元素,返回被删除的元素 * E:修改功能 * Object set(int index,Object element):根据索引修改元素，返回被修饰的元素 */ public class ListDemo { public static void main(String[] args) { // 创建集合对象 List list = new ArrayList(); // 添加元素 list.add(\"hello\"); list.add(\"world\"); list.add(\"java\"); // void add(int index,Object element):在指定位置添加元素 // list.add(1, \"android\");//没有问题 // IndexOutOfBoundsException // list.add(11, \"javaee\");//有问题 // list.add(3, \"javaee\"); //没有问题 // list.add(4, \"javaee\"); //有问题 // Object get(int index):获取指定位置的元素 // System.out.println(\"get:\" + list.get(1)); // IndexOutOfBoundsException // System.out.println(\"get:\" + list.get(11)); // Object remove(int index)：根据索引删除元素,返回被删除的元素 // System.out.println(\"remove:\" + list.remove(1)); // IndexOutOfBoundsException // System.out.println(\"remove:\" + list.remove(11)); // Object set(int index,Object element):根据索引修改元素，返回被修饰的元素 System.out.println(\"set:\" + list.set(1, \"javaee\")); System.out.println(\"list:\" + list); } } LinkedList类 LinkedList采用链表存储方式，插入、删除元素时效率比较高。 常用方法 demo //定义新闻类 public class News { public int id; //新闻id编号 public String title; //新闻标题 public String author; //新闻作者 //无参构造器 public News() {} //含参构造器 public News(int id,String title,String author ) { this.id=id; this.title=title; this.author=author; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } } import java.util.Iterator; import java.util.LinkedList; public class MyTest { public static void main(String[] args) { //创建一个LinkedList实例 LinkedList list =new LinkedList(); //创建news对象 News car= new News(1,\"car\",\"lucy\"); News games=new News(2,\"games\",\"leilei\"); News art= new News(3,\"art\",\"lili\"); //将news对象添加到list容器中 list.addFirst(car); list.add(games); list.addLast(art); //遍历出LinkedList中的元素 Iterator it=list.iterator(); while(it.hasNext()) { News n=(News)it.next(); System.out.println(n.id+n.title+n.author); } //普通for循环 for(int i=0;i Vector类 ​ 底层数据结构是数组，查询快，增删慢。 ​ 线程安全，效率低。 Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。 Vector是一个“旧的”集合类。它与ArrayList类一样，封装了一个动态的Object[]数组。 二者最大的区别在于：Vector类的所有方法都是同步方法，而ArrayList类的方法都是非同步方法； 第二个区别在于：Vector类的方法要比ArrayList类的方法多，在某些情况下使用起来比ArrayList类方便，创建了一个Vector对象后，可以往其中随意地插入不同的类的对象，既不需顾及类型也不需预先选定向量的容量，并可方便地进行查找。对于预先不知或不愿预先定义数组大小，并需频繁进行查找、插入和删除工作的情况，可以考虑使用Vector ，Vector 常用于保存从数据库中读取的记录。 1.1.2Set接口 Set 接口存储一组唯一，无序的对象。 • Set接口是Collection接口的子接口。 • Set类型的集合具有以下特点： – 不允许包含相同的元素 – 至多有一个null元素 – 无序 Hashset /* * 无序(存储顺序和取出顺序不一致),唯一 * HashSet：它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。 * 注意：虽然Set集合的元素无序，但是，作为集合来说，它肯定有它自己的存储顺序， * 而你的顺序恰好和它的存储顺序一致，这代表不了有序，你可以多存储一些数据，就能看到效果。 */ public class SetDemo { public static void main(String[] args) { // 创建集合对象 Set set = new HashSet(); // 创建并添加元素 set.add(\"hello\"); set.add(\"java\"); set.add(\"world\"); set.add(\"java\"); set.add(\"world\"); // 增强for for (String s : set) { System.out.println(s); } } } /* * HashSet:存储字符串并遍历 * 问题：为什么存储字符串的时候，字符串内容相同的只存储了一个呢? * 通过查看add方法的源码，我们知道这个方法底层依赖 两个方法：hashCode()和equals()。 * 步骤： * 首先比较哈希值 * 如果相同，继续走，比较地址值或者走equals() * 如果不同,就直接添加到集合中 * 按照方法的步骤来说： * 先看hashCode()值是否相同 * 相同:继续走equals()方法 * 返回true： 说明元素重复，就不添加 * 返回false：说明元素不重复，就添加到集合 * 不同：就直接把元素添加到集合 * 如果类没有重写这两个方法，默认使用的Object()。一般来说不同相同。 * 而String类重写了hashCode()和equals()方法，所以，它就可以把内容相同的字符串去掉。只留下一个。 */ public class HashSetDemo { public static void main(String[] args) { // 创建集合对象 HashSet hs = new HashSet(); // 创建并添加元素 hs.add(\"hello\"); hs.add(\"world\"); hs.add(\"java\"); hs.add(\"world\"); // 遍历集合 for (String s : hs) { System.out.println(s); } } } import java.util.HashSet; /* * HashSet集合存储自定义对象并遍历。如果对象的成员变量值相同即为同一个对象 * * 注意了： * 你使用的是HashSet集合，这个集合的底层是哈希表结构。 * 而哈希表结构底层依赖:hashCode()和equals()方法。 * 如果你认为对象的成员变量值相同即为同一个对象的话，你就应该重写这两个方法。 * 如何重写呢?不同担心，自动生成即可。 */ public class DogDemo { public static void main(String[] args) { // 创建集合对象 HashSet hs = new HashSet(); // 创建狗对象 Dog d1 = new Dog(\"秦桧\", 25, \"红色\", '男'); Dog d2 = new Dog(\"高俅\", 22, \"黑色\", '女'); Dog d3 = new Dog(\"秦桧\", 25, \"红色\", '男'); Dog d4 = new Dog(\"秦桧\", 20, \"红色\", '女'); Dog d5 = new Dog(\"魏忠贤\", 28, \"白色\", '男'); Dog d6 = new Dog(\"李莲英\", 23, \"黄色\", '女'); Dog d7 = new Dog(\"李莲英\", 23, \"黄色\", '女'); Dog d8 = new Dog(\"李莲英\", 23, \"黄色\", '男'); // 添加元素 hs.add(d1); hs.add(d2); hs.add(d3); hs.add(d4); hs.add(d5); hs.add(d6); hs.add(d7); hs.add(d8); // 遍历 for (Dog d : hs) { System.out.println(d.getName() + \"---\" + d.getAge() + \"---\" + d.getColor() + \"---\" + d.getSex()); } } } class Dog { private String name; private int age; private String color; private char sex; public Dog() { super(); } public Dog(String name, int age, String color, char sex) { super(); this.name = name; this.age = age; this.color = color; this.sex = sex; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } public char getSex() { return sex; } public void setSex(char sex) { this.sex = sex; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((color == null) ? 0 : color.hashCode()); result = prime * result + ((name == null) ? 0 : name.hashCode()); result = prime * result + sex; return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Dog other = (Dog) obj; if (age != other.age) return false; if (color == null) { if (other.color != null) return false; } else if (!color.equals(other.color)) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; if (sex != other.sex) return false; return true; } } import java.util.LinkedHashSet; /* * LinkedHashSet:底层数据结构由哈希表和链表组成。 * 哈希表保证元素的唯一性。 * 链表保证元素有素。(存储和取出是一致) */ public class LinkedHashSetDemo { public static void main(String[] args) { // 创建集合对象 LinkedHashSet hs = new LinkedHashSet(); // 创建并添加元素 hs.add(\"hello\"); hs.add(\"world\"); hs.add(\"java\"); hs.add(\"world\"); hs.add(\"java\"); // 遍历 for (String s : hs) { System.out.println(s); } } } TreeSet Treeset中的数据是自动排好序的，不允许放入null值 . TreeSet 方法保证元素唯一性的方式： 就是参考比较方法的结果是否为 0，如果 return 0，视为两个对象重复，不存。 public class TestTreeSet { public static void main(String[] args) { Set set = new TreeSet(); set.add(1); set.add(\"A\"); set.add(null);//java.lang.ClassCastException System.out.println(set); } TreeSet是依靠TreeMap来实现的。 TreeSet是一个有序集合，TreeSet中元素将按照升序排列，缺省是按照自然顺序进行排列，意味着TreeSet中元素要实现Comparable接口。 我们可以在构造TreeSet对象时，传递实现了Comparator接口的比较器对象。 TreeSet 集合排序有两种方式， Comparable 和 Comparator 区别： 1：让元素自身具备比较性，需要元素对象实现 Comparable 接口，覆盖 compareTo 方法。 2：让集合自身具备比较性，需要定义一个实现了 Comparator 接口的比较器，并覆盖 compare 方法，并将该类对象作为实际参数传递给 TreeSet 集合的构造函数。第二种方式较为灵活。 /** - 实现Comparable接口重写compareTo方法 - @author Administrator * */ public class User implements Comparable { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } @Override public int compareTo(User o) { if (o.name.compareTo(this.name) > 0) return -1; if (o.name.compareTo(this.name) this.age) return -1; if (o.age { @Override public int compare(User o1, User o2) { if (o1.getName().compareTo(o2.getName()) > 0) return 1; if (o1.getName().compareTo(o2.getName()) o2.getAge()) return 1; if (o1.getAge() 常用方法 demo import java.util.HashSet; import java.util.Set; public class MyTest { public static void main(String[] args) { // Set容器中存放的不重复的元素 Set set =new HashSet(); String s1=new String(\"java\"); String s2=\"java\"; //String s3=new String(\"Java\"); set.add(s1); set.add(s2); //set.add(s3); System.out.println(\"条数\"+set.size()); } } 练习 集合的嵌套遍历？ /* * 集合的嵌套遍历 * 需求： * 我们班有学生，每一个学生是不是一个对象。所以我们可以使用一个集合表示我们班级的学生。ArrayList * 但是呢，我们旁边是不是还有班级，每个班级是不是也是一个ArrayList。 * 而我现在有多个ArrayList。也要用集合存储，怎么办呢? * 就是这个样子的：ArrayList> */ public class ArrayListDemo { public static void main(String[] args) { // 创建大集合 ArrayList> bigArrayList = new ArrayList>(); // 创建第一个班级的学生集合 ArrayList firstArrayList = new ArrayList(); // 创建学生 Student s1 = new Student(\"唐僧\", 30); Student s2 = new Student(\"孙悟空\", 29); Student s3 = new Student(\"猪八戒\", 28); Student s4 = new Student(\"沙僧\", 27); Student s5 = new Student(\"白龙马\", 26); // 学生进班 firstArrayList.add(s1); firstArrayList.add(s2); firstArrayList.add(s3); firstArrayList.add(s4); firstArrayList.add(s5); // 把第一个班级存储到学生系统中 bigArrayList.add(firstArrayList); // 创建第二个班级的学生集合 ArrayList secondArrayList = new ArrayList(); // 创建学生 Student s11 = new Student(\"诸葛亮\", 30); Student s22 = new Student(\"刘备\", 28); Student s33 = new Student(\"张飞\", 26); // 学生进班 secondArrayList.add(s11); secondArrayList.add(s22); secondArrayList.add(s33); // 把第二个班级存储到学生系统中 bigArrayList.add(secondArrayList); // 创建第三个班级的学生集合 ArrayList thirdArrayList = new ArrayList(); // 创建学生 Student s111 = new Student(\"宋江\", 40); Student s222 = new Student(\"吴用\", 35); Student s333 = new Student(\"李逵\", 30); Student s444 = new Student(\"武松\", 22); // 学生进班 thirdArrayList.add(s111); thirdArrayList.add(s222); thirdArrayList.add(s333); thirdArrayList.add(s444); // 把第三个班级存储到学生系统中 bigArrayList.add(thirdArrayList); // 遍历集合 for (ArrayList array : bigArrayList) { for (Student s : array) { System.out.println(s.getName() + \"---\" + s.getAge()); } } } /****************************如下为实体类**********************************/ class Student { private String name; private int age; public Student() { super(); } public Student(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 产生10个1-20之间的随机数，要求随机数不能重复？ /* * 获取10个1-20之间的随机数，要求不能重复 * * 用数组实现，但是数组的长度是固定的，长度不好确定。 * 所以我们使用集合实现。 * * 分析： * A:创建产生随机数的对象 * B:创建一个存储随机数的集合。 * C:定义一个统计变量。从0开始。 * D:判断统计遍历是否小于10 * 是:先产生一个随机数，判断该随机数在集合中是否存在。 * 如果不存在:就添加，统计变量++。 * 如果存在:就不搭理它。 * 否：不搭理它 * E:遍历集合 */ public class RandomDemo { public static void main(String[] args) { // 创建产生随机数的对象 Random r = new Random(); // 创建一个存储随机数的集合。 ArrayList array = new ArrayList(); // 定义一个统计变量。从0开始。 int count = 0; // 判断统计遍历是否小于10 while (count 键盘录入多个数据，以0结束，并在控制台输入最大值？ /* * 键盘录入多个数据，以0结束，要求在控制台输出这多个数据中的最大值 * 分析： * A:创建键盘录入数据对象 * B:键盘录入多个数据,我们不知道多少个，所以用集合存储 * C:以0结束,这个简单，只要键盘录入的数据是0，我就不继续录入数据了 * D:把集合转成数组 * E:对数组排序 * F:获取该数组中的最大索引的值 */ public class ArrayListDemo { public static void main(String[] args) { // 创建键盘录入数据对象 Scanner sc = new Scanner(System.in); // 键盘录入多个数据,我们不知道多少个，所以用集合存储 ArrayList array = new ArrayList(); // 以0结束,这个简单，只要键盘录入的数据是0，我就不继续录入数据了 while (true) { System.out.println(\"请输入数据：\"); int number = sc.nextInt(); if (number != 0) { array.add(number); } else { break; } } // 把集合转成数组 // public T[] toArray(T[] a) Integer[] i = new Integer[array.size()]; // Integer[] ii = array.toArray(i); array.toArray(i); // System.out.println(i); // System.out.println(ii); // 对数组排序 // public static void sort(Object[] a) Arrays.sort(i); // 获取该数组中的最大索引的值 System.out.println(\"数组是：\" + arrayToString(i) + \"最大值是:\" + i[i.length - 1]); } public static String arrayToString(Integer[] i) { StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for (int x = 0; x 1.2Map Map接口存储一组键值对象，提供key到value的映射. Map以按键/数值对的形式存储数据，和数组非常相似，在数组中存在的索引，它们本身也是对象； |--HashMap： 底层是哈希表数据结构，是线程不同步的。可以存储 null 键， null 值。替代了 Hashtable. |--Hashtable： 底层是哈希表数据结构，是线程同步的。不可以存储 null 键， null 值。 |--TreeMap： 底层是二叉树结构，可以对 map 集合中的键进行指定顺序的排序。 Map 集合存储和 Collection 有着很大不同： Collection 一次存一个元素； Map 一次存一对元素。 Collection 是单列集合； Map 是双列集合。 Map 中的存储的一对元素：一个是键，一个是值， 键与值之间有对应(映射)关系。 特点：要保证 map 集合中键的唯一性。 1，添加。 put(key,value)：当存储的键相同时，新的值会替换老的值，并将老值返回。如果键没有重复，返回 null。 void putAll(Map); 2，删除。 void clear()：清空 value remove(key) ：删除指定键。 3，判断。 boolean isEmpty()： boolean containsKey(key)：是否包含 key boolean containsValue(value) ：是否包含 value 4，取出。 int size()：返回长度 value get(key) ：通过指定键获取对应的值。如果返回 null，可以判断该键不存在。当然有特殊情况，就是在 hashmap 集合中，是可以存储 null 键 null 值的。Collection values()： 获取 map 集合中的所有的值。 5，想要获取 map 中的所有元素： 原理： map 中是没有迭代器的， collection 具备迭代器，只要将 map 集合转成 Set 集合，可以使用迭代器了。之所以转成 set，是因为 map 集合具备着键的唯一性，其实 set 集合就来自于 map， set 集合底层其实用的就是map 的方法。 ★ 把 map 集合转成 set 的方法： Set keySet(); Set entrySet();//取的是键和值的映射关系。 Entry 就是 Map 接口中的内部接口； 为什么要定义在 map 内部呢？ entry 是访问键值关系的入口，是 map 的入口，访问的是 map 中的键值对。 HashMap类 demo import java.util.HashMap; import java.util.Map; public class MyTest { public static void main(String[] args) { // 使用hashMap进行存储元素key-value; Map m=new HashMap(); //向map容器中存放元素 m.put(\"CN\", \"中国\"); m.put(\"FR\", \"法国\"); m.put(\"US\", \"美国\"); m.put(\"EN\", \"英国\"); //如何获得容器中的各个元素 ，通过key 获得value String cnValue=(String) m.get(\"CN\"); System.out.println(\"国家为：\"+cnValue); String frValue=(String)m.get(\"FR\"); System.out.println(\"国家为\"+frValue); String usValue=(String)m.get(\"US\"); System.out.println(\"国家为\"+usValue); String enValue=(String)m.get(\"EN\"); System.out.println(\"国家为\"+enValue); //显示集合中元素的个数 System.out.println(\"map中元素的个数\"+m.size()); //判断是否包含FR 键 boolean b=m.containsKey(\"FR\"); System.out.println(b); String s=(String)m.remove(\"FR\"); System.out.println(s); System.out.println(m.containsKey(\"FR\")); //显示键集 和值集 和键值集 System.out.println(m.keySet()); System.out.println(m.values()); System.out.println(m); //清空map容器 m.clear(); if(m.isEmpty()) { System.out.println(\"已经清空\"); } } } 练习 1、根据学生的英文名找到学生对象？ public class Student { private String name; // 学员姓名 private String sex; // 学员性别 public Student() { } public Student(String name, String sex) { this.name = name; this.sex = sex; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } import java.util.HashMap; import java.util.Map; public class HashMapDemo { public static void main(String[] args) { // 1、创建学员对象 Student student1 = new Student(\"李明\", \"男\"); Student student2 = new Student(\"刘丽\", \"女\"); // 2、创建保存“键-值对”的集合对象 Map students = new HashMap(); // 3、把英文名称与学员对象按照“键-值对”的方式存储在HashMap中 students.put(\"Jack\", student1); students.put(\"Rose\", student2); // 4、打印键集 /*System.out.println(\"键集：\"+students.keySet()); // 5、打印值集 System.out.println(\"值集：\"+students.values()); // 6、打印键-值对集合 System.out.println(\"键-值对集合:\"+students);*/ String key = \"Jack\"; // 7、判断是否存在”Jack”这个键 if(students.containsKey(key)){ // 8、如果存在，根据键获取相应的值 Student student = (Student)students.get(key); System.out.println(key+\"对应的学员姓名是：\"+student.getName()+\"；性别是：\"+student.getSex()); } } } 2、对题目1进行修改，使用泛型？ 1.3Collections类 Java集合框架将针对不同数据结构算法的实现都保存在工具类中。 Collections类定义了一系列用于操作集合的静态方法。 常用方法 import java.util.ArrayList; import java.util.Collections; import java.util.List; public class CollectionsDemo { public static void main(String[] args) { //创建集合 List list = new ArrayList(); //增加10个不同单词 list.add(\"this\"); list.add(\"is\"); list.add(\"collection\"); list.add(\"test\"); list.add(\"and\"); list.add(\"we\"); list.add(\"can\"); list.add(\"learn\"); list.add(\"how\"); list.add(\"to\"); //打印输出集合中最大元素和最小元素 String strMax = (String) Collections.max(list); String strMin = (String) Collections.min(list); System.out.println(\"最大值：\"+strMax); System.out.println(\"最小值：\"+strMin); //按升序打印输出集合中所有元素 Collections.sort(list); System.out.println(\"集合升序\"); for(int i=0;i 对自定义类进行排序 public class Student implements Comparable{ private int number=0; //学号 private String name=\"\"; //学生姓名 private String gender=\"\"; //性别 public int getNumber(){ return number; } public void setNumber(int number){ this.number=number; } public String getName(){ return name; } public void setName(String name){ this.name=name; } public String getGender(){ return gender; } public void setGender(String gender){ this.gender=gender; } public int compareTo(Object obj){ Student student=(Student)obj; if(this.number==student.number){ return 0; //如果学号相同，那么两者就是相等的 }else if(this.number>student.getNumber()){ return 1; //如果这个学生的学号大于传入学生的学号 }else{ return -1; //如果这个学生的学号小于传入学生的学号 } } } import java.util.ArrayList; import java.util.Collections; import java.util.Iterator; public class CollectionsDemo { public static void main(String[] args) { Student student1=new Student(); student1.setNumber(5); Student student2=new Student(); student2.setNumber(2); Student student3=new Student(); student3.setNumber(1); Student student4=new Student(); student4.setNumber(4); ArrayList list=new ArrayList(); list.add(student1); list.add(student2); list.add(student3); list.add(student4); System.out.println(\"-------排序前-------\"); Iterator iterator=list.iterator(); while(iterator.hasNext()){ Student stu=iterator.next(); System.out.println(stu.getNumber()); } //使用Collections的sort方法对list进行排序 System.out.println(\"-------排序后-------\"); Collections.sort(list); iterator=list.iterator(); while(iterator.hasNext()){ Student stu=iterator.next(); System.out.println(stu.getNumber()); } } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/collection/collection.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 16:45:15 "},"genericity/genericity.html":{"url":"genericity/genericity.html","title":"泛型","keywords":"","body":"2-泛型 是一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的特殊类型。也称为参数化类型，把类型当作参数进行传递。 /* * 回想一下，我们的数组 * String[] strArray = new String[3]; * strArray[0] = \"hello\"; * strArray[1] = \"world\"; * strArray[2] = 10; * 集合也模仿着数组的这种做法，在创建对象的时候明确元素的数据类型。这样就不会在有问题了。 * 而这种技术被称为：泛型。 * * 泛型：是一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。参数化类型，把类型当作参数一样的传递。 * 格式： * * 此处的数据类型只能是引用类型。 * 好处： * A:把运行时期的问题提前到了编译期间 * B:避免了强制类型转换 * C:优化了程序设计，解决了黄色警告线 */ public class GenericDemo { public static void main(String[] args) { // 创建 ArrayList array = new ArrayList(); // 添加元素 array.add(\"hello\"); array.add(\"world\"); array.add(\"java\"); // array.add(new Integer(100)); //array.add(10); // JDK5以后的自动装箱 // 等价于：array.add(Integer.valueOf(10)); // 遍历 Iterator it = array.iterator(); while (it.hasNext()) { // ClassCastException // String s = (String) it.next(); String s = it.next(); System.out.println(s); } // 看下面这个代码 // String[] strArray = new String[3]; // strArray[0] = \"hello\"; // strArray[1] = \"world\"; // strArray[2] = 10; } } /* * 泛型在哪些地方使用呢? * 看API，如果类，接口，抽象类后面跟的有就说要使用泛型。一般来说就是在集合中使用。 */ public class ArrayListDemo { public static void main(String[] args) { // 用ArrayList存储字符串元素，并遍历。用泛型改进代码 ArrayList array = new ArrayList(); array.add(\"hello\"); array.add(\"world\"); array.add(\"java\"); Iterator it = array.iterator(); while (it.hasNext()) { String s = it.next(); System.out.println(s); } System.out.println(\"-----------------\"); for (int x = 0; x /* * 泛型类：把泛型定义在类上 */ public class ObjectTool { private T obj; public T getObj() { return obj; } public void setObj(T obj) { this.obj = obj; } } /* * 泛型类的测试 */ public class ObjectToolDemo { public static void main(String[] args) { // ObjectTool ot = new ObjectTool(); // // ot.setObj(new String(\"吴亦凡\")); // String s = (String) ot.getObj(); // System.out.println(\"姓名是：\" + s); // // ot.setObj(new Integer(30)); // Integer i = (Integer) ot.getObj(); // System.out.println(\"年龄是：\" + i); // ot.setObj(new String(\"鹿晗\")); // // ClassCastException // Integer ii = (Integer) ot.getObj(); // System.out.println(\"姓名是：\" + ii); System.out.println(\"-------------\"); ObjectTool ot = new ObjectTool(); // ot.setObj(new Integer(27)); //这个时候编译期间就过不去 ot.setObj(new String(\"王力宏\")); String s = ot.getObj(); System.out.println(\"姓名是：\" + s); ObjectTool ot2 = new ObjectTool(); // ot2.setObj(new String(\"吴彦祖\"));//这个时候编译期间就过不去 ot2.setObj(new Integer(27)); Integer i = ot2.getObj(); System.out.println(\"年龄是：\" + i); } } /* * 泛型方法：把泛型定义在方法上 */ public class ObjectTool { public void show(T t) { System.out.println(t); } } public class ObjectToolDemo { public static void main(String[] args) { // ObjectTool ot = new ObjectTool(); // ot.show(\"hello\"); // ot.show(100); // ot.show(true); // ObjectTool ot = new ObjectTool(); // ot.show(\"hello\"); // // ObjectTool ot2 = new ObjectTool(); // ot2.show(100); // // ObjectTool ot3 = new ObjectTool(); // ot3.show(true); // 定义泛型方法后 ObjectTool ot = new ObjectTool(); ot.show(\"hello\"); ot.show(100); ot.show(true); } } /* * 泛型接口：把泛型定义在接口上 */ public interface Inter { public abstract void show(T t); } public class InterDemo { public static void main(String[] args) { // 第一种情况的测试 // Inter i = new InterImpl(); // i.show(\"hello\"); // // 第二种情况的测试 Inter i = new InterImpl(); i.show(\"hello\"); Inter ii = new InterImpl(); ii.show(100); } } /* * 泛型高级(通配符) * ?:任意类型，如果没有明确，那么就是Object以及任意的Java类了 * ? extends E:向下限定，E及其子类 * ? super E:向上限定，E极其父类 */ public class GenericDemo { public static void main(String[] args) { // 泛型如果明确的写的时候，前后必须一致 Collection c1 = new ArrayList(); // Collection c2 = new ArrayList(); // Collection c3 = new ArrayList(); // Collection c4 = new ArrayList(); // ?表示任意的类型都是可以的 Collection c5 = new ArrayList(); Collection c6 = new ArrayList(); Collection c7 = new ArrayList(); Collection c8 = new ArrayList(); // ? extends E:向下限定，E及其子类 // Collection c9 = new ArrayList(); Collection c10 = new ArrayList(); Collection c11 = new ArrayList(); Collection c12 = new ArrayList(); // ? super E:向上限定，E极其父类 Collection c13 = new ArrayList(); Collection c14 = new ArrayList(); // Collection c15 = new ArrayList(); // Collection c16 = new ArrayList(); } } class Animal { } class Dog extends Animal { } class Cat extends Animal { } demo /** * 宠物类，狗狗父类。 */ public abstract class Pet { protected String name = \"无名氏\";// 昵称 protected int health = 100;// 健康值 protected int love = 0;// 亲密度 public abstract void eat(); //抽象方法eat(),负责宠物吃饭功能。 /** * 无参构造方法。 */ public Pet() { } /** * 有参构造方法。 * @param name 昵称 */ public Pet(String name) { this.name = name; } public String getName() { return name; } public int getHealth() { return health; } public int getLove() { return love; } /** * 输出宠物信息。 */ public void print() { System.out.println(\"宠物的自我介绍：\\n我的名字叫\" + this.name + \"，健康值是\" + this.health + \"，和主人的亲密度是\" + this.love + \"。\"); } } /** * 狗狗类，宠物的子类。 */ public class Dog extends Pet { private String strain;// 品种 /** * 有参构造方法。 * @param name 昵称 * @param strain 品种 */ public Dog(String name, String strain) { super(name); this.strain = strain; } public String getStrain() { return strain; } /** * 重写父类的print方法。 */ public void print(){ super.print(); //调用父类的print方法 System.out.println(\"我是一只 \" + this.strain + \"。\"); } /** * 实现吃饭方法。 */ public void eat() { super.health = super.health + 3; System.out.println(\"狗狗\"+super.name + \"吃饱啦！健康值增加3。\"); } } import java.util.ArrayList; import java.util.List; /** * 对List应用使用泛型。 */ public class TestList { public static void main(String[] args) { /* 1、创建多个狗狗对象*/ Dog ououDog = new Dog(\"偶偶\", \"哈士奇\"); Dog yayaDog = new Dog(\"丫丫\", \"藏獒\"); Dog meimeiDog = new Dog(\"美眉\", \"金毛\"); Dog feifeiDog = new Dog(\"菲菲\", \"贵宾犬\"); /* 2、创建ArrayList集合对象并把多个狗狗对象放入其中*/ List dogs = new ArrayList();//标记元素类型 dogs.add(ououDog); dogs.add(yayaDog); dogs.add(meimeiDog); dogs.add(2, feifeiDog); // 添加feifeiDog到指定位置 //dogs.add(\"hello\"); //出现编译错误,元素类型不是Dog。 /* 3、 显示第三个元素的信息*/ Dog dog3 = dogs.get(2); //无需类型强制转换 System.out.println(\"第三个狗狗的信息如下:\"); System.out.println(dog3.getName() + \"\\t\" + dog3.getStrain()); /*4、使用foreach语句遍历dogs对象*/ System.out.println(\"\\n所有狗狗的信息如下：\"); for(Dog dog:dogs){//无需类型强制转换 System.out.println(dog.getName() + \"\\t\" + dog.getStrain()); } } } import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set; /** * 对Map应用使用泛型。 */ public class TestMap { public static void main(String[] args) { /* 1、创建多个狗狗对象*/ Dog ououDog = new Dog(\"偶偶\", \"哈士奇\"); Dog yayaDog = new Dog(\"丫丫\", \"金毛\"); Dog meimeiDog = new Dog(\"美眉\", \"藏獒\"); Dog feifeiDog = new Dog(\"菲菲\", \"贵宾犬\"); /* 2、创建Map集合对象并把多个狗狗对象放入其中*/ Map dogMap=new HashMap(); dogMap.put(ououDog.getName(),ououDog); dogMap.put(yayaDog.getName(),yayaDog); dogMap.put(meimeiDog.getName(),meimeiDog); dogMap.put(feifeiDog.getName(),feifeiDog); /*3、通过迭代器依次输出集合中所有狗狗的信息*/ System.out.println(\"使用Iterator遍历，所有狗狗的昵称和品种分别是：\"); Set keys=dogMap.keySet();//取出所有key的集合 Iterator it=keys.iterator();//获取Iterator对象 while(it.hasNext()){ String key=it.next(); //取出key Dog dog=dogMap.get(key); //根据key取出对应的值 System.out.println(key+\"\\t\"+dog.getStrain()); } /*//使用foreach语句输出集合中所有狗狗的信息 for(String key:keys){ Dog dog=dogMap.get(key); //根据key取出对应的值 System.out.println(key+\"\\t\"+dog.getStrain()); }*/ } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/genericity/genericity.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 16:46:50 "},"utility-class/utility-class.html":{"url":"utility-class/utility-class.html","title":"实用类","keywords":"","body":"3-实用类 3.1枚举 枚举指由一组固定的常量组成的类型。 //一周七天的枚举 public enum Week { MON,TUE,WED,THU,FRI,SAT,SUN } //没有使用枚举 public class WeekDemo1 { /** * 一周做什么事情 * */ public void doWhat(int day){ //使用条件判断 if(day>7 || day /** * 枚举常量的定义和使用 * */ public class WeekDemo2 { /** * 做什么事情 * */ public void doWhat(Week day){ //使用枚举 switch(day){ case MON: case TUE: case WED: case THU: case FRI: System.out.println(\"工作日，努力写代码！\"); break; case SAT: System.out.println(\"星期六，休息！看电影！\"); break; case SUN: System.out.println(\"星期日，休息！看电影！\"); break; default: System.out.println(\"地球上的一个星期就7天\"); } } public static void main(String[] args){ WeekDemo2 wd=new WeekDemo2(); //使用枚举 WeeK.FRI wd.doWhat(Week.FRI); } } 练习 1、使用枚举设计L1、L2、L3对应不同级别的工程师，并在控制台输出？ public class Test { // 定义枚举 public enum Level { L1,L2,L3 } public void show(Level level) { switch (level) { case L1: System.out.println(\"初级工程师\"); break; case L2: System.out.println(\"中级工程师\"); break; case L3: System.out.println(\"高级工程师\"); break; default: System.out.println(\"输入有错\"); } } public static void main(String[] args) { Test t = new Test(); t.show(Level.L1); Level level = Level.U2; t.show(level); t.show(Level.L3); } } 3.2包装类 包装类把基本类型数据转换为对象。每个基本类型在java.lang包中都有一个相应的包装类。 包装类作用 提供了一系列实用的方法。 集合不允许存放基本数据类型数据，存放数字时，要用包装类型。 public class Demo { public static void main(String[] args) { //所有包装类都可将与之对应的基本数据类型作为参数，来构造它们的实例 Integer i=new Integer(34); Double d=new Double(98.7); Boolean b=new Boolean(true); Character c=new Character('a'); System.out.println(i+\"\\t\"+d+\"\\t\"+b+\"\\t\"+c); //除Character类外，其他包装类可以一个字符串为参数构造它们的实例 //编译错误 //Character c2=new Character(\"a\"); Integer i2=new Integer(\"34\"); Double d2=new Double(\"98.7\"); Boolean b2=new Boolean(\"true\"); System.out.println(i2+\"\\t\"+d2+\"\\t\"+b2); //Boolean类构造方法参数为String类型时，若该字符串内容为true(不考虑大小写)，则该Boolean对象表示true，否则表示false Boolean b3=new Boolean(\"TRue\"); Boolean b4=new Boolean(\"false\"); Boolean b5=new Boolean(\"love\"); System.out.println(b3+\"\\t\"+b4+\"\\t\"+b5); //当包装类构造方法参数为String 类型时，字符串不能为null，且该字符串必须可解析为相应的基本数据类型的数据，否则编译通过，运行时NumberFormatException异常 Integer i3=new Integer(null); Double d4=new Double(\"包装类\"); System.out.println(i3+\"\\t\"+d4); } } /** * 包装类常用方法 * */ public class Demo { public static void main(String[] args){ //XXXValue():包装类转换成基本类型 Integer integerId=new Integer(25); int intId=integerId.intValue(); System.out.println(intId); Boolean booleanVal=new Boolean(true); boolean bool2=booleanVal.booleanValue(); System.out.println(bool2); System.out.println(\"*************************\"); //toString():以字符串形式返回包装对象表示的基本类型数据 String sex=Character.toString('男'); String id=Integer.toString(89); System.out.println(sex); System.out.println(id); String sex2='男'+\"\"; String id2=89+\"\"; System.out.println(sex2); System.out.println(id2); System.out.println(\"*************************\"); //所有包装类valueOf(type value) Integer intValue=Integer.valueOf(21); System.out.println(intValue); Boolean bool=Boolean.valueOf(false); System.out.println(bool); System.out.println(\"*************************\"); //除Character类外，其他包装类valueOf(String s) intValue=Integer.valueOf(\"32\"); //bool=Boolean.valueOf(\"true\"); bool=Boolean.valueOf(\"love\"); //编译错误 //Character c=Character.valueOf(\"a\"); System.out.println(intValue); System.out.println(bool); System.out.println(\"*************************\"); //parseXXX()：把字符串转换为相应的基本数据类型数据（Character除外） int i=Integer.parseInt(\"89\"); System.out.println(i); //boolean flag=Boolean.parseBoolean(\"true\"); //boolean flag=Boolean.parseBoolean(\"TRue\"); //boolean flag=Boolean.parseBoolean(\"love\"); boolean flag=Boolean.parseBoolean(\"false\"); System.out.println(flag); System.out.println(\"*************************\"); //基本类型和包装类的自动转换:装箱和拆箱 //装箱 Integer intObject=5; //拆箱 int intValue2=intObject; System.out.println(intObject+\"\\t\"+intValue2); } } Integer类 /* * 需求1：我要求大家把100这个数据的二进制，八进制，十六进制计算出来 * 需求2：我要求大家判断一个数据是否是int范围内的。 * 首先你的知道int的范围是多大? */ public class IntegerDemo { public static void main(String[] args) { // public static String toBinaryString(int i) System.out.println(Integer.toBinaryString(100)); // public static String toOctalString(int i) System.out.println(Integer.toOctalString(100)); // public static String toHexString(int i) System.out.println(Integer.toHexString(100)); // public static final int MAX_VALUE System.out.println(Integer.MAX_VALUE); // public static final int MIN_VALUE System.out.println(Integer.MIN_VALUE); } } /* * Integer的构造方法： * public Integer(int value) * public Integer(String s) * 注意：这个字符串必须是由数字字符组成 */ public class IntegerDemo { public static void main(String[] args) { // 方式1 int i = 100; Integer ii = new Integer(i); System.out.println(\"ii:\" + ii); // 方式2 String s = \"100\"; // NumberFormatException // String s = \"abc\"; Integer iii = new Integer(s); System.out.println(\"iii:\" + iii); } } /* * int类型和String类型的相互转换 * * int -- String * String.valueOf(number) * * String -- int * Integer.parseInt(s) */ public class IntegerDemo { public static void main(String[] args) { // int -- String int number = 100; // 方式1 String s1 = \"\" + number; System.out.println(\"s1:\" + s1); // 方式2 String s2 = String.valueOf(number); System.out.println(\"s2:\" + s2); // 方式3 // int -- Integer -- String Integer i = new Integer(number); String s3 = i.toString(); System.out.println(\"s3:\" + s3); // 方式4 // public static String toString(int i) String s4 = Integer.toString(number); System.out.println(\"s4:\" + s4); System.out.println(\"-----------------\"); // String -- int String s = \"100\"; // 方式1 // String -- Integer -- int Integer ii = new Integer(s); // public int intValue() int x = ii.intValue(); System.out.println(\"x:\" + x); //方式2 //public static int parseInt(String s) int y = Integer.parseInt(s); System.out.println(\"y:\"+y); } } /* * 常用的基本进制转换 * public static String toBinaryString(int i) * public static String toOctalString(int i) * public static String toHexString(int i) * * 十进制到其他进制 * public static String toString(int i,int radix) * 由这个我们也看到了进制的范围：2-36 * 为什么呢?0,...9,a...z * * 其他进制到十进制 * public static int parseInt(String s,int radix) */ public class IntegerDemo { public static void main(String[] args) { // 十进制到二进制，八进制，十六进制 System.out.println(Integer.toBinaryString(100)); System.out.println(Integer.toOctalString(100)); System.out.println(Integer.toHexString(100)); System.out.println(\"-------------------------\"); // 十进制到其他进制 System.out.println(Integer.toString(100, 10)); System.out.println(Integer.toString(100, 2)); System.out.println(Integer.toString(100, 8)); System.out.println(Integer.toString(100, 16)); System.out.println(Integer.toString(100, 5)); System.out.println(Integer.toString(100, 7)); System.out.println(Integer.toString(100, -7)); System.out.println(Integer.toString(100, 70)); System.out.println(Integer.toString(100, 1)); System.out.println(Integer.toString(100, 17)); System.out.println(Integer.toString(100, 32)); System.out.println(Integer.toString(100, 37)); System.out.println(Integer.toString(100, 36)); System.out.println(\"-------------------------\"); //其他进制到十进制 System.out.println(Integer.parseInt(\"100\", 10)); System.out.println(Integer.parseInt(\"100\", 2)); System.out.println(Integer.parseInt(\"100\", 8)); System.out.println(Integer.parseInt(\"100\", 16)); System.out.println(Integer.parseInt(\"100\", 23)); //NumberFormatException //System.out.println(Integer.parseInt(\"123\", 2)); } } /* * JDK5的新特性 * 自动装箱：把基本类型转换为包装类类型 * 自动拆箱：把包装类类型转换为基本类型 * * 注意一个小问题： * 在使用时，Integer x = null;代码就会出现NullPointerException。 * 建议先判断是否为null，然后再使用。 */ public class IntegerDemo { public static void main(String[] args) { // 定义了一个int类型的包装类类型变量i // Integer i = new Integer(100); Integer ii = 100; ii += 200; System.out.println(\"ii:\" + ii); // 通过反编译后的代码 // Integer ii = Integer.valueOf(100); //自动装箱 // ii = Integer.valueOf(ii.intValue() + 200); //自动拆箱，再自动装箱 // System.out.println((new StringBuilder(\"ii:\")).append(ii).toString()); Integer iii = null; // NullPointerException if (iii != null) { iii += 1000; System.out.println(iii); } } } /* * 注意：Integer的数据直接赋值，如果在-128到127之间，会直接从缓冲池里获取数据 */ public class IntegerDemo { public static void main(String[] args) { Integer i1 = new Integer(127); Integer i2 = new Integer(127); System.out.println(i1 == i2); System.out.println(i1.equals(i2)); System.out.println(\"-----------\"); Integer i3 = new Integer(128); Integer i4 = new Integer(128); System.out.println(i3 == i4); System.out.println(i3.equals(i4)); System.out.println(\"-----------\"); Integer i5 = 128; Integer i6 = 128; System.out.println(i5 == i6); System.out.println(i5.equals(i6)); System.out.println(\"-----------\"); Integer i7 = 127; Integer i8 = 127; System.out.println(i7 == i8); System.out.println(i7.equals(i8)); // 通过查看源码，我们就知道了，针对-128到127之间的数据，做了一个数据缓冲池，如果数据是该范围内的，每次并不创建新的空间 // Integer ii = Integer.valueOf(127); } } Character类 /* * Character 类在对象中包装一个基本类型 char 的值 * 此外，该类提供了几种方法，以确定字符的类别（小写字母，数字，等等），并将字符从大写转换成小写，反之亦然 * * 构造方法： * Character(char value) */ public class CharacterDemo { public static void main(String[] args) { // 创建对象 // Character ch = new Character((char) 97); Character ch = new Character('a'); System.out.println(\"ch:\" + ch); } } /* * public static boolean isUpperCase(char ch):判断给定的字符是否是大写字符 * public static boolean isLowerCase(char ch):判断给定的字符是否是小写字符 * public static boolean isDigit(char ch):判断给定的字符是否是数字字符 * public static char toUpperCase(char ch):把给定的字符转换为大写字符 * public static char toLowerCase(char ch):把给定的字符转换为小写字符 */ public class CharacterDemo { public static void main(String[] args) { // public static boolean isUpperCase(char ch):判断给定的字符是否是大写字符 System.out.println(\"isUpperCase:\" + Character.isUpperCase('A')); System.out.println(\"isUpperCase:\" + Character.isUpperCase('a')); System.out.println(\"isUpperCase:\" + Character.isUpperCase('0')); System.out.println(\"-----------------------------------------\"); // public static boolean isLowerCase(char ch):判断给定的字符是否是小写字符 System.out.println(\"isLowerCase:\" + Character.isLowerCase('A')); System.out.println(\"isLowerCase:\" + Character.isLowerCase('a')); System.out.println(\"isLowerCase:\" + Character.isLowerCase('0')); System.out.println(\"-----------------------------------------\"); // public static boolean isDigit(char ch):判断给定的字符是否是数字字符 System.out.println(\"isDigit:\" + Character.isDigit('A')); System.out.println(\"isDigit:\" + Character.isDigit('a')); System.out.println(\"isDigit:\" + Character.isDigit('0')); System.out.println(\"-----------------------------------------\"); // public static char toUpperCase(char ch):把给定的字符转换为大写字符 System.out.println(\"toUpperCase:\" + Character.toUpperCase('A')); System.out.println(\"toUpperCase:\" + Character.toUpperCase('a')); System.out.println(\"-----------------------------------------\"); // public static char toLowerCase(char ch):把给定的字符转换为小写字符 System.out.println(\"toLowerCase:\" + Character.toLowerCase('A')); System.out.println(\"toLowerCase:\" + Character.toLowerCase('a')); } } import java.util.Scanner; /* * 统计一个字符串中大写字母字符，小写字母字符，数字字符出现的次数。(不考虑其他字符) * * 分析： * A:定义三个统计变量。 * int bigCont=0; * int smalCount=0; * int numberCount=0; * B:键盘录入一个字符串。 * C:把字符串转换为字符数组。 * D:遍历字符数组获取到每一个字符 * E:判断该字符是 * 大写 bigCount++; * 小写 smalCount++; * 数字 numberCount++; * F:输出结果即可 */ public class CharacterTest { public static void main(String[] args) { // 定义三个统计变量。 int bigCount = 0; int smallCount = 0; int numberCount = 0; // 键盘录入一个字符串。 Scanner sc = new Scanner(System.in); System.out.println(\"请输入一个字符串：\"); String line = sc.nextLine(); // 把字符串转换为字符数组。 char[] chs = line.toCharArray(); // 历字符数组获取到每一个字符 for (int x = 0; x 3.3Math类 对于数学运算进行操作的类。 /* * Math:用于数学运算的类。 * 成员变量： * public static final double PI * public static final double E * 成员方法： * public static int abs(int a)：绝对值 * public static double ceil(double a):向上取整 * public static double floor(double a):向下取整 * public static int max(int a,int b):最大值 (min自学) * public static double pow(double a,double b):a的b次幂 * public static double random():随机数 [0.0,1.0) * public static int round(float a) 四舍五入(参数为double的自学) * public static double sqrt(double a):正平方根 */ public class MathDemo { public static void main(String[] args) { // public static final double PI System.out.println(\"PI:\" + Math.PI); // public static final double E System.out.println(\"E:\" + Math.E); System.out.println(\"--------------\"); // public static int abs(int a)：绝对值 System.out.println(\"abs:\" + Math.abs(10)); System.out.println(\"abs:\" + Math.abs(-10)); System.out.println(\"--------------\"); // public static double ceil(double a):向上取整 System.out.println(\"ceil:\" + Math.ceil(12.34)); System.out.println(\"ceil:\" + Math.ceil(12.56)); System.out.println(\"--------------\"); // public static double floor(double a):向下取整 System.out.println(\"floor:\" + Math.floor(12.34)); System.out.println(\"floor:\" + Math.floor(12.56)); System.out.println(\"--------------\"); // public static int max(int a,int b):最大值 System.out.println(\"max:\" + Math.max(12, 23)); // 需求：我要获取三个数据中的最大值 // 方法的嵌套调用 System.out.println(\"max:\" + Math.max(Math.max(12, 23), 18)); // 需求：我要获取四个数据中的最大值 System.out.println(\"max:\" + Math.max(Math.max(12, 78), Math.max(34, 56))); System.out.println(\"--------------\"); // public static double pow(double a,double b):a的b次幂 System.out.println(\"pow:\" + Math.pow(2, 3)); System.out.println(\"--------------\"); // public static double random():随机数 [0.0,1.0) System.out.println(\"random:\" + Math.random()); // 获取一个1-100之间的随机数 System.out.println(\"random:\" + ((int) (Math.random() * 100) + 1)); System.out.println(\"--------------\"); // public static int round(float a) 四舍五入(参数为double的自学) System.out.println(\"round:\" + Math.round(12.34f)); System.out.println(\"round:\" + Math.round(12.56f)); System.out.println(\"--------------\"); //public static double sqrt(double a):正平方根 System.out.println(\"sqrt:\"+Math.sqrt(4)); } } /* * 需求：请设计一个方法，可以实现获取任意范围内的随机数。 * * 分析： * A:键盘录入两个数据。 * int strat; * int end; * B:想办法获取在start到end之间的随机数 * 我写一个功能实现这个效果，得到一个随机数。(int) * C:输出这个随机数 */ public class MathDemo { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"请输入开始数：\"); int start = sc.nextInt(); System.out.println(\"请输入结束数：\"); int end = sc.nextInt(); for (int x = 0; x import java.util.Scanner; /* * 幸运抽奖：会员号的百位数与系统随机数相同，即为中奖 * */ public class GoodLuck { public static void main(String[] args) { //随机产生一个0-9之间的任意整数 int random=(int)(Math.random()*10); // System.out.println(random); //从控制台接收一个任意的四位数 System.out.print(\"请输入4位会员号：\"); Scanner input=new Scanner(System.in); int custNo=input.nextInt(); //获得会员号的百位数 int baiwei=custNo/100%10; if(baiwei==random){ System.out.println(custNo+\"是幸运客户，获得精美MP3一个。\"); }else{ System.out.println(custNo+\" 谢谢您的支持！\"); } } } 3.4Random类 产生随机数的类。 /* * Random:产生随机数的类 * * 构造方法： * public Random():没有给种子，用的是默认种子，是当前时间的毫秒值 * public Random(long seed):给出指定的种子 * * 给定种子后，每次得到的随机数是相同的。 * * 成员方法： * public int nextInt()：返回的是int范围内的随机数 * public int nextInt(int n):返回的是[0,n)范围的内随机数 */ public class RandomDemo { public static void main(String[] args) { // 创建对象 // Random r = new Random(); Random r = new Random(1111); for (int x = 0; x import java.util.Random; public class RandomDemo { public static void main(String[] args) { Random rand=new Random(); //创建一个Random对象 for(int i=0;i 3.5System类 系统类，提供一些关于系统的操作的方法。 public class Person { private String name; private int age; public Person() { super(); } public Person(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Person [name=\" + name + \", age=\" + age + \"]\"; } @Override protected void finalize() throws Throwable { System.out.println(\"当前的对象被回收了\" + this); super.finalize(); } } /* * System类包含一些有用的类字段和方法。它不能被实例化。 * * 方法： * public static void gc()：运行垃圾回收器。 * public static void exit(int status) * public static long currentTimeMillis() * public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length) */ public class SystemDemo { public static void main(String[] args) { Person p = new Person(\"赵雅芝\", 60); System.out.println(p); p = null; // 让p不再指定堆内存 System.gc(); } } /* * System类包含一些有用的类字段和方法。它不能被实例化。 * * 方法： * public static void gc()：运行垃圾回收器。 * public static void exit(int status):终止当前正在运行的 Java 虚拟机。参数用作状态码；根据惯例，非 0 的状态码表示异常终止。 * public static long currentTimeMillis():返回以毫秒为单位的当前时间 * public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length) */ public class SystemDemo { public static void main(String[] args) { // System.out.println(\"我们喜欢林青霞(东方不败)\"); // System.exit(0); // System.out.println(\"我们也喜欢赵雅芝(白娘子)\"); // System.out.println(System.currentTimeMillis()); // 单独得到这样的实际目前对我们来说意义不大 // 那么，它到底有什么作用呢? // 要求：请大家给我统计这段程序的运行时间 long start = System.currentTimeMillis(); for (int x = 0; x /* * System类包含一些有用的类字段和方法。它不能被实例化。 * * 方法： * public static void gc()：运行垃圾回收器。 * public static void exit(int status):终止当前正在运行的 Java 虚拟机。参数用作状态码；根据惯例，非 0 的状态码表示异常终止。 * public static long currentTimeMillis():返回以毫秒为单位的当前时间 * public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length) * 从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。 */ public class SystemDemo { public static void main(String[] args) { // 定义数组 int[] arr = { 11, 22, 33, 44, 55 }; int[] arr2 = { 6, 7, 8, 9, 10 }; // 请大家看这个代码的意思 System.arraycopy(arr, 1, arr2, 2, 2); System.out.println(Arrays.toString(arr)); System.out.println(Arrays.toString(arr2)); } } 3.6BigInteger类 针对大整数的运算。 /* * BigInteger:可以让超过Integer范围内的数据进行运算 * * 构造方法： * BigInteger(String val) */ public class BigIntegerDemo { public static void main(String[] args) { // 这几个测试，是为了简单超过int范围内，Integer就不能再表示，所以就更谈不上计算了。 // Integer i = new Integer(100); // System.out.println(i); // // System.out.println(Integer.MAX_VALUE); // Integer ii = new Integer(\"2147483647\"); // System.out.println(ii); // // NumberFormatException // Integer iii = new Integer(\"2147483648\"); // System.out.println(iii); // 通过大整数来创建对象 BigInteger bi = new BigInteger(\"2147483648\"); System.out.println(\"bi:\" + bi); } } import java.math.BigInteger; /* * public BigInteger add(BigInteger val):加 * public BigInteger subtract(BigInteger val):减 * public BigInteger multiply(BigInteger val):乘 * public BigInteger divide(BigInteger val):除 * public BigInteger[] divideAndRemainder(BigInteger val):返回商和余数的数组 */ public class BigIntegerDemo { public static void main(String[] args) { BigInteger bi1 = new BigInteger(\"100\"); BigInteger bi2 = new BigInteger(\"50\"); // public BigInteger add(BigInteger val):加 System.out.println(\"add:\" + bi1.add(bi2)); // public BigInteger subtract(BigInteger val):加 System.out.println(\"subtract:\" + bi1.subtract(bi2)); // public BigInteger multiply(BigInteger val):加 System.out.println(\"multiply:\" + bi1.multiply(bi2)); // public BigInteger divide(BigInteger val):加 System.out.println(\"divide:\" + bi1.divide(bi2)); // public BigInteger[] divideAndRemainder(BigInteger val):返回商和余数的数组 BigInteger[] bis = bi1.divideAndRemainder(bi2); System.out.println(\"商：\" + bis[0]); System.out.println(\"余数：\" + bis[1]); } } BigDecimal类 浮点数据做运算，会丢失精度。所以，对浮点数据的操作建议采用BigDecimal。 /* * 看程序写结果：结果和我们想的有一点点不一样，这是因为float类型的数据存储和整数不一样导致的。它们大部分的时候，都是带有有效数字位。 * * 由于在运算的时候，float类型和double很容易丢失精度，演示案例。所以，为了能精确的表示、计算浮点数，Java提供了BigDecimal * * BigDecimal类：不可变的、任意精度的有符号十进制数,可以解决数据丢失问题。 */ public class BigDecimalDemo { public static void main(String[] args) { System.out.println(0.09 + 0.01); System.out.println(1.0 - 0.32); System.out.println(1.015 * 100); System.out.println(1.301 / 100); System.out.println(1.0 - 0.12); } } import java.math.BigDecimal; /* * 构造方法： * public BigDecimal(String val) * * public BigDecimal add(BigDecimal augend) * public BigDecimal subtract(BigDecimal subtrahend) * public BigDecimal multiply(BigDecimal multiplicand) * public BigDecimal divide(BigDecimal divisor) * public BigDecimal divide(BigDecimal divisor,int scale,int roundingMode):商，几位小数，如何舍取 */ public class BigDecimalDemo { public static void main(String[] args) { // System.out.println(0.09 + 0.01); // System.out.println(1.0 - 0.32); // System.out.println(1.015 * 100); // System.out.println(1.301 / 100); BigDecimal bd1 = new BigDecimal(\"0.09\"); BigDecimal bd2 = new BigDecimal(\"0.01\"); System.out.println(\"add:\" + bd1.add(bd2)); System.out.println(\"-------------------\"); BigDecimal bd3 = new BigDecimal(\"1.0\"); BigDecimal bd4 = new BigDecimal(\"0.32\"); System.out.println(\"subtract:\" + bd3.subtract(bd4)); System.out.println(\"-------------------\"); BigDecimal bd5 = new BigDecimal(\"1.015\"); BigDecimal bd6 = new BigDecimal(\"100\"); System.out.println(\"multiply:\" + bd5.multiply(bd6)); System.out.println(\"-------------------\"); BigDecimal bd7 = new BigDecimal(\"1.301\"); BigDecimal bd8 = new BigDecimal(\"100\"); System.out.println(\"divide:\" + bd7.divide(bd8)); System.out.println(\"divide:\" + bd7.divide(bd8, 3, BigDecimal.ROUND_HALF_UP)); System.out.println(\"divide:\" + bd7.divide(bd8, 8, BigDecimal.ROUND_HALF_UP)); } } 3.7String类 多个字符组成的一组数据。也可以看成为字符数组。 /* * 字符串：就是由多个字符组成的一串数据。也可以看成是一个字符数组。 * 通过查看API，我们可以知道 * A:字符串字面值\"abc\"也可以看成是一个字符串对象。 * B:字符串是常量，一旦被赋值，就不能被改变。 * * 构造方法： * public String():空构造 * public String(byte[] bytes):把字节数组转成字符串 * public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串 * public String(char[] value):把字符数组转成字符串 * public String(char[] value,int index,int count):把字符数组的一部分转成字符串 * public String(String original):把字符串常量值转成字符串 * * 字符串的方法： * public int length()：返回此字符串的长度。 */ public class StringDemo { public static void main(String[] args) { // public String():空构造 String s1 = new String(); System.out.println(\"s1:\" + s1); System.out.println(\"s1.length():\" + s1.length()); System.out.println(\"--------------------------\"); // public String(byte[] bytes):把字节数组转成字符串 byte[] bys = { 97, 98, 99, 100, 101 }; String s2 = new String(bys); System.out.println(\"s2:\" + s2); System.out.println(\"s2.length():\" + s2.length()); System.out.println(\"--------------------------\"); // public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串 // 我想得到字符串\"bcd\" String s3 = new String(bys, 1, 3); System.out.println(\"s3:\" + s3); System.out.println(\"s3.length():\" + s3.length()); System.out.println(\"--------------------------\"); // public String(char[] value):把字符数组转成字符串 char[] chs = { 'a', 'b', 'c', 'd', 'e', '爱', '林', '亲' }; String s4 = new String(chs); System.out.println(\"s4:\" + s4); System.out.println(\"s4.length():\" + s4.length()); System.out.println(\"--------------------------\"); // public String(char[] value,int index,int count):把字符数组的一部分转成字符串 String s5 = new String(chs, 2, 4); System.out.println(\"s5:\" + s5); System.out.println(\"s5.length():\" + s5.length()); System.out.println(\"--------------------------\"); //public String(String original):把字符串常量值转成字符串 String s6 = new String(\"abcde\"); System.out.println(\"s6:\" + s6); System.out.println(\"s6.length():\" + s6.length()); System.out.println(\"--------------------------\"); //字符串字面值\"abc\"也可以看成是一个字符串对象。 String s7 = \"abcde\"; System.out.println(\"s7:\"+s7); System.out.println(\"s7.length():\"+s7.length()); } } /* * A:字符串一旦被赋值，就不能改变。 * 注意：这里指的是字符串的内容不能改变，而不是引用不能改变。 * B:字面值作为字符串对象和通过构造方法创建对象的不同 * String s = new String(\"hello\");和String s = \"hello\"的区别? * */ public class StringDemo { public static void main(String[] args) { String s = \"hello\"; s += \"world\"; System.out.println(\"s:\" + s); // helloworld } } /* * String s = new String(“hello”)和String s = “hello”;的区别? * 有。前者会创建2个对象，后者创建1个对象。 * * ==:比较引用类型比较的是地址值是否相同 * equals:比较引用类型默认也是比较地址值是否相同，而String类重写了equals()方法，比较的是内容是否相同。 */ public class StringDemo2 { public static void main(String[] args) { String s1 = new String(\"hello\"); String s2 = \"hello\"; System.out.println(s1 == s2);// false System.out.println(s1.equals(s2));// true } } /* * 看程序写结果 * 字符串如果是变量相加，先开空间，在拼接。 * 字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。 */ public class StringDemo4 { public static void main(String[] args) { String s1 = \"hello\"; String s2 = \"world\"; String s3 = \"helloworld\"; System.out.println(s3 == s1 + s2);// false System.out.println(s3.equals((s1 + s2)));// true System.out.println(s3 == \"hello\" + \"world\");// false 这个我们错了，应该是true System.out.println(s3.equals(\"hello\" + \"world\"));// true // 通过反编译看源码，我们知道这里已经做好了处理。 // System.out.println(s3 == \"helloworld\"); // System.out.println(s3.equals(\"helloworld\")); } } 练习 A:==和equals() String s1 = new String(\"hello\"); String s2 = new String(\"hello\"); System.out.println(s1 == s2);//false System.out.println(s1.equals(s2));// true String s3 = new String(\"hello\"); String s4 = \"hello\"; System.out.println(s3 == s4);// false System.out.println(s3.equals(s4));// true String s5 = \"hello\"; String s6 = \"hello\"; System.out.println(s5 == s6);// true System.out.println(s5.equals(s6));// true B:字符串的拼接 String s1 = \"hello\"; String s2 = \"world\"; String s3 = \"helloworld\"; System.out.println(s3 == s1 + s2);// false System.out.println(s3.equals((s1 + s2)));// true System.out.println(s3 == \"hello\" + \"world\");// false 这个我们错了，应该是true System.out.println(s3.equals(\"hello\" + \"world\"));// true 字符串长度 import java.util.*; public class Register { /** * 注册密码长度不少于6位 */ public static void main(String[] args) { Scanner input = new Scanner(System.in); String uname,pwd; System.out.print(\"请输入用户名： \"); uname=input.next(); System.out.print(\"请输入密码： \"); pwd=input.next(); if(pwd.length()>=6){ System.out.print(\"注册成功！ \"); }else{ System.out.print(\"密码长度不能小于6位！\"); } } } 字符串比较 import java.util.*; public class Login { /** * 登录 */ public static void main(String[] args) { Scanner input = new Scanner(System.in); String uname,pwd; System.out.print(\"请输入用户名： \"); uname=input.next(); System.out.print(\"请输入密码： \"); pwd=input.next(); if(uname.equals(\"Jack\")&&pwd.equals(\"123456\")){ System.out.print(\"登录成功！ \"); }else{ System.out.print(\"用户名或密码不匹配，登录失败！\"); } } } ==和equals（）比较 public class StrEqu { public static void main(String[] args) { String str1=\"abcd\"; String str2=\"abcd\"; System.out.println(str1==str2); System.out.println(str1.equals(str2)); String str3=new String(\"abcd\"); System.out.println(str1==str3); System.out.println(str1.equals(str3)); String str4=new String(\"abcd\"); System.out.println(str3==str4); System.out.println(str3.equals(str4)); } } 忽略大小写的字符串比较 import java.util.*; public class Login { /** * 登录 */ public static void main(String[] args) { Scanner input = new Scanner(System.in); String uname,pwd; System.out.print(\"请输入用户名： \"); uname=input.next(); System.out.print(\"请输入密码： \"); pwd=input.next(); /* if(uname.equals(\"TOM\")&&pwd.equals(\"1234567\")){ System.out.print(\"登录成功！ \"); }else{ System.out.print(\"用户名或密码不匹配，登录失败！\"); }*/ if(uname.equalsIgnoreCase(\"TOM\")&&pwd.equalsIgnoreCase(\"1234567\")){ System.out.print(\"登录成功！ \"); }else{ System.out.print(\"用户名或密码不匹配，登录失败！\"); } } } 字符串连接 public class PrintScore { /** * 打印成绩单 * */ public static void main(String[] args) { int sqlScore = 80; //SQL成绩 int javaScore = 90; //Java成绩 double htmlScore = 86.7; //HTML成绩 //成绩单 String scoreSheet = \"SQL:\" + sqlScore + \" Java:\" + javaScore + \" HTML:\" + htmlScore; //打印成绩单 System.out.println(\"*****成绩单*****\"); System.out.println(scoreSheet); String bottom = \"\\n\\t\\t清华大学教务处所有：\".concat(\"社科院\"); System.out.println(bottom); } } 字符串提取 import java.util.*; public class Verify{ public static void main(String[] args) { // 声明变量 boolean fileCorrect = false; //标识文件名是否正确 boolean emailCorrect = false; //标识E-mail是否正确 System.out.print(\"---欢迎进入作业提交系统---\"); Scanner input = new Scanner(System.in); System.out.println(\"请输入Java文件名: \"); String fileName = input.next(); System.out.print(\"请输入你的邮箱:\"); String email = input.next(); //检查Java文件名 int index = fileName.lastIndexOf(\".\"); //\".\"的位置 if(index!=-1 && index!=0 && fileName.substring(index+1, fileName.length()).equals(\"java\")){ fileCorrect = true; //标识文件名正确 }else{ System.out.println(\"文件名无效。\"); } //检查你的邮箱格式 if(email.indexOf('@')!=-1 && email.indexOf('.')>email.indexOf('@')){ emailCorrect = true; //标识E-mail正确 }else{ System.out.println(\"E-mail无效。\"); } //输出检测结果 if(fileCorrect && emailCorrect){ System.out.println(\"作业提交成功!\"); }else{ System.out.println(\"作业提交失败!\"); } } } 字符串拆分 public class Poem { /** * 拆分诗歌 */ public static void main(String[] args) { String words=\"君不见黄河之水天上来 奔流到海不复回 君不见高堂明镜悲白发 朝如青丝暮成雪\"; String[] printword=new String[100];//接收数组 System.out.println(\"***原诗歌格式***\\n\"+words); System.out.println(\"\\n***拆分后诗歌格式***\"); printword=words.split(\" \");//按照空格进行拆分 for(int i=0;i String类的获取功能 /* * String类的获取功能 * int length():获取字符串的长度。 * char charAt(int index):获取指定索引位置的字符 * int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。 * 为什么这里是int类型，而不是char类型? * 原因是：'a'和97其实都可以代表'a' * int indexOf(String str):返回指定字符串在此字符串中第一次出现处的索引。 * int indexOf(int ch,int fromIndex):返回指定字符在此字符串中从指定位置后第一次出现处的索引。 * int indexOf(String str,int fromIndex):返回指定字符串在此字符串中从指定位置后第一次出现处的索引。 * String substring(int start):从指定位置开始截取字符串,默认到末尾。 * String substring(int start,int end):从指定位置开始到指定位置结束截取字符串。 */ public class StringDemo { public static void main(String[] args) { // 定义一个字符串对象 String s = \"helloworld\"; // int length():获取字符串的长度。 System.out.println(\"s.length:\" + s.length()); System.out.println(\"----------------------\"); // char charAt(int index):获取指定索引位置的字符 System.out.println(\"charAt:\" + s.charAt(7)); System.out.println(\"----------------------\"); // int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。 System.out.println(\"indexOf:\" + s.indexOf('l')); System.out.println(\"----------------------\"); // int indexOf(String str):返回指定字符串在此字符串中第一次出现处的索引。 System.out.println(\"indexOf:\" + s.indexOf(\"owo\")); System.out.println(\"----------------------\"); // int indexOf(int ch,int fromIndex):返回指定字符在此字符串中从指定位置后第一次出现处的索引。 System.out.println(\"indexOf:\" + s.indexOf('l', 4)); System.out.println(\"indexOf:\" + s.indexOf('k', 4)); // -1 System.out.println(\"indexOf:\" + s.indexOf('l', 40)); // -1 System.out.println(\"----------------------\"); // 自己练习：int indexOf(String str,int // fromIndex):返回指定字符串在此字符串中从指定位置后第一次出现处的索引。 // String substring(int start):从指定位置开始截取字符串,默认到末尾。包含start这个索引 System.out.println(\"substring:\" + s.substring(5)); System.out.println(\"substring:\" + s.substring(0)); System.out.println(\"----------------------\"); // String substring(int start,int // end):从指定位置开始到指定位置结束截取字符串。包括start索引但是不包end索引 System.out.println(\"substring:\" + s.substring(3, 8)); System.out.println(\"substring:\" + s.substring(0, s.length())); } } 遍历获取字符串中的每一个字符 /* * 需求：遍历获取字符串中的每一个字符 * * 分析： * A:如何能够拿到每一个字符呢? * char charAt(int index) * B:我怎么知道字符到底有多少个呢? * int length() */ public class StringTest { public static void main(String[] args) { // 定义字符串 String s = \"helloworld\"; // 原始版本 // System.out.println(s.charAt(0)); // System.out.println(s.charAt(1)); // System.out.println(s.charAt(2)); // System.out.println(s.charAt(3)); // System.out.println(s.charAt(4)); // System.out.println(s.charAt(5)); // System.out.println(s.charAt(6)); // System.out.println(s.charAt(7)); // System.out.println(s.charAt(8)); // System.out.println(s.charAt(9)); // 只需要我们从0取到9 // for (int x = 0; x 统计各种字符出现的次数 /* * 需求：统计一个字符串中大写字母字符，小写字母字符，数字字符出现的次数。(不考虑其他字符) * 举例： * \"Hello123World\" * 结果： * 大写字符：2个 * 小写字符：8个 * 数字字符：3个 * * 分析： * 前提：字符串要存在 * A:定义三个统计变量 * bigCount=0 * smallCount=0 * numberCount=0 * B:遍历字符串，得到每一个字符。 * length()和charAt()结合 * C:判断该字符到底是属于那种类型的 * 大：bigCount++ * 小：smallCount++ * 数字：numberCount++ * * 这道题目的难点就是如何判断某个字符是大的，还是小的，还是数字的。 * ASCII码表： * 0 48 * A 65 * a 97 * 虽然，我们按照数字的这种比较是可以的，但是想多了，有比这还简单的 * char ch = s.charAt(x); * * if(ch>='0' && ch='a' && ch='A' && ch='a' && ch='A' && ch='0' && ch String的转换功能 /* * String的转换功能： * byte[] getBytes():把字符串转换为字节数组。 * char[] toCharArray():把字符串转换为字符数组。 * static String valueOf(char[] chs):把字符数组转成字符串。 * static String valueOf(int i):把int类型的数据转成字符串。 * 注意：String类的valueOf方法可以把任意类型的数据转成字符串。 * String toLowerCase():把字符串转成小写。 * String toUpperCase():把字符串转成大写。 * String concat(String str):把字符串拼接。 */ public class StringDemo { public static void main(String[] args) { // 定义一个字符串对象 String s = \"JavaSE\"; // byte[] getBytes():把字符串转换为字节数组。 byte[] bys = s.getBytes(); for (int x = 0; x 字符串首字母大写，其他小写 /* * 需求：把一个字符串的首字母转成大写，其余为小写。(只考虑英文大小写字母字符) * 举例： * helloWORLD * 结果： * Helloworld * * 分析： * A:先获取第一个字符 * B:获取除了第一个字符以外的字符 * C:把A转成大写 * D:把B转成小写 * E:C拼接D */ public class StringTest { public static void main(String[] args) { // 定义一个字符串 String s = \"helloWORLD\"; // 先获取第一个字符 String s1 = s.substring(0, 1); // 获取除了第一个字符以外的字符 String s2 = s.substring(1); // 把A转成大写 String s3 = s1.toUpperCase(); // 把B转成小写 String s4 = s2.toLowerCase(); // C拼接D String s5 = s3.concat(s4); System.out.println(s5); // 优化后的代码 // 链式编程 String result = s.substring(0, 1).toUpperCase() .concat(s.substring(1).toLowerCase()); System.out.println(result); } } String的替换、去空格、字典比较功能 /* * String类的其他功能： * * 替换功能： * String replace(char old,char new) * String replace(String old,String new) * * 去除字符串两空格 * String trim() * * 按字典顺序比较两个字符串 * int compareTo(String str) * int compareToIgnoreCase(String str) */ public class StringDemo { public static void main(String[] args) { // 替换功能 String s1 = \"helloworld\"; String s2 = s1.replace('l', 'k'); String s3 = s1.replace(\"owo\", \"ak47\"); System.out.println(\"s1:\" + s1); System.out.println(\"s2:\" + s2); System.out.println(\"s3:\" + s3); System.out.println(\"---------------\"); // 去除字符串两空格 String s4 = \" hello world \"; String s5 = s4.trim(); System.out.println(\"s4:\" + s4 + \"---\"); System.out.println(\"s5:\" + s5 + \"---\"); // 按字典顺序比较两个字符串 String s6 = \"hello\"; String s7 = \"hello\"; String s8 = \"abc\"; String s9 = \"xyz\"; System.out.println(s6.compareTo(s7));// 0 System.out.println(s6.compareTo(s8));// 7 System.out.println(s6.compareTo(s9));// -16 } } 把数组中的数据按照指定个格式拼接成一个字符串 /* * 需求：把数组中的数据按照指定个格式拼接成一个字符串 * 举例： * int[] arr = {1,2,3}; * 输出结果： * \"[1, 2, 3]\" * 分析： * A:定义一个字符串对象，只不过内容为空 * B:先把字符串拼接一个\"[\" * C:遍历int数组，得到每一个元素 * D:先判断该元素是否为最后一个 * 是：就直接拼接元素和\"]\" * 不是：就拼接元素和逗号以及空格 * E:输出拼接后的字符串 */ public class StringTest { public static void main(String[] args) { // 前提是数组已经存在 int[] arr = { 1, 2, 3 }; // 定义一个字符串对象，只不过内容为空 String s = \"\"; // 先把字符串拼接一个\"[\" s += \"[\"; // 遍历int数组，得到每一个元素 for (int x = 0; x 字符串反转 public class StringTest3 { public static void main(String[] args) { // 键盘录入一个字符串 Scanner sc = new Scanner(System.in); System.out.println(\"请输入一个字符串：\"); String line = sc.nextLine(); /* // 定义一个新字符串 String result = \"\"; // 把字符串转成字符数组 char[] chs = line.toCharArray(); // 倒着遍历字符串，得到每一个字符 for (int x = chs.length - 1; x >= 0; x--) { // 用新字符串把每一个字符拼接起来 result += chs[x]; } // 输出新串 System.out.println(\"反转后的结果是：\" + result); */ // 改进为功能实现 String s = myReverse(line); System.out.println(\"实现功能后的结果是：\" + s); } /* * 两个明确： 返回值类型：String 参数列表：String */ public static String myReverse(String s) { // 定义一个新字符串 String result = \"\"; // 把字符串转成字符数组 char[] chs = s.toCharArray(); // 倒着遍历字符串，得到每一个字符 for (int x = chs.length - 1; x >= 0; x--) { // 用新字符串把每一个字符拼接起来 result += chs[x]; } return result; } } 统计大串中小串出现的次数 /* * 统计大串中小串出现的次数 * 举例： * 在字符串\"woaijavawozhenaijavawozhendeaijavawozhendehenaijavaxinbuxinwoaijavagun\" * 结果： * java出现了5次 * * 分析： * 前提：是已经知道了大串和小串。 * * A:定义一个统计变量，初始化值是0 * B:先在大串中查找一次小串第一次出现的位置 * a:索引是-1，说明不存在了，就返回统计变量 * b:索引不是-1，说明存在，统计变量++ * C:把刚才的索引+小串的长度作为开始位置截取上一次的大串，返回一个新的字符串，并把该字符串的值重新赋值给大串 * D:回到B */ public class StringTest4 { public static void main(String[] args) { // 定义大串 String maxString = \"woaijavawozhenaijavawozhendeaijavawozhendehenaijavaxinbuxinwoaijavagun\"; // 定义小串 String minString = \"java\"; // 写功能实现 int count = getCount(maxString, minString); System.out.println(\"Java在大串中出现了：\" + count + \"次\"); } /* * 两个明确： 返回值类型：int 参数列表：两个字符串 */ public static int getCount(String maxString, String minString) { // 定义一个统计变量，初始化值是0 int count = 0; // 先在大串中查找一次小串第一次出现的位置 int index = maxString.indexOf(minString); // 索引不是-1，说明存在，统计变量++ while (index != -1) { count++; // 把刚才的索引+小串的长度作为开始位置截取上一次的大串，返回一个新的字符串，并把该字符串的值重新赋值给大串 int startIndex = index + minString.length(); maxString = maxString.substring(startIndex); // 继续查 index = maxString.indexOf(minString); } return count; } } /* * 统计大串中小串出现的次数 * 举例： * 在字符串\"woaijavawozhenaijavawozhendeaijavawozhendehenaijavaxinbuxinwoaijavagun\" * 结果： * java出现了5次 * * 分析： * 前提：是已经知道了大串和小串。 * * A:定义一个统计变量，初始化值是0 * B:先在大串中查找一次小串第一次出现的位置 * a:索引是-1，说明不存在了，就返回统计变量 * b:索引不是-1，说明存在，统计变量++ * C:把刚才的索引+小串的长度作为开始位置截取上一次的大串，返回一个新的字符串，并把该字符串的值重新赋值给大串 * D:回到B */ public class StringTest5 { public static void main(String[] args) { // 定义大串 String maxString = \"woaijavawozhenaijavawozhendeaijavawozhendehenaijavaxinbuxinwoaijavagun\"; // 定义小串 String minString = \"java\"; // 写功能实现 int count = getCount(maxString, minString); System.out.println(\"Java在大串中出现了：\" + count + \"次\"); } /* * 两个明确： 返回值类型：int 参数列表：两个字符串 */ public static int getCount(String maxString, String minString) { // 定义一个统计变量，初始化值是0 int count = 0; /* // 先在大串中查找一次小串第一次出现的位置 int index = maxString.indexOf(minString); // 索引不是-1，说明存在，统计变量++ while (index != -1) { count++; // 把刚才的索引+小串的长度作为开始位置截取上一次的大串，返回一个新的字符串，并把该字符串的值重新赋值给大串 // int startIndex = index + minString.length(); // maxString = maxString.substring(startIndex); maxString = maxString.substring(index + minString.length()); // 继续查 index = maxString.indexOf(minString); } */ int index; //先查，赋值，判断 while((index=maxString.indexOf(minString))!=-1){ count++; maxString = maxString.substring(index + minString.length()); } return count; } } 练习 1、编写会员注册信息验证？ import java.util.Scanner; public class Register { /** * 验证注册信息 * @return flag 验证信息 */ public boolean verify(String name,String pwd1,String pwd2){ boolean flag=false; if(name.length() 2、查找特定字符出现的次数？ import java.util.Scanner; public class Counter { public int counter(String inputs,String word){ int counter=0;//计数器，初始化0 String[] temps=new String[inputs.length()]; //字符串转换成数组 for(int i=0;i 3、模拟登录，给出3次机会，并提示还有几次？ import java.util.Scanner; /* * 模拟登录,给三次机会,并提示还有几次。 * * 分析： * A:定义用户名和密码。已存在的。 * B:键盘录入用户名和密码。 * C:比较用户名和密码。 * 如果都相同，则登录成功 * 如果有一个不同，则登录失败 * D:给三次机会，用循环改进，最好用for循环。 */ public class StringTest { public static void main(String[] args) { // 定义用户名和密码。已存在的。 String username = \"admin\"; String password = \"admin\"; // 给三次机会，用循环改进，最好用for循环。 for (int x = 0; x 4、模拟登录,给三次机会,并提示还有几次。如果登录成功，就可以玩猜数字小游戏了。 import java.util.Scanner; /* * 模拟登录,给三次机会,并提示还有几次。如果登录成功，就可以玩猜数字小游戏了。 * * 分析： * A:定义用户名和密码。已存在的。 * B:键盘录入用户名和密码。 * C:比较用户名和密码。 * 如果都相同，则登录成功 * 如果有一个不同，则登录失败 * D:给三次机会，用循环改进，最好用for循环。 */ public class StringTest2 { public static void start() { // 产生一个随机数 int number = (int) (Math.random() * 100) + 1; while (true) { // 键盘录入数据 Scanner sc = new Scanner(System.in); System.out.println(\"请输入你要猜的数据(1-100)：\"); int guessNumber = sc.nextInt(); // 判断 if (guessNumber > number) { System.out.println(\"你猜的数据\" + guessNumber + \"大了\"); } else if (guessNumber 3.8StringBuffer类 用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为了解决这个问题，Java就提供了 一个字符串缓冲区类。StringBuffer供我们使用。 import java.util.*; public class TestInsert { /** * 每隔三位插入逗号 * */ public static void main(String[] args) { Scanner input = new Scanner(System.in); //接收数字串，存放于StringBuffer类型的对象中 System.out.print(\"请输入一串数字： \"); String nums = input.next(); StringBuffer str=new StringBuffer(nums); //从后往前每隔三位添加逗号 for(int i=str.length()-3;i>0;i=i-3){ str.insert(i,','); } System.out.print(str); } } /* * StringBuffer的构造方法： * public StringBuffer():无参构造方法 * public StringBuffer(int capacity):指定容量的字符串缓冲区对象 * public StringBuffer(String str):指定字符串内容的字符串缓冲区对象 * * StringBuffer的方法： * public int capacity()：返回当前容量。 理论值 * public int length():返回长度（字符数）。 实际值 */ public class StringBufferDemo { public static void main(String[] args) { // public StringBuffer():无参构造方法 StringBuffer sb = new StringBuffer(); System.out.println(\"sb:\" + sb); System.out.println(\"sb.capacity():\" + sb.capacity()); System.out.println(\"sb.length():\" + sb.length()); System.out.println(\"--------------------------\"); // public StringBuffer(int capacity):指定容量的字符串缓冲区对象 StringBuffer sb2 = new StringBuffer(50); System.out.println(\"sb2:\" + sb2); System.out.println(\"sb2.capacity():\" + sb2.capacity()); System.out.println(\"sb2.length():\" + sb2.length()); System.out.println(\"--------------------------\"); // public StringBuffer(String str):指定字符串内容的字符串缓冲区对象 StringBuffer sb3 = new StringBuffer(\"hello\"); System.out.println(\"sb3:\" + sb3); System.out.println(\"sb3.capacity():\" + sb3.capacity()); System.out.println(\"sb3.length():\" + sb3.length()); } } /* * StringBuffer的添加功能： * public StringBuffer append(String str):可以把任意类型数据添加到字符串缓冲区里面,并返回字符串缓冲区本身 * * public StringBuffer insert(int offset,String str):在指定位置把任意类型的数据插入到字符串缓冲区里面,并返回字符串缓冲区本身 */ public class StringBufferDemo { public static void main(String[] args) { // 创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); // public StringBuffer append(String str) // StringBuffer sb2 = sb.append(\"hello\"); // System.out.println(\"sb:\" + sb); // System.out.println(\"sb2:\" + sb2); // System.out.println(sb == sb2); // true // 一步一步的添加数据 // sb.append(\"hello\"); // sb.append(true); // sb.append(12); // sb.append(34.56); // 链式编程 sb.append(\"hello\").append(true).append(12).append(34.56); System.out.println(\"sb:\" + sb); // public StringBuffer insert(int offset,String // str):在指定位置把任意类型的数据插入到字符串缓冲区里面,并返回字符串缓冲区本身 sb.insert(5, \"world\"); System.out.println(\"sb:\" + sb); } } /* * StringBuffer的删除功能 * public StringBuffer deleteCharAt(int index):删除指定位置的字符，并返回本身 * public StringBuffer delete(int start,int end):删除从指定位置开始指定位置结束的内容，并返回本身 */ public class StringBufferDemo { public static void main(String[] args) { // 创建对象 StringBuffer sb = new StringBuffer(); // 添加功能 sb.append(\"hello\").append(\"world\").append(\"java\"); System.out.println(\"sb:\" + sb); // public StringBuffer deleteCharAt(int index):删除指定位置的字符，并返回本身 // 需求：我要删除e这个字符，肿么办? // sb.deleteCharAt(1); // 需求:我要删除第一个l这个字符，肿么办? // sb.deleteCharAt(1); // public StringBuffer delete(int start,int // end):删除从指定位置开始指定位置结束的内容，并返回本身 // 需求：我要删除world这个字符串，肿么办? // sb.delete(5, 10); // 需求:我要删除所有的数据 sb.delete(0, sb.length()); System.out.println(\"sb:\" + sb); } } /* * StringBuffer的替换功能： * public StringBuffer replace(int start,int end,String str):从start开始到end用str替换 */ public class StringBufferDemo { public static void main(String[] args) { // 创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); // 添加数据 sb.append(\"hello\"); sb.append(\"world\"); sb.append(\"java\"); System.out.println(\"sb:\" + sb); // public StringBuffer replace(int start,int end,String // str):从start开始到end用str替换 // 需求：我要把world这个数据替换为\"节日快乐\" sb.replace(5, 10, \"节日快乐\"); System.out.println(\"sb:\" + sb); } } /* * StringBuffer的反转功能： * public StringBuffer reverse() */ public class StringBufferDemo { public static void main(String[] args) { // 创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); // 添加数据 sb.append(\"霞青林爱我\"); System.out.println(\"sb:\" + sb); // public StringBuffer reverse() sb.reverse(); System.out.println(\"sb:\" + sb); } } /* * StringBuffer的截取功能:注意返回值类型不再是StringBuffer本身了 * public String substring(int start) * public String substring(int start,int end) */ public class StringBufferDemo { public static void main(String[] args) { // 创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); // 添加元素 sb.append(\"hello\").append(\"world\").append(\"java\"); System.out.println(\"sb:\" + sb); // 截取功能 // public String substring(int start) String s = sb.substring(5); System.out.println(\"s:\" + s); System.out.println(\"sb:\" + sb); // public String substring(int start,int end) String ss = sb.substring(5, 10); System.out.println(\"ss:\" + ss); System.out.println(\"sb:\" + sb); } } /*为什么我们要讲解类之间的转换： * A -- B的转换 * 我们把A转换为B，其实是为了使用B的功能。 * B -- A的转换 * 我们可能要的结果是A类型，所以还得转回来。 * String和StringBuffer的相互转换?*/ public class StringBufferTest { public static void main(String[] args) { // String -- StringBuffer String s = \"hello\"; // 注意：不能把字符串的值直接赋值给StringBuffer // StringBuffer sb = \"hello\"; // StringBuffer sb = s; // 方式1:通过构造方法 StringBuffer sb = new StringBuffer(s); // 方式2：通过append()方法 StringBuffer sb2 = new StringBuffer(); sb2.append(s); System.out.println(\"sb:\" + sb); System.out.println(\"sb2:\" + sb2); System.out.println(\"---------------\"); // StringBuffer -- String StringBuffer buffer = new StringBuffer(\"java\"); // String(StringBuffer buffer) // 方式1:通过构造方法 String str = new String(buffer); // 方式2：通过toString()方法 String str2 = buffer.toString(); System.out.println(\"str:\" + str); System.out.println(\"str2:\" + str2); } } /* * 把数组拼接成一个字符串 */ public class StringBufferTest2 { public static void main(String[] args) { // 定义一个数组 int[] arr = { 44, 33, 55, 11, 22 }; // 定义功能 // 方式1：用String做拼接的方式 String s1 = arrayToString(arr); System.out.println(\"s1:\" + s1); // 方式2:用StringBuffer做拼接的方式 String s2 = arrayToString2(arr); System.out.println(\"s2:\" + s2); } // 用StringBuffer做拼接的方式 public static String arrayToString2(int[] arr) { StringBuffer sb = new StringBuffer(); sb.append(\"[\"); for (int x = 0; x /* * 把字符串反转 */ public class StringBufferTest3 { public static void main(String[] args) { // 键盘录入数据 Scanner sc = new Scanner(System.in); System.out.println(\"请输入数据：\"); String s = sc.nextLine(); // 方式1：用String做拼接 String s1 = myReverse(s); System.out.println(\"s1:\" + s1); // 方式2：用StringBuffer的reverse()功能 String s2 = myReverse2(s); System.out.println(\"s2:\" + s2); } // 用StringBuffer的reverse()功能 public static String myReverse2(String s) { // StringBuffer sb = new StringBuffer(); // sb.append(s); // StringBuffer sb = new StringBuffer(s); // sb.reverse(); // return sb.toString(); // 简易版 return new StringBuffer(s).reverse().toString(); } // 用String做拼接 public static String myReverse(String s) { String result = \"\"; char[] chs = s.toCharArray(); for (int x = chs.length - 1; x >= 0; x--) { // char ch = chs[x]; // result += ch; result += chs[x]; } return result; } } /* * 判断一个字符串是否是对称字符串 * 例如\"abc\"不是对称字符串，\"aba\"、\"abba\"、\"aaa\"、\"mnanm\"是对称字符串 * * 分析： * 判断一个字符串是否是对称的字符串，我只需要把 * 第一个和最后一个比较 * 第二个和倒数第二个比较 * ... * 比较的次数是长度除以2。 */ public class StringBufferTest4 { public static void main(String[] args) { // 创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(\"请输入一个字符串：\"); String s = sc.nextLine(); // 一个一个的比较 boolean b = isSame(s); System.out.println(\"b:\" + b); //用字符串缓冲区的反转功能 boolean b2 = isSame2(s); System.out.println(\"b2:\"+b2); } public static boolean isSame2(String s) { return new StringBuffer(s).reverse().toString().equals(s); } // public static boolean isSame(String s) { // // 把字符串转成字符数组 // char[] chs = s.toCharArray(); // // for (int start = 0, end = chs.length - 1; start 3.9正则表达式 符合一定规则的字符串。 常见规则 A:字符 x 字符 x。举例：'a'表示字符a \\\\ 反斜线字符 表示\\。 \\n 新行（换行）符 ('\\u000A') \\r 回车符 ('\\u000D') B:字符类 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） [0-9] 0到9的字符都包括 C:预定义字符类 . 任何字符。我的就是.字符本身，怎么表示呢? \\. \\d 数字：[0-9] \\w 单词字符：[a-zA-Z_0-9] 在正则表达式里面组成单词的东西必须有这些东西组成 D:边界匹配器 ^ 行的开头 $ 行的结尾 \\b 单词边界 就是不是单词字符的地方。 举例：hello world?haha;xixi E:Greedy 数量词 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 /* * 正则表达式：符合一定规则的字符串。 * 1:要求必须是5-15位数字 * 2:0不能开头 */ public class RegexDemo2 { public static void main(String[] args) { // 创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(\"请输入你的QQ号码：\"); String qq = sc.nextLine(); System.out.println(\"checkQQ:\" + checkQQ(qq)); } public static boolean checkQQ(String qq) { // String regex =\"[1-9][0-9]{4,14}\"; // //public boolean matches(String regex)告知此字符串是否匹配给定的正则表达式 // boolean flag = qq.matches(regex); // return flag; //return qq.matches(\"[1-9][0-9]{4,14}\"); return qq.matches(\"[1-9]\\\\d{4,14}\"); } } /* * 判断功能 * String类的public boolean matches(String regex) * * 需求： * 判断手机号码是否满足要求? * * 分析： * A:键盘录入手机号码 * B:定义手机号码的规则 * 13436975980 * 13688886868 * 13866668888 * 13456789012 * 13123456789 * 18912345678 * 18886867878 * 18638833883 * C:调用功能，判断即可 * D:输出结果 */ public class RegexDemo { public static void main(String[] args) { //键盘录入手机号码 Scanner sc = new Scanner(System.in); System.out.println(\"请输入你的手机号码：\"); String phone = sc.nextLine(); //定义手机号码的规则 String regex = \"1[38]\\\\d{9}\"; //调用功能，判断即可 boolean flag = phone.matches(regex); //输出结果 System.out.println(\"flag:\"+flag); } } /* * 校验邮箱 * * 分析： * A:键盘录入邮箱 * B:定义邮箱的规则 * 1517806580@qq.com * dongjie@163.com * qwe111@126.com * aaa@sina.com.cn * fqy@itcast.cn * C:调用功能，判断即可 * D:输出结果 */ public class RegexTest { public static void main(String[] args) { //键盘录入邮箱 Scanner sc = new Scanner(System.in); System.out.println(\"请输入邮箱：\"); String email = sc.nextLine(); //定义邮箱的规则 //String regex = \"[a-zA-Z_0-9]+@[a-zA-Z_0-9]{2,6}(\\\\.[a-zA-Z_0-9]{2,3})+\"; String regex = \"\\\\w+@\\\\w{2,6}(\\\\.\\\\w{2,3})+\"; //调用功能，判断即可 boolean flag = email.matches(regex); //输出结果 System.out.println(\"flag:\"+flag); } } /* * 分割功能 * String类的public String[] split(String regex) * 根据给定正则表达式的匹配拆分此字符串。 * * 举例： * 相亲网,QQ * 搜索好友 * 性别：女 * 范围：\"18-24\" * * age>=18 && age=startAge && age /* * 分割功能练习 */ public class RegexDemo2 { public static void main(String[] args) { // 定义一个字符串 String s1 = \"aa,bb,cc\"; // 直接分割 String[] str1Array = s1.split(\",\"); for (int x = 0; x /* * 我有如下一个字符串:\"91 27 46 38 50\" * 请写代码实现最终输出结果是：\"27 38 46 50 91\" * * 分析： * A:定义一个字符串 * B:把字符串进行分割，得到一个字符串数组 * C:把字符串数组变换成int数组 * D:对int数组排序 * E:把排序后的int数组在组装成一个字符串 * F:输出字符串 */ public class RegexTest { public static void main(String[] args) { // 定义一个字符串 String s = \"91 27 46 38 50\"; // 把字符串进行分割，得到一个字符串数组 String[] strArray = s.split(\" \"); // 把字符串数组变换成int数组 int[] arr = new int[strArray.length]; for (int x = 0; x /* * 替换功能 * String类的public String replaceAll(String regex,String replacement) * 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 */ public class RegexDemo { public static void main(String[] args) { // 定义一个字符串 String s = \"helloqq12345worldkh622112345678java\"; // 我要去除所有的数字,用*给替换掉 // String regex = \"\\\\d+\"; // String regex = \"\\\\d\"; //String ss = \"*\"; // 直接把数字干掉 String regex = \"\\\\d+\"; String ss = \"\"; String result = s.replaceAll(regex, ss); System.out.println(result); } } import java.util.regex.Matcher; import java.util.regex.Pattern; /* * 获取功能 * Pattern和Matcher类的使用 * * 模式和匹配器的基本使用顺序 */ public class RegexDemo { public static void main(String[] args) { // 模式和匹配器的典型调用顺序 // 1把正则表达式编译成模式对象 Pattern p = Pattern.compile(\"a*b\"); // 2通过模式对象得到匹配器对象，这个时候需要的是被匹配的字符串 Matcher m = p.matcher(\"aaaaab\"); // 调用匹配器对象的功能 boolean b = m.matches(); System.out.println(b); //这个是判断功能，但是如果做判断，这样做就有点麻烦了，我们直接用字符串的方法做 String s = \"aaaaab\"; String regex = \"a*b\"; boolean bb = s.matches(regex); System.out.println(bb); } } import java.util.regex.Matcher; import java.util.regex.Pattern; /* * 获取功能： * 获取下面这个字符串中由三个字符组成的单词 * da jia ting wo shuo,jin tian yao xia yu,bu shang wan zi xi,gao xing bu? */ public class RegexDemo2 { public static void main(String[] args) { // 定义字符串 String s = \"da jia ting wo shuo,jin tian yao xia yu,bu shang wan zi xi,gao xing bu?\"; // 规则 String regex = \"\\\\b\\\\w{3}\\\\b\"; // 把规则编译成模式对象 Pattern p = Pattern.compile(regex); // 通过模式对象得到匹配器对象 Matcher m = p.matcher(s); // 调用匹配器对象的功能 // 通过find方法就是查找有没有满足条件的子串 // public boolean find() // boolean flag = m.find(); // System.out.println(flag); // // 如何得到值呢? // // public String group() // String ss = m.group(); // System.out.println(ss); // // // 再来一次 // flag = m.find(); // System.out.println(flag); // ss = m.group(); // System.out.println(ss); while (m.find()) { System.out.println(m.group()); } // 注意：一定要先find()，然后才能group() // IllegalStateException: No match found // String ss = m.group(); // System.out.println(ss); } } 3.10Date类和DateFormat类 Date是日期类，可以精确到毫秒。 DateFormat是针对日期进行格式化和针对字符串进行解析的类。是抽象类，使用其子类SimpleDateFormat。 /* * Date:表示特定的瞬间，精确到毫秒。 * * 构造方法： * Date():根据当前的默认毫秒值创建日期对象 * Date(long date)：根据给定的毫秒值创建日期对象 */ public class DateDemo { public static void main(String[] args) { // 创建对象 Date d = new Date(); System.out.println(\"d:\" + d); // 创建对象 // long time = System.currentTimeMillis(); long time = 1000 * 60 * 60; // 1小时 Date d2 = new Date(time); System.out.println(\"d2:\" + d2); } } import java.util.Date; /* * public long getTime():获取时间，以毫秒为单位 * public void setTime(long time):设置时间 * * 从Date得到一个毫秒值 * getTime() * 把一个毫秒值转换为Date * 构造方法 * setTime(long time) */ public class DateDemo { public static void main(String[] args) { // 创建对象 Date d = new Date(); // 获取时间 long time = d.getTime(); System.out.println(time); // System.out.println(System.currentTimeMillis()); System.out.println(\"d:\" + d); // 设置时间 d.setTime(1000); System.out.println(\"d:\" + d); } } import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; /* * Date -- String(格式化) * public final String format(Date date) * * String -- Date(解析) * public Date parse(String source) * * DateForamt:可以进行日期和字符串的格式化和解析，但是由于是抽象类，所以使用具体子类SimpleDateFormat。 * * SimpleDateFormat的构造方法： * SimpleDateFormat():默认模式 * SimpleDateFormat(String pattern):给定的模式 * 这个模式字符串该如何写呢? * 通过查看API，我们就找到了对应的模式 * 年 y * 月 M * 日 d * 时 H * 分 m * 秒 s * * 2018年9月12日 12:12:12 */ public class DateFormatDemo { public static void main(String[] args) throws ParseException { // Date -- String // 创建日期对象 Date d = new Date(); // 创建格式化对象 // SimpleDateFormat sdf = new SimpleDateFormat(); // 给定模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); // public final String format(Date date) String s = sdf.format(d); System.out.println(s); //String -- Date String str = \"2008-08-08 12:12:12\"; //在把一个字符串解析为日期的时候，请注意格式必须和给定的字符串格式匹配 SimpleDateFormat sdf2 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Date dd = sdf2.parse(str); System.out.println(dd); } } import java.text.ParseException; import java.util.Date; /* * 工具类的测试 */ public class DateUtilDemo { public static void main(String[] args) throws ParseException { Date d = new Date(); // yyyy-MM-dd HH:mm:ss String s = DateUtil.dateToString(d, \"yyyy年MM月dd日 HH:mm:ss\"); System.out.println(s); String s2 = DateUtil.dateToString(d, \"yyyy年MM月dd日\"); System.out.println(s2); String s3 = DateUtil.dateToString(d, \"HH:mm:ss\"); System.out.println(s3); String str = \"2014-10-14\"; Date dd = DateUtil.stringToDate(str, \"yyyy-MM-dd\"); System.out.println(dd); } } import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; /** * 这是日期和字符串相互转换的工具类 * */ public class DateUtil { private DateUtil() { } /** * 这个方法的作用就是把日期转成一个字符串 * * @param d * 被转换的日期对象 * @param format * 传递过来的要被转换的格式 * @return 格式化后的字符串 */ public static String dateToString(Date d, String format) { // SimpleDateFormat sdf = new SimpleDateFormat(format); // return sdf.format(d); return new SimpleDateFormat(format).format(d); } /** * 这个方法的作用就是把一个字符串解析成一个日期对象 * * @param s * 被解析的字符串 * @param format * 传递过来的要被转换的格式 * @return 解析后的日期对象 * @throws ParseException */ public static Date stringToDate(String s, String format) throws ParseException { return new SimpleDateFormat(format).parse(s); } } import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Scanner; /* * 算一下你来到这个世界多少天? * * 分析： * A:键盘录入你的出生的年月日 * B:把该字符串转换为一个日期 * C:通过该日期得到一个毫秒值 * D:获取当前时间的毫秒值 * E:用D-C得到一个毫秒值 * F:把E的毫秒值转换为年 * /1000/60/60/24 */ public class MyYearOldDemo { public static void main(String[] args) throws ParseException { // 键盘录入你的出生的年月日 Scanner sc = new Scanner(System.in); System.out.println(\"请输入你的出生年月日:\"); String line = sc.nextLine(); // 把该字符串转换为一个日期 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); Date d = sdf.parse(line); // 通过该日期得到一个毫秒值 long myTime = d.getTime(); // 获取当前时间的毫秒值 long nowTime = System.currentTimeMillis(); // 用D-C得到一个毫秒值 long time = nowTime - myTime; // 把E的毫秒值转换为年 long day = time / 1000 / 60 / 60 / 24; System.out.println(\"你来到这个世界：\" + day + \"天\"); } } import java.text.SimpleDateFormat; import java.util.Date; public class Test { public static void main(String[] args) { Date date = new Date(); //创建日期对象 SimpleDateFormat formater = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//定制日期格式 System.out.println(\"当前时间为：\"+formater.format(date)); } } 3.11Calendar类 日历类，封装所有的日历字段值，通过统一的方法，根据传入不同的日历字段取到值。 import java.util.Calendar; /* * Calendar:它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。 * * public int get(int field):返回给定日历字段的值。日历类中的每个日历字段都是静态的成员变量，并且是int类型。 */ public class Test { public static void main(String[] args) { Calendar t = Calendar.getInstance(); System.out.println(\"今天是\"+t.get(Calendar.YEAR)+\"年\" +(t.get(Calendar.MONTH)+1)+\"月\"+t.get(Calendar.DAY_OF_MONTH)+\"日\"); //Calendar.DAY_OF_WEEK 中 Sunday是1 System.out.println(\"今天是星期\"+(t.get(Calendar.DAY_OF_WEEK)-1)); } } import java.util.Calendar; /* * public void add(int field,int amount):根据给定的日历字段和对应的时间，来对当前的日历进行操作。 * public final void set(int year,int month,int date):设置当前日历的年月日 */ public class CalendarDemo { public static void main(String[] args) { // 获取当前的日历时间 Calendar c = Calendar.getInstance(); // 获取年 int year = c.get(Calendar.YEAR); // 获取月 int month = c.get(Calendar.MONTH); // 获取日 int date = c.get(Calendar.DATE); System.out.println(year + \"年\" + (month + 1) + \"月\" + date + \"日\"); // // 三年前的今天 // c.add(Calendar.YEAR, -3); // // 获取年 // year = c.get(Calendar.YEAR); // // 获取月 // month = c.get(Calendar.MONTH); // // 获取日 // date = c.get(Calendar.DATE); // System.out.println(year + \"年\" + (month + 1) + \"月\" + date + \"日\"); // 5年后的10天前 c.add(Calendar.YEAR, 5); c.add(Calendar.DATE, -10); // 获取年 year = c.get(Calendar.YEAR); // 获取月 month = c.get(Calendar.MONTH); // 获取日 date = c.get(Calendar.DATE); System.out.println(year + \"年\" + (month + 1) + \"月\" + date + \"日\"); System.out.println(\"--------------\"); c.set(2011, 11, 11); // 获取年 year = c.get(Calendar.YEAR); // 获取月 month = c.get(Calendar.MONTH); // 获取日 date = c.get(Calendar.DATE); System.out.println(year + \"年\" + (month + 1) + \"月\" + date + \"日\"); } } import java.util.Calendar; import java.util.Scanner; /* * 获取任意一年的二月有多少天 * * 分析： * A:键盘录入任意的年份 * B:设置日历对象的年月日 * 年就是A输入的数据 * 月是2 * 日是1 * C:把时间往前推一天，就是2月的最后一天 * D:获取这一天输出即可 */ public class CalendarTest { public static void main(String[] args) { // 键盘录入任意的年份 Scanner sc = new Scanner(System.in); System.out.println(\"请输入年份：\"); int year = sc.nextInt(); // 设置日历对象的年月日 Calendar c = Calendar.getInstance(); c.set(year, 2, 1); // 其实是这一年的3月1日 // 把时间往前推一天，就是2月的最后一天 c.add(Calendar.DATE, -1); // 获取这一天输出即可 System.out.println(c.get(Calendar.DATE)); } } 练习 1、如何使用Date和Calendar类处理日期？ import java.text.SimpleDateFormat; import java.util.Date; import java.util.Calendar; public class Test { public static void main(String[] args) { Date date = new Date(); //创建日期对象 SimpleDateFormat formater = new SimpleDateFormat(\"yyyy-MM-dd\");//定制日期格式 System.out.println(\"当前日期为：\"+formater.format(date)); Calendar cal=Calendar.getInstance(); cal.set(Calendar.YEAR, 2015); cal.set(Calendar.MONTH, 4); cal.set(Calendar.DAY_OF_MONTH, 6); int week=cal.get(Calendar.WEEK_OF_YEAR); System.out.println(\"2015年4月6日是一年中的第\"+week+\"星期。\"); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/utility-class/utility-class.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 16:51:06 "},"stream/stream.html":{"url":"stream/stream.html","title":"流处理","keywords":"","body":"4-流的处理 4.1File类 相关记录或放在一起的数据的集合。File类访问文件属性。 常用方法 方法名称 说明 boolean exists() 判断文件或目录是否存在 boolean isFile() 判断是否是文件 boolean isDirectory() 判断是否是目录 String getPath() 返回对象文件的相对路径 String getAbsolutePath() 返回对象文件的绝对路径 String getName() 返回对象表示文件或者目录的名称 boolean delete() 删除对象表示的文件或者目录 boolean createNewFile() 创建空文件，不创建文件夹 long length() 返回文件的长度，单位是字节。若文件不存在，则返回为0L //对文件的增删查操作 import java.io.*; public class FileMethods { public static void main(String[] args) { FileMethods fm=new FileMethods(); File file=new File(\"D:\\\\myDoc\\\\test.txt\"); //fm.create(file); fm.showFileInfo(file); //fm.delete(file); } /** * 创建文件的方法 * @param file 文件对象 */ public void create(File file){ if(!file.exists()){ try { file.createNewFile(); System.out.println(\"文件已创建！\"); } catch (IOException e) { e.printStackTrace(); } } } /** * 删除文件 * @param file 文件对象 */ public void delete(File file){ if(file.exists()){ file.delete(); System.out.println(\"文件已删除！\"); } } /** * 显示文件信息 * @param file 文件对象 */ public void showFileInfo(File file){ if(file.exists()){ //判断文件是否存在 if(file.isFile()){ //如果是文件 System.out.println(\"名称:\" + file .getName()); System.out.println(\"相对路径: \" + file.getPath()); System.out.println(\"绝对路径: \" + file.getAbsolutePath()); System.out.println(\"文件大小:\" + file.length()+ \" 字节\"); } if(file.isDirectory()){ System.out.println(\"此文件是目录\"); } }else System.out.println(\"文件不存在\"); } } 4.2IO流 通过流读写文件。 流是一组有序的数据序列。 以先进先出方式发送信息的通道。 数据源、流和程序三者的关系 Java流的分类 按照流向区分 ​ 输入流 InputStream\\ Reader ​ 输出流 OutputStream\\ Writer 按照处理数据单位区分 ​ 字节流 InputStream/ OutputStream ​ 字符流 Reader/ Writer FileInputStream import java.io.*; public class FileInputStreamTest { public static void main(String[] args){ FileInputStream fis=null; //创建流对象 try { fis=new FileInputStream(\"d:\\\\myDoc\\\\hello.txt\"); int data; System.out.println(\"可读取的字节数：\"+fis.available()); System.out.print(\"文件内容为：\"); //循环读数据 read()方法是从输入流读取1个8位的字节，把它转化为0-255之间的整数返回。将返回的整数转换为字符 while((data=fis.read())!=-1){ System.out.print((char)data); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally{ try { //关闭流对象 fis.close(); } catch (IOException e) { e.printStackTrace(); } } } } FileOutputStream import java.io.*; public class FileOutputStreamTest { public static void main(String[] args){ FileOutputStream fos=null; try { fos=new FileOutputStream(\"d:\\\\myDoc\\\\hello.txt\",true); String str=\"好好学习Java\"; byte[] words=str.getBytes(); fos.write(words,0,words.length); System.out.println(\"hello文件已更新\"); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { System.out.println(\"文件更新时出错！\"); e.printStackTrace(); }finally{ try { if(fos!=null){ fos.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 使用FileReader读取文本文件 import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; import java.io.Reader; public class FileReaderTest { /** * 使用FileReader读取文本文件 */ public static void main(String[] args) { //创建 FileReader对象 Reader fr=null; StringBuffer sbf=null; try { fr = new FileReader(\"C:\\\\myDoc\\\\简介.txt\"); char ch[]=new char[1024]; //创建字符数组作为中转站 sbf=new StringBuffer(); int length=-1; //将字符读入数组,循环读取并追加字符 while ((length=fr.read(ch))!= -1) { sbf.append(ch); //追加到字符串 } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally{ try { if(fr!=null) fr.close(); } catch (IOException e) { e.printStackTrace(); } } System.out.println(sbf.toString()); } } 使用BufferedReader和FileReader读取文本文件 import java.io.*; public class BufferedReaderTest { /** * @param args */ public static void main(String[] args) { FileReader fr=null; BufferedReader br=null; try { //创建一个FileReader对象 fr=new FileReader(\"C:\\\\myDoc\\\\hello.txt\"); //创建一个BufferedReader 对象 br=new BufferedReader(fr); //读取一行数据 String line=null; while((line=br.readLine())!=null){ System.out.println(line); } }catch(IOException e){ System.out.println(\"文件不存在!\"); }finally{ try { //关闭 流 if(br!=null) br.close(); if(fr!=null) fr.close(); } catch (IOException e) { e.printStackTrace(); } } } } 解决中文乱码 import java.io.*; /* * 当hello.txt编码格式是ANSI时，程序可以正常读取数据，（InputStreamReader fr=new InputStreamReader(fis,\"gbk\"); ）； * 当hello.txt编码格式改为UTF-8时，代码改为InputStreamReader fr=new InputStreamReader(fis,\"UTF-8\"); 时才可以正常读取数据。 * */ public class BufferedReaderTest { public static void main(String[] args) { InputStreamReader fr = null; BufferedReader br = null; try { FileInputStream fis = new FileInputStream(\"c:\\\\myDoc\\\\hello.txt\"); // 指定编码格式 fr = new InputStreamReader(fis, \"utf-8\"); br = new BufferedReader(fr); String line = null; while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException e) { try { br.close(); fr.close(); } catch (IOException e1) { // TODO Auto-generated catch block e1.printStackTrace(); } System.out.println(e.getMessage()); } } } 使用FileWriter类向文本文件写数据 import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; import java.io.Writer; public class FileWriterTest { /** * 使用FileWriter类向文本文件写数据 */ public static void main(String[] args) { Writer fw=null; try { //创建一个FileWriter对象 fw=new FileWriter(\"C:\\\\myDoc\\\\简介.txt\"); //fw=new FileWriter(\"C:\\\\myDoc\\\\简介.txt\",true); //写入信息 fw.write(\"我热爱编程！\"); fw.flush(); //刷新缓冲区 }catch(IOException e){ System.out.println(\"文件不存在!\"); }finally{ try { if(fw!=null) fw.close(); //关闭流 } catch (IOException e) { e.printStackTrace(); } } } } 使用FileWriter类和BufferedWriter类写文本文件 import java.io.*; public class BufferedWriterTest { public static void main(String[] args) { FileWriter fw=null; BufferedWriter bw=null; FileReader fr=null; BufferedReader br=null; try { //创建一个FileWriter 对象 fw=new FileWriter(\"C:\\\\myDoc\\\\hello.txt\"); //创建一个BufferedWriter 对象 bw=new BufferedWriter(fw); bw.write(\"大家好！\"); bw.write(\"我正在学习BufferedWriter。\"); bw.newLine(); bw.write(\"请多多指教！\"); bw.newLine(); bw.flush(); //读取文件内容 fr=new FileReader(\"C:\\\\myDoc\\\\hello.txt\"); br=new BufferedReader(fr); String line=null; while((line=br.readLine())!=null){ System.out.println(line); } fr.close(); }catch(IOException e){ System.out.println(\"文件不存在!\"); }finally{ try{ if(fw!=null) fw.close(); if(br!=null) br.close(); if(fr!=null) fr.close(); }catch(IOException ex){ ex.printStackTrace(); } } } } 二进制文件的读写 import java.io.*; //二进制文件的读写 public class ReadAndWriteBinaryFile { public static void main(String[] args){ DataInputStream dis=null; DataOutputStream dos=null; FileInputStream fis=null; FileOutputStream fos=null; try { //创建输入流对象 fis=new FileInputStream(\"c:\\\\myDoc\\\\star.jpg\"); dis=new DataInputStream(fis); //创建输出流对象 fos=new FileOutputStream(\"c:\\\\myDoc\\\\new.jpg\"); dos=new DataOutputStream(fos); //读取文件并写入文件 int temp; while((temp=dis.read())!=-1){ dos.write(temp); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally{ try { if(dis!=null){ dis.close(); } if(dos!=null){ dos.close(); } if(fis!=null){ fis.close(); } if(fos!=null){ fos.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 使用序列化和反序列化 public class Student implements java.io.Serializable { private String name; private int age; private String gender; private transient String password; public Student(String name, int age,String gender){ this.name=name; this.age=age; this.gender=gender; } public Student(String name, int age,String gender,String password){ this.name=name; this.age=age; this.gender=gender; this.password=password; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } import java.io.*; public class SerializableObj { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectOutputStream oos = null; ObjectInputStream ois=null; try { // 创建ObjectOutputStream输出流 oos = new ObjectOutputStream(new FileOutputStream( \"c:\\\\myDoc\\\\stu.txt\")); Student stu = new Student(\"James Gosphy\", 30, \"女\",\"aaaa\"); System.out.println(\"姓名为：\"+stu.getName()); System.out.println(\"年龄为：\"+stu.getAge()); System.out.println(\"性别为：\"+stu.getGender()); System.out.println(\"密码为：\"+stu.getPassword()); // 对象序列化，写入输出流 oos.writeObject(stu); //创建ObjectInputStream输入流 ois=new ObjectInputStream(new FileInputStream(\"c:\\\\myDoc\\\\stu.txt\")); //反序列化，强转类型 Student stu1=(Student)ois.readObject(); //输出生成后对象信息 System.out.println(\"姓名为：\"+stu1.getName()); System.out.println(\"年龄为：\"+stu1.getAge()); System.out.println(\"性别为：\"+stu1.getGender()); System.out.println(\"密码为：\"+stu1.getPassword()); } catch (IOException ex) { ex.printStackTrace(); } finally { try { if (oos != null) { oos.close(); } if (ois != null) { ois.close(); } }catch (IOException ex) { ex.printStackTrace(); } } } } 练习 1、使用FileInputStream和FileOutputStream实现文件的复制？ import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; public class InputAndOutputFile { public static void main(String[] args) { FileInputStream fis=null; FileOutputStream fos=null; try { //1、创建输入流对,负责读取D:/ a.txt文件 fis = new FileInputStream(\"D:/a.txt\"); //2、创建输出流对象 fos = new FileOutputStream(\"C:/myFile/a1.txt\",true); //3、创建中转站数组,存放每次读取的内容 byte[] words=new byte[1024]; //4、通过循环实现文件读取 int len = -1; while((len = fis.read(words))!=-1){ fos.write(words, 0, len); } fos.flush(); System.out.println(\"复制完成，请查看文件！\"); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally{ //5、关闭流 try { if(fos!=null) fos.close(); if(fis!=null) fis.close(); } catch (IOException e) { e.printStackTrace(); } } } } 2、如何替换文本文件内容？ import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; import java.io.InputStreamReader; import java.nio.charset.Charset; import org.omg.CORBA.Environment; public class ReaderAndWriterFile { public void replaceFile(String file1,String file2) { BufferedReader reader = null; BufferedWriter writer = null; try { //创建 FileReader对象和FileWriter对象. //中文内容编码问题 //FileReader fr = new FileReader(file1); FileInputStream fis=new FileInputStream(file1); InputStreamReader isr=new InputStreamReader(fis,\"utf-8\"); FileWriter fw = new FileWriter(file2); //创建 输入、输入出流对象. reader = new BufferedReader(isr); writer = new BufferedWriter(fw); String line = null; StringBuffer sbf=new StringBuffer(); //循环读取并追加字符 while ((line = reader.readLine()) != null) { sbf.append(line); } System.out.println(\"替换前：\"+sbf); /*替换内容*/ String newString=sbf.toString().replace(\"{name}\", \"欧欧\"); newString = newString.replace(\"{type}\", \"狗狗\"); newString = newString.replace(\"{master}\", \"李伟\"); System.out.println(\"替换后：\"+newString); writer.write(newString); //写入文件 } catch (IOException e) { e.printStackTrace(); }finally{ //关闭 reader 和 writer. try { if(reader!=null) reader.close(); if(writer!=null) writer.close(); } catch (IOException e) { e.printStackTrace(); } } } public static void main(String[] args) { ReaderAndWriterFile obj = new ReaderAndWriterFile(); obj.replaceFile(\"c:\\\\pet.template\", \"C:\\\\myDoc\\\\pet.txt\"); System.out.println(Charset.defaultCharset()); } } 3、如何复制图片？ import java.io.*; //二进制文件的读写 public class ReadAndWriteBinaryFile { public static void main(String[] args){ DataInputStream dis=null; DataOutputStream dos=null; FileInputStream fis=null; FileOutputStream fos=null; try { //创建输入流对象 fis=new FileInputStream(\"c:\\\\myDoc\\\\star.jpg\"); dis=new DataInputStream(fis); //创建输出流对象 fos=new FileOutputStream(\"c:\\\\myDoc\\\\new.jpg\"); dos=new DataOutputStream(fos); //读取文件并写入文件 int temp; while((temp=dis.read())!=-1){ dos.write(temp); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally{ try { if(dis!=null){ dis.close(); } if(dos!=null){ dos.close(); } if(fis!=null){ fis.close(); } if(fos!=null){ fos.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 4、如何对学生对象进行序列化和反序列化？ 答案见上述 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/stream/stream.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 16:52:24 "},"multithreading/multithreading.html":{"url":"multithreading/multithreading.html","title":"多线程","keywords":"","body":"5-多线程 5.1程序、进程、线程 进程是指运行中的程序。进程的特点：动态性、独立性、并发性。 线程是进程内部的一个执行单元，它是程序中一个单一的顺序控制流程。 多线程是在一个进程中同时运行多个线程，用于完成不同的工作。比如迅雷软件同时现在不同的文件资源。 5.2线程与进程的区别 区别 进程 线程 根本区别 作为资源分配的单位 调度和执行的单位 开销 每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销。 线程可以看成是轻量级的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器（PC），线程切换的开销小。 所处环境 在操作系统中能同时运行多个任务（程序） 在同一应用程序中有多个顺序流同时执行 分配内存 系统在运行时会为每个进程分配不同的内存区域 除了CPU之外，不会为线程分配内存（线程所使用的资源时它所属的进程的资源），线程组只能共享资源 包含关系 没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的。 线程是进程的一部分，所以线程有的时候被称为是轻量级进程。 主线程 main()方法即为主线程入口。 产生其他子线程的线程。 必须最后完成执行，因为它执行各种关闭动作。 5.3线程的创建与启动 Thread类的常用方法 方法 功能 static Thread currentThread() 得到当前线程 getName() 返回线程的名称 setName(String name) 指定线程的名称 int getPriority() 获得线程的优先级数值 void setPriority() 设置线程的优先级 void start() 调用run()方法启动线程，开始线程的执行 void run() 存放线程体代码 isAlive() 判断线程是否活着 显示主线程名 public class ThreadDemo { public static void main(String args[]) { Thread t= Thread.currentThread(); System.out.println(\"当前线程是: \"+t.getName()); t.setName(\"MyJavaThread\"); System.out.println(\"当前线程名是: \"+t.getName()); } } 继承Thread类创建线程 public class MyThread extends Thread{ //重写run()方法 public void run(){ for(int i=1;i public class Test { public static void main(String[] args) { MyThread thread = new MyThread(); thread.start(); //启动线程 } } 多线程交替执行 public class MyThread extends Thread{ //重写run()方法 public void run(){ for(int i=1;i public class Test { public static void main(String[] args) { MyThread thread = new MyThread(); MyThread thread2 = new MyThread(); //创建新线程thread2 thread.start(); thread2.start(); //启动thread2 } } 直接调用run()和start()区别 public class MyThread extends Thread{ //重写run()方法 public void run(){ for(int i=1;i public class Test { public static void main(String[] args) { MyThread thread = new MyThread(); MyThread thread2 = new MyThread(); //直接调用run()方法 thread.run(); thread2.run(); } } 实现Runable接口创建线程 class MyRunnable implements Runnable{ //实现run()方法 public void run(){ for(int i=1;i public class Test { public static void main(String[] args) { MyRunnable myRunnable = new MyRunnable(); Thread myThread = new Thread(myRunnable); myThread.start(); } } 5.4线程的生命周期 新生状态 用new关键字建立一个线程对象后，该线程对象就处于新生状态。 处于新生状态的线程有自己的内存空间，通过调用start进入就绪状态。 就绪状态 处于就绪状态线程具备了运行条件，但还没分配到CPU，处于线程就绪队列，等待系统为其分配CPU。 当系统选定一个等待执行的线程后，它就会从就绪状态进入执行状态，该动作称之为“cpu调度”。 运行状态 在运行状态的线程执行自己的run方法中代码，直到等待某资源而阻塞或者完成任务而死亡。 如果在给定时间片内没有执行结束，就会被系统给换下来回到等待执行状态。 阻塞状态 处于运行状态的线程在某些情况下，如果执行了sleep（）方法，或者等待的I/O设备等资源，将让出CPU，并暂停停止自己的运行，进入阻塞状态。 在阻塞状态的线程不能进入就绪队列，只有当引起阻塞的原因消除时，（比如睡眠时间已到，或等待的I/O设备空闲下来），线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。 死亡状态 死亡状态是线程生命周期中的最后一个阶段。线程死亡原因有三个： 一是正常运行的线程完成了它的全部工作； 二是线程被强制性的终止； 三是线程抛出未捕获的异常； 描述线程的状态 /** * 描述线程的状态 */ public class Mythread implements Runnable{ public void run() { try { System.out.println(\"线程t在运行！\"); Thread.sleep(500); System.out.println(\"线程t在短时间睡眠后重新运行！\"); } catch (InterruptedException IE) { System.out.println(\"线程被中断\"); } } public static void main(String args[]) { Thread t=new Thread(new Mythread()); System.out.println (\"线程 t 为新建！\"); t.start(); System.out.println (\"线程 t 为就绪！\"); } } 5.5线程调度 线程调度指按照特定机制为多个线程分配CPU的使用权。 方法 说明 void setPriority(int newPriority) 设置线程的优先级,由1-10表示，默认优先级为5。优先级越高，获得CPU资源的概率越大。 static void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程休眠，进入阻塞状态，不会释放CPU执行权。 void join() 阻塞指定线程等到另一个线程完成以后再继续执行。好比强行“插队”。 static void yield() 暂停当前正在执行的线程对象，转入就绪状态，再次公平竞争CPU资源。 线程的优先级 /** * 设置线程优先级 * */ public class MyThread implements Runnable{ public void run(){ for(int i=1;i 线程的休眠 /** * 线程休眠 */ public class ThreadSleepDemo { public static void main(String[] args) { System.out.println(\"Wait\"); Wait.bySec(5); // 让主线程等待5秒种再执行 System.out.println(\"start\"); } } class Wait { public static void bySec(long s) { for (int i = 0; i 线程的强制执行 public class MyThread implements Runnable{ public void run(){ for(int i=0;i /** * 线程强制执行 */ public class ThreadJoinDemo { public static void main(String[] args) { System.out.println(\"*****线程强制执行******\"); //创建子线程并启动 Thread temp = new Thread(new MyThread()); temp.start(); for(int i=0;i 线程的礼让 public class MyThread implements Runnable{ public void run(){ for(int i=0;i public class ThreadYieldDemo { public static void main(String[] args) { System.out.println(\"*****线程的礼让*****\"); MyThread my = new MyThread(); Thread t1 = new Thread(my,\"线程A\"); Thread t2 = new Thread(my,\"线程B\"); t1.start(); t2.start(); } } 5.6线程同步 使用synchronized修饰的方法控制对类成员变量的访问。 线程同步的好处 解决线程安全问题 线程同步的缺点 性能下降 会带来死锁 死锁 当两个线程相互等待对方释放“锁”时就会发生死锁。 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。 多线程编程时，应该注意避免死锁发生。 多线程共享数据引发的问题 /** * 线程不安全的网络抢票 * */ public class Site implements Runnable{ private int count=10; //记录剩余票数 private int num = 0; //记录买到第几张票 public void run(){ while(true){ //没有余票时，跳出循环 if(count public class Test { public static void main(String[] args) { Site site = new Site(); Thread person1= new Thread(site,\"桃跑跑\"); Thread person2= new Thread(site,\"抢票代理\"); Thread person3= new Thread(site,\"黄牛党\"); System.out.println(\"********开始抢票********\"); person1.start(); person2.start(); person3.start(); } } 同步方法解决共享数据并发 /** * 模拟网络延时线程不安全 * */ public class Site implements Runnable{ private int count=10; //记录剩余票数 private int num = 0; //记录买到第几张票 public void run(){ while(true){ if(count public class Test { public static void main(String[] args) { Site site = new Site(); Thread person1= new Thread(site,\"桃跑跑\"); Thread person2= new Thread(site,\"抢票代理\"); Thread person3= new Thread(site,\"黄牛党\"); System.out.println(\"********开始抢票********\"); person1.start(); person2.start(); person3.start(); } } 同步代码块解决共享数据并发 /** * 同步后的网络购票 */ public class Site implements Runnable { private int count = 10; // 记录剩余票数 private int num = 0; // 记录买到第几张票 public void run() { while (true) { //同步代码块 synchronized (this) { // 没有余票时，跳出循环 if (count public class Test { public static void main(String[] args) { Site site = new Site(); Thread person1= new Thread(site,\"桃跑跑\"); Thread person2= new Thread(site,\"抢票代理\"); Thread person3= new Thread(site,\"黄牛党\"); System.out.println(\"********开始抢票********\"); person1.start(); person2.start(); person3.start(); } } 多个线程并发访问同一资源的同步代码块时： 同一时刻只能有一个线程进入synchronized(this)同步代码块。 当一个线程访问一个sychronized(this)同步代码块时，其他synchronized（this）同步代码块同样被锁定。 当一个线程访问一个synchronized（this）同步代码块时，其他线程可以访问该资源的非synchronized（this）同步代码块。 练习 1、使用继承Thread类方式创建线程？ public class Test { public static void main(String[] args) { //创建线程对象 Mythread thread1 = new Mythread(); Mythread thread2 = new Mythread(); //启动线程 thread2.start(); thread1.start(); } } //使用继承Thread类的方式创建线程 class Mythread extends Thread{ public void run(){ for(int i=1;i 2、使用实现Runnable接口的方式创建线程？ public class Test { public static void main(String[] args) { //创建线程对象 Thread thread1 = new Thread(new Mythread()); Thread thread2 = new Thread(new Mythread()); //启动线程 thread2.start(); thread1.start(); } } //使用实现Runnable接口的方式创建线程 class Mythread implements Runnable{ public void run(){ for(int i=1;i 3、模拟多人爬山？ public class ClimbThread extends Thread { private int time; // 爬100米的时间 public int num = 0; // 爬多少个100米 public ClimbThread(String name, int time, int kilometer) { super(name); this.time = time; this.num = kilometer * 1000 / 100; } public void run() { while (num > 0) { try { Thread.sleep(this.time); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"爬完100米！\"); num--; } System.out.println(Thread.currentThread().getName()+\"到达终点！\"); } } /** * 模拟多人爬山 */ public class Test { public static void main(String[] args) { ClimbThread youngMan = new ClimbThread(\"年轻人\",500,1); ClimbThread oldMan = new ClimbThread(\"老年人\",1500,1); System.out.println(\"********开始爬山*********\"); youngMan.start(); oldMan.start(); } } 4、线程的优先级？ public class ThreadPriorityDemo { public static void main(String[] args) { Thread mainThread = Thread.currentThread(); //获取主线程 Thread myThread = new Thread(new MyThread()); //创建子线程 System.out.println(\"*******显示默认优先级*******\"); System.out.println(\"主线程名：\"+mainThread.getName()+\",优先级：\"+mainThread.getPriority()); System.out.println(\"子线程名：\"+myThread.getName()+\",优先级：\"+myThread.getPriority()); System.out.println(\"*******修改默认优先级后*******\"); mainThread.setPriority(Thread.MAX_PRIORITY); //修改主线程默认优先级 myThread.setPriority(Thread.MIN_PRIORITY); //修改子线程默认优先级 System.out.println(\"主线程名：\"+mainThread.getName()+\",优先级：\"+mainThread.getPriority()); System.out.println(\"子线程名：\"+myThread.getName()+\",优先级：\"+myThread.getPriority()); } } class MyThread implements Runnable { public void run() { } } 5、模拟叫号看病？ /** * 治病 */ public class CureThread implements Runnable { public void run() { for (int i = 0; i public class Test { public static void main(String[] args) { Thread thread = new Thread(new CureThread()); thread.setPriority(Thread.MAX_PRIORITY); thread.start(); //主线程模拟医院叫号 for(int i=0;i 6、模拟接力赛跑？ public class RunThread implements Runnable { private int meters = 1000; //共1000米 public void run() { while (true) { //同步代码块 synchronized (this) { if(meters /** * 跑步线程类 */ public class RunThread implements Runnable { private int meters = 1000; //共跑1000米 public void run() { while (true) { if(meters 7、网络购票？ /** * 模拟网络延时线程不安全 */ public class Site implements Runnable { private int count = 10; // 记录剩余票数 private int num = 0; // 记录买到第几张票 private boolean flag = false; //记录是否售完 public void run() { while (true) { if(!sale()){ break; } } } // 同步方法：卖票 public synchronized boolean sale() { if (count 5.7Lock与synchronized的比较 Lock锁 JDK1.5后新增功能，与采用synchronized相比，Lock可提供多种锁方案，更灵活。 java.util.concurrent.lock中的lock框架是锁定的一个抽象，它允许把锁定的实现作为Java类，而不是作为语言的特性来实现。这就为Lock的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。 ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了再激烈竞争下的更佳的性能。 注意：如果同步代码有异常，要将unlock()写入finally语句块。 Lock和synchronized的区别 Lock是显式锁（手动开启和关闭锁，勿忘关闭锁），synchronized式隐式锁。 Lock只有代码块锁，synchronized有代码块锁和方法锁。 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） 优先使用顺序 Lock ---同步代码块（已经进入方法体，分配响应资源） ----同步方法（再方法体之外） 5.8Hashtable和HashMap Hashtable 实现了Map接口，继承了Dictionary类。 线程安全，效率较低。 键和值都不允许为null。 HashMap 实现了Map接口，继承AbstractMap类。 非线程安全，效率高。 键和值都允许null。 5.9StringBuffer和StringBuilder 前者线程安全、后者线程不安全。 5.10线程通信 5.10.1生产者与消费者 分析 这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖、相互条件。 对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后，又需要马上通知消费者消费。 对于消费者，在消费之后，要通知生产者已经消费结束，需要继续生产新产品以供消费。 在生产者消费者问题中，仅有synchronized是不够的 synchronized可以阻止同时访问共享资源，实现线程同步。 synchronized不能用来实现不同线程之间的消息传递（通讯）。 解决方案1（管程法） 生产者：负责生产数据的模块（方法、对象、线程、进程）。 消费者：负责处理数据的模块（方法、对象、线程、进程）。 缓冲区：消费者不能直接使用生产者的数据，它们之间有个“缓冲区”。 生产者将生产好的数据放入“缓冲区”,消费者从“缓冲区”拿要处理的数据。 解决方案2（信号灯法） Java提供了3个方法解决线程之间的通信问题。它们均是java.lang.Object类的方法。都只能在同步方法或者同步代码块中使用，否则会抛出异常。 方法名 作用 final void wait() 表示线程一直等待，直到其它线程通知。 void wait(long timeout) 线程等待指定毫秒参数的时间。 final void wait(long timeout,int nanos) 线程等待指定毫秒、微秒的时间。 final void notify() 唤醒一个处于等待状态的线程。 final void notifyAll() 6.2唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先运行。 5.10.2线程通信下的线程生命周期 5.10.3线程组 线程组表示一个线程的集合。 线程组也可以包含其他线程组。线程组构成一颗树。在树中，除了初始线程组外，每个线程组都有一个父线程组。 顶级线程组system，线程的默认线程组名称是main。 在创建初，线程被限制到一个组里，而且不能改变到一个不同的组。 作用1：统一管理，便于都一组线程进行批量管理线程或线程组对象。 作用2：允许线程访问有关自己的线程组的信息，但是不允许它访问有关器线程组的父线程组或其他任何线程组的信息。 5.10.4线程池 创建和销毁对象是非常耗时的。 创建对象：需要分配内存等资源。 销毁对象：虽然不需要程序员操心，但是垃圾回收器会在后台一直跟踪并销毁。 对于经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 解决方法：创建好多个线程，放入线程池中，使用时直接获取引用，不使用时放回池中。可以避免频繁创建销毁、实现重复利用。 好处1：提高响应速度（减少创建新线程的时间）。 好处2：降低资源消耗（重复利用线程池中线程，不需要每次都创建）。 好处3：提高线程的可管理性，避免线程无限制创建，从而销毁系统资源，降低系统稳定性，甚至内存溢出或者CPU耗尽。 Executor： 线程池顶级接口，只有一个方法 ExecutorService：真正的线程池接口 void execute(Runnable command):执行任务/命令，没有返回值，一般用来执行Runnable Futuresubmit(Callable task): 执行任务，有返回值，一般用来执行Callable void shutdown(): 关闭连接池 AbstractExecutorService: 基本实现了ExecutorService的所有方法 ThreadPoolExecutor : 默认的线程池实现类 ScheluledThreadPoolExcutor : 实现周期性任务调度的线程池 Executors : 工具类、线程池的工厂类，用于创建并返回不同类型的线程池 Executors.newCachedThreadPool() : 创建一个 可根据需要创建新线程的线程池 Executors.newFixedThreadPool(n): 创建一个可重用固定线程数的线程池 Executors.newSingleThreadExecutor() : 创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(n) : 创建一个线程池，它可安排在给定延迟后运行命令或者定期的执行。 线程池参数 corePoolSize: 核心池的大小 默认情况下，创建了线程池后，线程数为0，当有任务来之后，就会创建一个线程去执行任务。 当线程池中线程数量达到corePoolSize，就会把到达的任务放到队列中等待。 maximumPoolSize: 最大线程数 corePoolSize和maximumPoolSize之间的线程会自动释放，小于等于corePoolSize的不会释放。当大于了这个值就会将任务由一个丢弃处理机制来处理。 keepAliveTime: 线程没有任务时最多保持多长时间后会终止 默认只限于corePoolSize和maimumPoolSize之间的线程 TimeUnit keepAliveTime的时间单位 BlockingQueue: 存储等待执行的任务的阻塞队列，有多种选择，可以是顺序队列、链式队列等。 ThreadFactory： 线程工厂，默认是DefaultThreadFactory,Executors的静态内部类 Rejected Execution Handler： 拒绝处理任务时的策略，如果线程池的线程已经饱和，并且任务队列也已满，对新的任务应该采取什么策略。 比如抛出异常、直接舍弃、丢弃队列种最旧任务等，默认是直接抛出异常。 CallerRunsPolicy: 如果发现线程池还在运行，就直接运行这个线程 DiscardOldestPolicy: 在线程池的等待队列中，将头取出一个抛弃，然后将当前线程放进去 DiscardPolicy： 什么也不做 AbortPolicy：java默认，抛出一个异常 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/multithreading/multithreading.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 16:54:14 "},"network-programming/network-programming.html":{"url":"network-programming/network-programming.html","title":"网络编程","keywords":"","body":"6-网络编程 6.1IP地址 IP地址是唯一表示网络上的每台计算机。由4个8位二进制组成。 IP地址=网络地址+主机地址。 网络地址：标识计算机或网络设备所在的网段。 主机地址：标识特定主机或网路设备。 6.2DNS域名解析 6.3网络服务器 在网络环境下，具有较高计算能力，能够提供用户服务功能的计算机。 6.4网络通信协议 为了在网络中不同的计算机之间进行通信而建立的规则、标准或约定的集合。 6.5Socket Socket称为“套接字”，是通信链路的端点。是提供给应用程序的接口。位于在java.net包中。 6.6基于TCP协议的Socket编程 用来实现双向安全连接网络通信。进行网络通信时，Socket需要借助数据流来完成数据的传递工作。 客户端发送信息给服务器端 import java.net.*; import java.io.*; public class LoginClient { public static void main(String[] args) { try { //建立客户端Socket连接，指定服务器的位置以及端口 Socket socket=new Socket(\"localhost\",8800); //打开输入输出流 OutputStream os=socket.getOutputStream(); //发送客户端登录信息，即向输出流写入信息 String info=\"用户名：Tom;用户密码：123456\"; os.write(info.getBytes()); //关闭资源 os.close(); socket.close(); } catch (UnknownHostException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } import java.net.*; import java.io.*; public class LoginServer { public static void main(String[] args) { try { //建立一个服务器Socket（ServerSocket）指定端口并开始监听 ServerSocket serverSocket=new ServerSocket(8800); //使用accept()方法等待客户端触发通信 Socket socket=serverSocket.accept(); //打开输入输出流 InputStream is=socket.getInputStream(); //获取客户端信息，即从输入流读取信息 BufferedReader br=new BufferedReader(new InputStreamReader(is)); String info=null; while(!((info=br.readLine())==null)){ System.out.println(\"我是服务器，客户登录信息为：\"+info); } //关闭资源 br.close(); is.close(); socket.close(); serverSocket.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 客户端发送对象给服务器端 import java.io.Serializable; /* *用户类：用户名和密码 */ public class User implements Serializable { private String userName; private String pwd; public User() { } public User(String userName, String pwd) { this.userName = userName; this.pwd = pwd; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } } import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.ObjectOutputStream; import java.io.OutputStream; import java.net.Socket; import java.net.UnknownHostException; /* * 客户端 * */ public class LoginClient { public static void main(String[] args) { try { //1、创建一个客户端Socket Socket socket=new Socket(\"localhost\",5000); //2、通过输出流发送请求 OutputStream os=socket.getOutputStream(); User user=new User(\"TOM\",\"123456\"); ObjectOutputStream oos=new ObjectOutputStream(os); oos.writeObject(user); socket.shutdownOutput(); //通过输入流来接收到服务器给客户端的响应 InputStream is=socket.getInputStream(); BufferedReader br=new BufferedReader(new InputStreamReader(is)); String reply; while((reply=br.readLine())!=null){ System.out.println(\"服务器的响应：\"+reply); } //3、释放资源 br.close(); is.close(); os.close(); socket.close(); } catch (UnknownHostException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.ObjectInputStream; import java.io.OutputStream; import java.net.ServerSocket; import java.net.Socket; /* * 服务器端 * */ public class LoginServer { public static void main(String[] args) { try { //1.创建一个服务器Socket ServerSocket serverSocket=new ServerSocket(5000); //2.使用accept()等待客户的通信 Socket socket=serverSocket.accept(); //3.获得输入流，获得相应的用户请求 InputStream is=socket.getInputStream(); ObjectInputStream ois=new ObjectInputStream(is); User user=(User)ois.readObject(); System.out.println(\"我是服务器，接收到的信息：\"+user.getUserName()+\"--\"+user.getPwd()); //给客户端一个响应 String reply=\"欢迎登录！\"; byte[] replys=reply.getBytes(); OutputStream os=socket.getOutputStream(); os.write(replys); //4.释放相应资源 os.close(); ois.close(); is.close(); socket.close(); serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } } 多客户端用户登录 import java.io.Serializable; /** * 用户类 * */ public class User implements Serializable{ private String loginName; //用户名 private String pwd; //用户密码 public User() { } public User(String loginName, String pwd) { super(); this.loginName = loginName; this.pwd = pwd; } public String getLoginName() { return loginName; } public void setLoginName(String loginName) { this.loginName = loginName; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } } import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.OutputStream; import java.net.Socket; import java.net.UnknownHostException; public class LoginThread extends Thread { Socket socket=null; //每启动一个线程，对应Socket public LoginThread(Socket socket){ this.socket=socket; } //启动线程，即响应客户请求 public void run(){ try { //打开输入输出流 InputStream is=socket.getInputStream(); OutputStream os=socket.getOutputStream(); //反序列化 ObjectInputStream ois=new ObjectInputStream(is); //获取客户端信息，即从输入流读取信息 //BufferedReader br=new BufferedReader(new InputStreamReader(ois)); User user=(User)ois.readObject(); if(!(user==null)){ System.out.println(\"我是服务器，客户登录信息为：\"+user.getLoginName()+\",\"+user.getPwd()); } //给客户端一个响应，即向输出流写入信息 String reply=\"欢迎你，登录成功!\"; os.write(reply.getBytes()); //关闭资源 ois.close(); os.close(); is.close(); socket.close(); } catch (UnknownHostException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }catch (ClassNotFoundException e) { e.printStackTrace(); } } } import java.net.*; import java.io.*; public class LoginClient { public static void main(String[] args) { try { //建立客户端Socket连接，指定服务器的位置以及端口 Socket socket=new Socket(\"localhost\",8800); //打开输入输出流 OutputStream os=socket.getOutputStream(); InputStream is=socket.getInputStream(); //对象序列化 ObjectOutputStream oos=new ObjectOutputStream(os); //发送客户端登录信息，即向输出流写入信息 User user=new User(); user.setLoginName(\"Tom\"); user.setPwd(\"123456\"); oos.writeObject(user); socket.shutdownOutput(); //接收服务器段的响应，即从输入流读取信息 String reply=null; BufferedReader br=new BufferedReader(new InputStreamReader(is)); while(!((reply=br.readLine())==null)){ System.out.println(\"我是客户端，服务器的响应为：\"+reply); } //4.关闭资源 oos.close(); is.close(); os.close(); socket.close(); } catch (UnknownHostException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } import java.net.*; import java.io.*; public class LoginClient2 { public static void main(String[] args) { try { //建立客户端Socket连接，指定服务器的位置以及端口 Socket socket=new Socket(\"localhost\",8800); //打开输入输出流 OutputStream os=socket.getOutputStream(); InputStream is=socket.getInputStream(); //对象序列化 ObjectOutputStream oos=new ObjectOutputStream(os); //发送客户端登录信息，即向输出流写入信息 User user=new User(); user.setLoginName(\"Kate\"); user.setPwd(\"654321\"); oos.writeObject(user); socket.shutdownOutput(); //接收服务器段的响应，即从输入流读取信息 String reply=null; BufferedReader br=new BufferedReader(new InputStreamReader(is)); while(!((reply=br.readLine())==null)){ System.out.println(\"我是客户端，服务器的响应为：\"+reply); } //4.关闭资源 oos.close(); is.close(); os.close(); socket.close(); } catch (UnknownHostException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } import java.net.*; import java.io.*; public class LoginServer { public static void main(String[] args) { try { //建立一个服务器Socket（ServerSocket）指定端口并开始监听 ServerSocket serverSocket=new ServerSocket(8800); //使用accept()方法等待客户端触发通信 Socket socket=null; //监听一直进行中 while(true){ socket=serverSocket.accept(); LoginThread LoginThread=new LoginThread(socket); LoginThread.start(); } } catch (UnknownHostException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } 6.7基于UDP协议的Socket编程 客户端返送信息给服务器端 import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.SocketException; import java.net.UnknownHostException; /* * 客户端 * */ public class LoginClient { public static void main(String[] args) { String info=\"您好，我想咨询一个问题！\"; byte[] infos=info.getBytes(); DatagramSocket socket=null; try { InetAddress ia=InetAddress.getByName(\"localhost\"); //构建客户端要发送的数据包对象 DatagramPacket dp=new DatagramPacket(infos, infos.length,ia,5000); //客户端需要一个DatagramSocket对象 socket=new DatagramSocket(); //通过DatagramSocket对象发送数据包到服务器 socket.send(dp); //接收服务器的响应 byte[] replys=new byte[1024]; DatagramPacket dp1=new DatagramPacket(replys, replys.length); socket.receive(dp1); String reply=new String(dp1.getData(),0,dp1.getData().length); System.out.println(\"服务器回应：\"+reply); } catch (UnknownHostException e) { e.printStackTrace(); } catch (SocketException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally{ //释放资源 socket.close(); } } } import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketAddress; import java.net.SocketException; /** * 服务器端 * */ public class LoginServer { public static void main(String[] args) { byte[] infos=new byte[1024]; DatagramPacket dp=new DatagramPacket(infos, infos.length); DatagramSocket socket=null; try { socket=new DatagramSocket(5000); //接收客户端的数据包，并将信息封装在dp中 socket.receive(dp); //构建一个字符串 String info=new String(dp.getData(),0,dp.getData().length); System.out.println(\"客户端说：\"+info); //给客户端一个响应 String reply=\"您好，我在，请说！\"; //客户端的地址 SocketAddress sa=dp.getSocketAddress(); //打一个包裹 DatagramPacket dp1= new DatagramPacket(reply.getBytes(),0,reply.getBytes().length,sa); //将包裹寄走 socket.send(dp1); } catch (SocketException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally{ socket.close(); } } } 练习 1、模拟用户登录的功能? 2、多客户端用户登录? 3、客户咨询问题? 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/network-programming/network-programming.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 16:55:18 "},"reflect/reflect.html":{"url":"reflect/reflect.html","title":"反射","keywords":"","body":"反射 主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。 反射是Java中一种强大的工具，能够使我们很方便的创建灵活的代码，这些代码可以再运行时装配，无需在组件之间进行源代码链接。但是反射使用不当会成本很高！ PS:通过反射的机制创建对象，获取类中的属性和方法，并调用类中的属性和方法; 二、反射的作用 1.反编译：.class-->.java 2.通过反射机制访问java对象的属性，方法，构造方法等；这样好像更容易理解一些，下边我们具体看怎么实现这些功能。 三、JDK提供的反射类 java.lang.Class;java.lang.reflect.Constructor; java.lang.reflect.Field;java.lang.reflect.Method; java.lang.reflect.Modifier; 四、反射的API 1.获取类的方法： a)Class.forName (“类的全路径”); b)类名.class c)对象.getClass(); 2.创建对象 a)newInstance(); 3.获取属性 public Field[] getFields()； 获取当前class中所有的公共属性 public Field getField(String name)； 获取当前class中指定属性名的公共属性 public Field[] getDeclaredFields()； 获取当前class中所有的属性包含私有的 public Field getDeclaredField(String name)； 获取当前class中指定属性名的属性包含私有的 4.获取方法 public Method getMethod(String name, Class... parameterTypes) 获取指定方法名和参数列表的方法 public Method[] getMethods() 获取所有的方法 public Method getDeclaredMethod(String name,Class... parameterTypes) 获取指定方法名和参数列表的方法，包含私有的 public Method[] getDeclaredMethods() 获取所有的方法，包含私有的 5.执行方法： 调用Method对象中的public Object invoke(Object obj, Object... args)方法。 五、反射的应用 1.反射的应用：Servlet、各大框架… 等都利用了java的反射机制； 例：简单工厂模式+反射改进 连接不同的数据库 /** 数据库接口 @author Administrator / public interface DataSource { public void init(); public void select(); public void insert(); } /** 数据库抽象类：可以扩展 @author Administrator / public abstract class AbstractDataSource implements DataSource { private String driverClass; private String url; private String user; private String password; } public class Oralce extends AbstractDataSource { @Override public void init() { System.out.println(\"Oracle连接成功...\"); } @Override public void select() { System.out.println(\"Oralce查询....\"); } @Override public void insert() { System.out.println(\"Oralce添加....\"); } } public class MySql extends AbstractDataSource { @Override public void init() { System.out.println(\"Mysql连接成功...\"); } @Override public void select() { System.out.println(\"Mysql查询...\"); } @Override public void insert() { System.out.println(\"Mysql添加...\"); } } public class Factory { public static DataSource getDataSource(String className) { DataSource dataSource = null; try { Class c = Class.forName(className); dataSource=(DataSource) c.newInstance(); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } return dataSource; } } public class Test { public static void main(String[] args) { //com.mxp.db.MySql //com.mxp.db.Oralce DataSource dataSource = Factory.getDataSource(\"com.mxp.db.Oralce\"); dataSource.init(); dataSource.select(); dataSource.insert(); } } 模仿servlet /** 预订义好的抽象类 @author Administrator / public abstract class HttpServlet { public abstract void doGet(); public abstract void doPost(); } /** 反射并调用HttpServlet中的方法 @author Administrator / public class Servlet { /** @param method :get post @param className */ public void execute(String method, String className) { try { Class c = Class.forName(className); HttpServlet servlet = (HttpServlet) c.newInstance(); method = \"do\" + String.valueOf(method.charAt(0)).toUpperCase() + method.substring(1); Method m = c.getMethod(method); m.invoke(servlet); } catch (Exception e) { e.printStackTrace(); } } } /** 用户自定义的实现类 @author Administrator / public class UserServlet extends HttpServlet { @Override public void doGet() { System.out.println(\"UserServlet is doGet\"); } @Override public void doPost() { System.out.println(\"UserServlet is doPost\"); } } /** 测试类 @author Administrator / public class Test { public static void main(String[] args) { String className = \"com.mxp.servlet.UserServlet\"; String method = \"post\"; Servlet servlet = new Servlet(); servlet.execute(method, className); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/reflect/reflect.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 16:55:51 "},"xml/xml.html":{"url":"xml/xml.html","title":"XML","keywords":"","body":"7-XML XML简介 可扩展标记语言 特点 与操作系统、编程语言的开发平台无关 实现不同系统之间的数据交换 作用 - 数据交互 - 配置应用程序和网站 - Ajax基石 XML保存衣服尺码信息 S M L XL XXL Dom解析XML：手机品牌和型号的增删改查 import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; import java.io.UnsupportedEncodingException; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.OutputKeys; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerConfigurationException; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.xml.sax.SAXException; public class ParseXMLDemo { private Document document=null; public static void main(String[] args) { ParseXMLDemo pd=new ParseXMLDemo(); pd.getDocument(); pd.showInfo(); // pd.add(); // pd.update(); // pd.savaXML(\"new.xml\"); // pd.delete(); } public void getDocument(){ DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance(); try { DocumentBuilder builder=factory.newDocumentBuilder(); document=builder.parse(\"收藏信息.xml\"); } catch (ParserConfigurationException e) { e.printStackTrace(); } catch (SAXException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } //获取手机品牌和属性 public void showInfo(){ NodeList brands=document.getElementsByTagName(\"Brand\"); for(int i=0;i Dom4j解析XML：手机品牌和型号的增删改查 import java.io.File; import java.io.FileWriter; import java.io.IOException; import java.util.Iterator; import org.dom4j.Document; import org.dom4j.Element; import org.dom4j.io.OutputFormat; import org.dom4j.io.SAXReader; import org.dom4j.io.XMLWriter; public class Dom4j { public static Document doc; public static void main(String[] args) { loadDocument(); // showPhoneInfo(); // saveXML(\"src/新收藏.xml\"); // addNewPhoneInfo(); // updatePhoneInfo(); deleteItem(); showPhoneInfo(); } public static void loadDocument(){ try{ SAXReader saxReader = new SAXReader(); doc = saxReader.read(new File(\"src/收藏信息.xml\")); }catch (Exception e) { // TODO: handle exception e.printStackTrace(); } } public static void updatePhoneInfo(){ // 获取XML的根节点 Element root = doc.getRootElement(); int id = 0; for (Iterator itBrand = root.elementIterator(); itBrand.hasNext();) { Element brand = (Element) itBrand.next(); id++; brand.addAttribute(\"id\", id + \"\"); } saveXML(\"src/收藏信息.xml\"); } public static void deleteItem(){ // 获取XML的根节点 Element root = doc.getRootElement(); int id = 0; for (Iterator itBrand = root.elementIterator(); itBrand.hasNext();) { Element brand = (Element) itBrand.next(); if (brand.attributeValue(\"name\").equals(\"华为\")) { brand.getParent().remove(brand); } } // saveXML(\"src/收藏信息.xml\"); } public static void showPhoneInfo() { // 获取XML的根节点 Element root = doc.getRootElement(); // 遍历所有的Brand标签 for (Iterator itBrand = root.elementIterator(); itBrand.hasNext();) { Element brand = (Element) itBrand.next(); // 输出标签的name属性 System.out.println(\"品牌：\" + brand.attributeValue(\"name\")); // 遍历Type标签 for (Iterator itType = brand.elementIterator(); itType.hasNext();) { Element type = (Element) itType.next(); // 输出标签的name属性 System.out.println(\"\\t型号：\" + type.attributeValue(\"name\")); } } } public static void saveXML(String path){ try { OutputFormat format = OutputFormat.createPrettyPrint(); format.setEncoding(\"GBK\"); // 指定XML编码 XMLWriter writer; writer = new XMLWriter(new FileWriter(path), format); writer.write(doc); writer.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } public static void addNewPhoneInfo(){ // 获取XML的根节点 Element root = doc.getRootElement(); // 创建Brand标签 Element el = root.addElement(\"Brand\"); // 给Brand标签设置属性 el.addAttribute(\"name\", \"三星\"); // 创建Type标签 Element typeEl = el.addElement(\"Type\"); // 给Type标签设置属性 typeEl.addAttribute(\"name\", \"Note4\"); saveXML(\"src/收藏信息.xml\"); } } import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.OutputKeys; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerConfigurationException; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.xml.sax.SAXException; public class Main { public static Document doc; public static void main(String[] args) { deleteItem(); } public static void updatePhoneInfo(){ try { // 1、得到DOM解析器的工厂实例 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); // 2、从DOM工厂获得DOM解析器 DocumentBuilder db = dbf.newDocumentBuilder(); // 3、解析XML文档，得到一个Document，即DOM树 doc = db.parse(\"src/收藏信息.xml\"); NodeList list = doc.getElementsByTagName(\"Brand\"); for(int i = 0; i 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/xml/xml.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 17:04:09 "},"design-mode/design-mode.html":{"url":"design-mode/design-mode.html","title":"设计模式","keywords":"","body":"设计模式 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式类型 序号 模式 & 描述 包括 1 创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） 2 结构型模式 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） 3 行为型模式 这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） 4 J2EE 模式 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern） 设计模式之间关系 设计模式的6大原则 1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5、迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 工厂模式 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 介绍 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，\"POP3\"、\"IMAP\"、\"HTTP\"，可以把这三个作为产品类，共同实现一个接口。 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 实现 我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。 FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。 步骤 1 创建一个接口: Shape.java public interface Shape { void draw(); } 步骤 2 创建实现接口的实体类。 Rectangle.java public class Rectangle implements Shape { @Override public void draw() { System.out.println(\"Inside Rectangle::draw() method.\"); } } Square.java public class Square implements Shape { @Override public void draw() { System.out.println(\"Inside Square::draw() method.\"); } } Circle.java public class Circle implements Shape { @Override public void draw() { System.out.println(\"Inside Circle::draw() method.\"); } } 步骤3 创建一个工厂，生成基于给定信息的实体类的对象。 ShapeFactory.java public class ShapeFactory { //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType){ if(shapeType == null){ return null; } if(shapeType.equalsIgnoreCase(\"CIRCLE\")){ return new Circle(); } else if(shapeType.equalsIgnoreCase(\"RECTANGLE\")){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(\"SQUARE\")){ return new Square(); } return null; } } 步骤 4 使用该工厂，通过传递类型信息来获取实体类的对象。 FactoryPatternDemo.java public class FactoryPatternDemo { public static void main(String[] args) { ShapeFactory shapeFactory = new ShapeFactory(); //获取 Circle 的对象，并调用它的 draw 方法 Shape shape1 = shapeFactory.getShape(\"CIRCLE\"); //调用 Circle 的 draw 方法 shape1.draw(); //获取 Rectangle 的对象，并调用它的 draw 方法 Shape shape2 = shapeFactory.getShape(\"RECTANGLE\"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取 Square 的对象，并调用它的 draw 方法 Shape shape3 = shapeFactory.getShape(\"SQUARE\"); //调用 Square 的 draw 方法 shape3.draw(); } } 步骤 5 执行程序，输出结果： Inside Circle::draw() method. Inside Rectangle::draw() method. Inside Square::draw() method. 抽象工厂模式 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 介绍 意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 主要解决：主要解决接口选择的问题。 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。 如何解决：在一个产品族里面，定义多个产品。 关键代码：在一个工厂里聚合多个同类产品。 应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。 注意事项：产品族难扩展，产品等级易扩展。 实现 我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。 AbstractFactoryPatternDemo，我们的演示类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。 步骤 1 为形状创建一个接口。 Shape.java public interface Shape { void draw(); } 步骤2 创建实现接口的实体类。 Rectangle.java public class Rectangle implements Shape { @Override public void draw() { System.out.println(\"Inside Rectangle::draw() method.\"); } } Square.java public class Square implements Shape { @Override public void draw() { System.out.println(\"Inside Square::draw() method.\"); } } Circle.java public class Circle implements Shape { @Override public void draw() { System.out.println(\"Inside Circle::draw() method.\"); } } 步骤3 为颜色创建一个接口。 Color.java public interface Color { void fill(); } 步骤4 创建实现接口的实体类。 Red.java public class Red implements Color { @Override public void fill() { System.out.println(\"Inside Red::fill() method.\"); } } Green.java public class Green implements Color { @Override public void fill() { System.out.println(\"Inside Green::fill() method.\"); } } Blue.java public class Blue implements Color { @Override public void fill() { System.out.println(\"Inside Blue::fill() method.\"); } } 步骤5 为 Color 和 Shape 对象创建抽象类来获取工厂。 AbstractFactory.java public abstract class AbstractFactory { public abstract Color getColor(String color); public abstract Shape getShape(String shape) ; } 步骤6 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。 ShapeFactory.java public class ShapeFactory extends AbstractFactory { @Override public Shape getShape(String shapeType){ if(shapeType == null){ return null; } if(shapeType.equalsIgnoreCase(\"CIRCLE\")){ return new Circle(); } else if(shapeType.equalsIgnoreCase(\"RECTANGLE\")){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(\"SQUARE\")){ return new Square(); } return null; } @Override public Color getColor(String color) { return null; } } ColorFactory.java public class ColorFactory extends AbstractFactory { @Override public Shape getShape(String shapeType){ return null; } @Override public Color getColor(String color) { if(color == null){ return null; } if(color.equalsIgnoreCase(\"RED\")){ return new Red(); } else if(color.equalsIgnoreCase(\"GREEN\")){ return new Green(); } else if(color.equalsIgnoreCase(\"BLUE\")){ return new Blue(); } return null; } } 步骤 7 创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。 FactoryProducer.java public class FactoryProducer { public static AbstractFactory getFactory(String choice){ if(choice.equalsIgnoreCase(\"SHAPE\")){ return new ShapeFactory(); } else if(choice.equalsIgnoreCase(\"COLOR\")){ return new ColorFactory(); } return null; } } 步骤 8 使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。 AbstractFactoryPatternDemo.java public class AbstractFactoryPatternDemo { public static void main(String[] args) { //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory(\"SHAPE\"); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape(\"CIRCLE\"); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape(\"RECTANGLE\"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape(\"SQUARE\"); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory(\"COLOR\"); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor(\"RED\"); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor(\"Green\"); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor(\"BLUE\"); //调用 Blue 的 fill 方法 color3.fill(); } } 步骤 9 执行程序，输出结果： Inside Circle::draw() method. Inside Rectangle::draw() method. Inside Square::draw() method. Inside Red::fill() method. Inside Green::fill() method. Inside Blue::fill() method. 单例模式 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意： 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 介绍 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 应用实例： 1、一个班级只有一个班主任。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 实现 我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。 SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。 步骤 1 创建一个 Singleton 类。 SingleObject.java public class SingleObject { //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject(){} //获取唯一可用的对象 public static SingleObject getInstance(){ return instance; } public void showMessage(){ System.out.println(\"Hello World!\"); } } 步骤 2 从 singleton 类获取唯一的对象。 SingletonPatternDemo.java public class SingletonPatternDemo { public static void main(String[] args) { //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); } } 步骤 3 执行程序，输出结果： Hello World! 单例模式的几种实现方式 单例模式的实现有多种方式，如下所示： 1、懒汉式，线程不安全 是否 Lazy 初始化：是 是否多线程安全：否 实现难度：易 描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 实例 public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。 2、懒汉式，线程安全 是否 Lazy 初始化：是 是否多线程安全：是 实现难度：易 描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。 优点：第一次调用才初始化，避免内存浪费。 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 实例 public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 3、饿汉式 是否 Lazy 初始化：否 是否多线程安全：是 实现难度：易 描述：这种方式比较常用，但容易产生垃圾对象。 优点：没有加锁，执行效率会提高。 缺点：类加载时就初始化，浪费内存。 它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。 实例 public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } } 4、双检锁/双重校验锁（DCL，即 double-checked locking） JDK 版本：JDK1.5 起 是否 Lazy 初始化：是 是否多线程安全：是 实现难度：较复杂 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 getInstance() 的性能对应用程序很关键。 实例 public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 5、登记式/静态内部类 是否 Lazy 初始化：是 是否多线程安全：是 实现难度：一般 描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。 实例 public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } 6、枚举 JDK 版本：JDK1.5 起 是否 Lazy 初始化：否 是否多线程安全：是 实现难度：易 描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。 不能通过 reflection attack 来调用私有构造方法。 实例 public enum Singleton { INSTANCE; public void whateverMethod() { } } 经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。 适配器模式 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。 介绍 意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 主要解决：主要解决在软件系统中，常常要将一些\"现存的对象\"放到新的环境中，而新环境要求的接口是现对象不能满足的。 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） 如何解决：继承或依赖（推荐）。 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。 应用实例： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。 优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。 缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。 使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。 注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。 实现 我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。 我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。 我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。 AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo，我们的演示类使用 AudioPlayer 类来播放各种格式。 步骤1 为媒体播放器和更高级的媒体播放器创建接口。 MediaPlayer.java public interface MediaPlayer { public void play(String audioType, String fileName); } AdvancedMediaPlayer.java public interface AdvancedMediaPlayer { public void playVlc(String fileName); public void playMp4(String fileName); } 步骤 2 创建实现了 AdvancedMediaPlayer 接口的实体类。 VlcPlayer.java public class VlcPlayer implements AdvancedMediaPlayer{ @Override public void playVlc(String fileName) { System.out.println(\"Playing vlc file. Name: \"+ fileName); } @Override public void playMp4(String fileName) { //什么也不做 } } Mp4Player.java public class Mp4Player implements AdvancedMediaPlayer{ @Override public void playVlc(String fileName) { //什么也不做 } @Override public void playMp4(String fileName) { System.out.println(\"Playing mp4 file. Name: \"+ fileName); } } 步骤 3 创建实现了 MediaPlayer 接口的适配器类。 MediaAdapter.java public class MediaAdapter implements MediaPlayer { AdvancedMediaPlayer advancedMusicPlayer; public MediaAdapter(String audioType){ if(audioType.equalsIgnoreCase(\"vlc\") ){ advancedMusicPlayer = new VlcPlayer(); } else if (audioType.equalsIgnoreCase(\"mp4\")){ advancedMusicPlayer = new Mp4Player(); } } @Override public void play(String audioType, String fileName) { if(audioType.equalsIgnoreCase(\"vlc\")){ advancedMusicPlayer.playVlc(fileName); }else if(audioType.equalsIgnoreCase(\"mp4\")){ advancedMusicPlayer.playMp4(fileName); } } } 步骤 4 创建实现了 MediaPlayer 接口的实体类。 AudioPlayer.java public class AudioPlayer implements MediaPlayer { MediaAdapter mediaAdapter; @Override public void play(String audioType, String fileName) { //播放 mp3 音乐文件的内置支持 if(audioType.equalsIgnoreCase(\"mp3\")){ System.out.println(\"Playing mp3 file. Name: \"+ fileName); } //mediaAdapter 提供了播放其他文件格式的支持 else if(audioType.equalsIgnoreCase(\"vlc\") || audioType.equalsIgnoreCase(\"mp4\")){ mediaAdapter = new MediaAdapter(audioType); mediaAdapter.play(audioType, fileName); } else{ System.out.println(\"Invalid media. \"+ audioType + \" format not supported\"); } } } 步骤 5 使用 AudioPlayer 来播放不同类型的音频格式。 AdapterPatternDemo.java public class AdapterPatternDemo { public static void main(String[] args) { AudioPlayer audioPlayer = new AudioPlayer(); audioPlayer.play(\"mp3\", \"beyond the horizon.mp3\"); audioPlayer.play(\"mp4\", \"alone.mp4\"); audioPlayer.play(\"vlc\", \"far far away.vlc\"); audioPlayer.play(\"avi\", \"mind me.avi\"); } } 步骤 6 执行程序，输出结果： Playing mp3 file. Name: beyond the horizon.mp3 Playing mp4 file. Name: alone.mp4 Playing vlc file. Name: far far away.vlc Invalid media. avi format not supported 代理模式 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 介绍 意图：为其他对象提供一种代理以控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 何时使用：想在访问一个类时做一些控制。 如何解决：增加中间层。 关键代码：实现与被代理类组合。 应用实例： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。 优点： 1、职责清晰。 2、高扩展性。 3、智能化。 缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 使用场景：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。 注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 实现 我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。 ProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。 步骤 1 创建一个接口。 Image.java public interface Image { void display(); } 步骤 2 创建实现接口的实体类。 RealImage.java public class RealImage implements Image { private String fileName; public RealImage(String fileName){ this.fileName = fileName; loadFromDisk(fileName); } @Override public void display() { System.out.println(\"Displaying \" + fileName); } private void loadFromDisk(String fileName){ System.out.println(\"Loading \" + fileName); } } ProxyImage.java public class ProxyImage implements Image{ private RealImage realImage; private String fileName; public ProxyImage(String fileName){ this.fileName = fileName; } @Override public void display() { if(realImage == null){ realImage = new RealImage(fileName); } realImage.display(); } } 步骤 3 当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。 ProxyPatternDemo.java public class ProxyPatternDemo { public static void main(String[] args) { Image image = new ProxyImage(\"test_10mb.jpg\"); // 图像将从磁盘加载 image.display(); System.out.println(\"\"); // 图像不需要从磁盘加载 image.display(); } } 步骤 4 执行程序，输出结果： Loading test_10mb.jpg Displaying test_10mb.jpg Displaying test_10mb.jpg 原型模式 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 介绍 意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 主要解决：在运行期建立和删除原型。 何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。 关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些\"易变类\"拥有稳定的接口。 应用实例： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。 优点： 1、性能提高。 2、逃避构造函数的约束。 缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。 使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。 注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。 实现 我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。 PrototypePatternDemo，我们的演示类使用 ShapeCache 类来获取 Shape 对象。 步骤1 创建一个实现了 Cloneable 接口的抽象类。 Shape.java public abstract class Shape implements Cloneable { private String id; protected String type; abstract void draw(); public String getType(){ return type; } public String getId() { return id; } public void setId(String id) { this.id = id; } public Object clone() { Object clone = null; try { clone = super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return clone; } } 步骤 2 创建扩展了上面抽象类的实体类。 Rectangle.java public class Rectangle extends Shape { public Rectangle(){ type = \"Rectangle\"; } @Override public void draw() { System.out.println(\"Inside Rectangle::draw() method.\"); } } Square.java public class Square extends Shape { public Square(){ type = \"Square\"; } @Override public void draw() { System.out.println(\"Inside Square::draw() method.\"); } } Circle.java public class Circle extends Shape { public Circle(){ type = \"Circle\"; } @Override public void draw() { System.out.println(\"Inside Circle::draw() method.\"); } } 步骤 3 创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中。 ShapeCache.java import java.util.Hashtable; public class ShapeCache { private static Hashtable shapeMap = new Hashtable(); public static Shape getShape(String shapeId) { Shape cachedShape = shapeMap.get(shapeId); return (Shape) cachedShape.clone(); } // 对每种形状都运行数据库查询，并创建该形状 // shapeMap.put(shapeKey, shape); // 例如，我们要添加三种形状 public static void loadCache() { Circle circle = new Circle(); circle.setId(\"1\"); shapeMap.put(circle.getId(),circle); Square square = new Square(); square.setId(\"2\"); shapeMap.put(square.getId(),square); Rectangle rectangle = new Rectangle(); rectangle.setId(\"3\"); shapeMap.put(rectangle.getId(),rectangle); } } 步骤 4 PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。 PrototypePatternDemo.java public class PrototypePatternDemo { public static void main(String[] args) { ShapeCache.loadCache(); Shape clonedShape = (Shape) ShapeCache.getShape(\"1\"); System.out.println(\"Shape : \" + clonedShape.getType()); Shape clonedShape2 = (Shape) ShapeCache.getShape(\"2\"); System.out.println(\"Shape : \" + clonedShape2.getType()); Shape clonedShape3 = (Shape) ShapeCache.getShape(\"3\"); System.out.println(\"Shape : \" + clonedShape3.getType()); } } 步骤 5 执行程序，输出结果： Shape : Circle Shape : Square Shape : Rectangle 作者: 悟空非空也 链接: https://wukongnotnull.github.io/javase-qingtong-wukongnote/design-mode/design-mode.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-07 17:30:28 "}}